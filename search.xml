<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>docker安装部署以及Dockerfile</title>
    <url>/2020/06/11/install-docker/</url>
    <content><![CDATA[<h2 id="docker安装准备"><a href="#docker安装准备" class="headerlink" title="docker安装准备"></a>docker安装准备</h2><p>关闭防火墙和selinux<br><br>centos6<br></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo  service  iptables  stop</span><br><span class="line">sudo  service  ip6tables  stop</span><br></pre></td></tr></table></figure>
<p>centos7</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo  systemctl stop  firewalld</span><br></pre></td></tr></table></figure>
<p>关闭开启自启动</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo  chkconfig  iptables  off   </span><br><span class="line">sudo  chkconfig  ip6tables  off</span><br></pre></td></tr></table></figure>
<p>临时关闭selinux</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo  setenforce 0</span><br></pre></td></tr></table></figure>
<p>永久关闭selinux</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo  vim  /etc/selinux/config</span><br><span class="line">        SELINUX=disabled</span><br></pre></td></tr></table></figure>
<p>重启生效</p>
<p>Docker 要求 CentOS 系统的内核版本高于 3.10，查看本页面的前提条件来验证你的CentOS 版本是否支持 Docker</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[sgsm@localhost ~]$ uname -r</span><br><span class="line">3.10.0-514.21.2.el7.x86_64</span><br><span class="line">[sgsm@localhost ~]$</span><br></pre></td></tr></table></figure>
<p>如果版本较低需要升级内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 更新yum库</span></span><br><span class="line">yum update   </span><br><span class="line"><span class="comment"># 升级内核版本（包含aufs）</span></span><br><span class="line"><span class="built_in">cd</span> /etc/yum.repos.d</span><br><span class="line">wget http://www.hop5.in/yum/el6/hop5.repo</span><br><span class="line">yum install kernel-ml-aufs kernel-ml-aufs-devel -y</span><br></pre></td></tr></table></figure>
<p>更新后需要修改配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo  vi /etc/grub.conf</span><br><span class="line">    <span class="comment"># 把默认的引导文件设置为0。因为升级内核之后，新的内核在第一个（0）位置</span></span><br><span class="line">    default=0</span><br></pre></td></tr></table></figure>
<p>最后重启系统,再次查看就是3.10版本了</p>
<h2 id="docker安装部署"><a href="#docker安装部署" class="headerlink" title="docker安装部署"></a>docker安装部署</h2><p>因为epel源中就有docker所以直接用epel源安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo  yum install  epel-release   -y</span><br><span class="line">sudo  yum install  docker-io   -y</span><br><span class="line">sudo  yum install docker-ce -y</span><br></pre></td></tr></table></figure>
<p>启动docker</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo  systemctl start  docker</span><br></pre></td></tr></table></figure>

<h2 id="docker-镜像"><a href="#docker-镜像" class="headerlink" title="docker 镜像"></a>docker 镜像</h2><p>搜寻镜像 $docker search 关键字</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[sgsm@localhost ~]$ sudo docker  search  centos7.2  </span><br><span class="line">INDEX       NAME                                             DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED</span><br><span class="line">docker.io   docker.io/kecikeci/centos7.2-tools               centos7.2+阿里云yum源+ssh密码登录+常用软件 基于官方centos7...   3                    </span><br><span class="line">docker.io   docker.io/13652604711/centos7.2-ssh                                                              2                    </span><br><span class="line">docker.io   docker.io/hasonl/centos7.2                       Centos7.2   System                              1                    </span><br><span class="line">docker.io   docker.io/sssllc/centos7.2-jdk1.8                centos-release-7-2.1511.el7.centos.2.10.x8...   1                    </span><br><span class="line">docker.io   docker.io/yasanbee/centos7.2-systemd             CentOS 7.2 Base Image Dockerfile with syst...   1                    [OK]</span><br><span class="line">docker.io   docker.io/10sr/centos7.2-python2.7               centos7.2-python2.7                             0                    [OK]</span><br><span class="line">docker.io   docker.io/692383247/centos7.2                    centos7.2                                       0                    </span><br><span class="line">docker.io   docker.io/92docker/centos7.2                                                                     0                    </span><br><span class="line">docker.io   docker.io/ailyfeng/centos7.2.1511                centos7.2.1511基础配置                              0                    </span><br><span class="line">docker.io   docker.io/chaoduoli/centos7.2-ssh                账号和密码都为root                                     0                    </span><br><span class="line">docker.io   docker.io/coxy/centos7.2-vagrant                 CentOS 7.2 <span class="keyword">for</span> Vagrant use. Contains SSH, ...   0                    </span><br><span class="line">docker.io   docker.io/daisuke310vvv/centos7.2-java1.7.0                                                      0                    </span><br><span class="line">docker.io   docker.io/dock2box/centos7.2.1511                                                                0                    </span><br><span class="line">docker.io   docker.io/ekzm/centos7.2.1511                                                                    0                    </span><br><span class="line">docker.io   docker.io/elain/centos7.2                        centos7.2 基础镜像                                  0                    </span><br><span class="line">docker.io   docker.io/gengyanping/centos7.2                                                                  0                    </span><br><span class="line">docker.io   docker.io/hizhangsir/centos7.2-jdk1.8            base                                            0                    </span><br><span class="line">docker.io   docker.io/jiezhiz/centos7.2                      base image from centos7.2                       0                    </span><br><span class="line">docker.io   docker.io/pangyu/centos7.2_java                                                                  0                    </span><br><span class="line">docker.io   docker.io/plsicloud/centos7.2-iperf3                                                             0                    </span><br><span class="line">docker.io   docker.io/plsicloud/centos7.2-openmpi2.0.1                                                       0                    </span><br><span class="line">docker.io   docker.io/plsicloud/centos7.2-openmpi2.0.2-hpl                                                   0                    </span><br><span class="line">docker.io   docker.io/qxp2181/centos7.2_mono_jexus           centos7.2_mono_jexus                            0                    </span><br><span class="line">docker.io   docker.io/sibylai/centos7.2-ssh                                                                  0                    </span><br><span class="line">docker.io   docker.io/wodrow/centos7.2                                                                       0                    </span><br><span class="line">[sgsm@localhost ~]$</span><br></pre></td></tr></table></figure>
<p>下载镜像 $ docker pull 镜像名</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[sgsm@localhost ~]$ sudo docker  pull alpine         </span><br><span class="line">Using default tag: latest</span><br><span class="line">Trying to pull repository docker.io/library/alpine ... </span><br><span class="line">latest: Pulling from docker.io/library/alpine</span><br><span class="line">df20fa9351a1: Pull complete </span><br><span class="line">Digest: sha256:185518070891758909c9f839cf4ca393ee977ac378609f700f60a771a2dfe321</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> docker.io/alpine:latest</span><br><span class="line">[sgsm@localhost ~]$</span><br></pre></td></tr></table></figure>
<p>dokcer run hello-world<br><br>pull镜像测试  如果pull失败   需要更改镜像源<br></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo  vim /etc/docker/daemon.json</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="string">"registry-mirrors"</span>: [<span class="string">"https://alzgoonw.mirror.aliyuncs.com"</span>]</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>重启docker</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl restart  docker</span><br></pre></td></tr></table></figure>
<p>默认docker pull的镜像都是最新版本   指定版本需要 docker pull centos:centos7    更精确为 docker pull centos:centos7.2.1511<br><br>例如：<br></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo  docker pull centos:centos7.2.1511</span><br></pre></td></tr></table></figure>
<p>查看docker 镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY                                                           TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">web                                                                  v1.1                84f2139ad784        6 weeks ago         285 MB</span><br><span class="line">docker.io/alpine                                                     latest              f70734b6a266        2 months ago        5.61 MB</span><br><span class="line">docker.io/nginx                                                      latest              602e111c06b6        2 months ago        127 MB</span><br><span class="line">docker.io/centos                                                     latest              470671670cac        5 months ago        237 MB</span><br><span class="line">docker.io/centos                                                     centos7             5e35e350aded        7 months ago        203 MB</span><br><span class="line">docker.io/centos                                                     centos7.2.1511      9aec5c5fe4ba        15 months ago       195 MB</span><br><span class="line">k8s.gcr.io/kube-apiserver                                            v1.13.0             f1ff9b7e3d6e        18 months ago       181 MB</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/kube-apiserver   v1.13.0             f1ff9b7e3d6e        18 months ago       181 MB</span><br><span class="line">[root@localhost ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>参数解释：</p>
<pre><code>REPOSITORY：仓库名称
TAG：标签名，一个仓库可以有若干个标签对应不同的镜像，默认都是latest
IMAGE ID：镜像ID
CREATED：创建时间，注意不是本地的pull时间
SIZE：镜像大小</code></pre><p>删除镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在删除docker镜像前需先删除所有使用此镜像的所有容器才可删除镜像</span></span><br><span class="line">docker rmi &lt;image id&gt;</span><br></pre></td></tr></table></figure>

<h2 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h2><p>创建容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -it  --privileged=<span class="literal">true</span>  -v /bak:/soft  --name web   -d  centos:centos7.2.1511 /usr/sbin/init </span><br><span class="line">    <span class="comment"># 选项</span></span><br><span class="line">     --privileged=<span class="literal">true</span>  赋予root权限,此root不是系统用户root,而是docker容器内的root权限, 不指定在容器内无法启动服务</span><br><span class="line">     -v /bak:/soft    挂载   -v 宿主机目录:容器内目录   </span><br><span class="line">     --name    容器名字</span><br><span class="line">     -d   后台运行</span><br><span class="line">     centos:centos7.2.1511    指定创建容器所使用的的镜像</span><br><span class="line">     /usr/sbin/init        不指定在容器内无法启动服务 报错：Fai led to get D-BuS connect ion: operation not permitted</span><br></pre></td></tr></table></figure>
<p>查看所有容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker ps -a</span></span><br><span class="line">CONTAINER ID        IMAGE                   COMMAND             CREATED             STATUS                                PORTS                            NAMES</span><br><span class="line">56da5506c5a1        centos:centos7.2.1511   <span class="string">"/usr/sbin/init"</span>    6 weeks ago         Exited (137) Less than a second ago                                    web</span><br></pre></td></tr></table></figure>
<p>查看正在运行的容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker ps</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                            NAMES</span><br><span class="line">ccc0f0ca5334        84f2139ad784        <span class="string">"/usr/sbin/init"</span>    6 weeks ago         Up 6 weeks          9001/tcp, 0.0.0.0:9090-&gt;80/tcp   <span class="built_in">test</span></span><br><span class="line">[root@localhost ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>选项</p>
<pre><code>-a：查看所有容器，含停止运行的
-l：查看刚启动的容器
-q：只显示容器ID
-s:显示容器大小
-n=4: 列出最近创建的4个容器</code></pre><p>查看在容器里做过的操作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker  diff  容器id</span><br></pre></td></tr></table></figure>
<p>查看容器运行信息docker stats<br>   <br> docker stats 可以查看到运行状态容器的CPU，内存及网络使用率<br></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker stats  ccc0f0ca5334</span></span><br><span class="line">CONTAINER           CPU %               MEM USAGE / LIMIT      MEM %               NET I/O             BLOCK I/O           PIDS</span><br><span class="line">ccc0f0ca5334        0.01%               1000 KiB / 7.605 GiB   0.01%               7.3 kB / 4.76 kB    531 MB / 179 MB     12</span><br><span class="line">CONTAINER           CPU %               MEM USAGE / LIMIT      MEM %               NET I/O             BLOCK I/O           PIDS</span><br><span class="line">ccc0f0ca5334        0.01%               1000 KiB / 7.605 GiB   0.01%               7.3 kB / 4.76 kB    531 MB / 179 MB     12</span><br><span class="line">CONTAINER           CPU %               MEM USAGE / LIMIT      MEM %               NET I/O             BLOCK I/O           PIDS</span><br><span class="line">ccc0f0ca5334        0.08%               1000 KiB / 7.605 GiB   0.01%               7.3 kB / 4.76 kB    531 MB / 179 MB     12</span><br><span class="line">CONTAINER           CPU %               MEM USAGE / LIMIT      MEM %               NET I/O             BLOCK I/O           PIDS</span><br><span class="line">ccc0f0ca5334        0.08%               1000 KiB / 7.605 GiB   0.01%               7.3 kB / 4.76 kB    531 MB / 179 MB     12</span><br><span class="line">CONTAINER           CPU %               MEM USAGE / LIMIT      MEM %               NET I/O             BLOCK I/O           PIDS</span><br><span class="line">ccc0f0ca5334        0.00%               1000 KiB / 7.605 GiB   0.01%               7.3 kB / 4.76 kB    531 MB / 179 MB     12</span><br><span class="line">CONTAINER           CPU %               MEM USAGE / LIMIT      MEM %               NET I/O             BLOCK I/O           PIDS</span><br><span class="line">ccc0f0ca5334        0.00%               1000 KiB / 7.605 GiB   0.01%               7.3 kB / 4.76 kB    531 MB / 179 MB     12</span><br><span class="line">^C</span><br><span class="line">[root@localhost ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>查看 Docker 容器或镜像的一些内部信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker inspect  ccc0f0ca5334</span><br></pre></td></tr></table></figure>
<p>进入容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it  web  /bin/bash</span><br></pre></td></tr></table></figure>
<p>退出容器不结束容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">使用 ctrl+p + ctrl+q    或者   ctrl+a  + ctrl+d</span><br></pre></td></tr></table></figure>
<p>容器的删除</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除已停止中的容器：</span></span><br><span class="line">docker rm  容器id</span><br><span class="line"><span class="comment"># 删除正常运行的容器：</span></span><br><span class="line">docker rm -f  容器id</span><br></pre></td></tr></table></figure>
<p>关闭容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker  stop  容器id或者容器name</span><br></pre></td></tr></table></figure>

<h2 id="容器内操作"><a href="#容器内操作" class="headerlink" title="容器内操作"></a>容器内操作</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install epel-release -y</span><br><span class="line">yum install net-tools   httpd  vim  elinks    passwd openssl openssh-server     openssl-client  -y</span><br><span class="line"> /usr/sbin/sshd -D &amp;  <span class="comment"># 启动sshd  方便之后的ansible</span></span><br><span class="line">然后配置yum源为宿主机的ip     <span class="comment"># 宿主机上需要开服httpd    并且在访问站点目录解压sgsm.zip包</span></span><br><span class="line"></span><br><span class="line">配置好yum源安装nodejs-4.4-*</span><br><span class="line"> yum install  subversion    nodejs-4.4*  -y   <span class="comment"># 因为测试环境需要svn检出代码 所以需要安装subversion</span></span><br><span class="line"></span><br><span class="line"> svn  co  代码路径</span><br><span class="line"></span><br><span class="line"><span class="comment">##  如果有报错 字符集有问题需要调整  </span></span><br><span class="line">  <span class="built_in">export</span> LC_CTYPE=<span class="string">"zh_CN.UTF-8"</span></span><br><span class="line">  <span class="built_in">export</span> LANG=<span class="string">"zh_CN.UTF-8"</span></span><br><span class="line">  <span class="built_in">export</span> LC_CTYPE=<span class="string">"zh_CN.GB2312"</span></span><br><span class="line">  然后在svn co</span><br><span class="line">  如果还不行    使用下面的方法</span><br><span class="line">	vim   /etc/profile </span><br><span class="line">		在最后插入</span><br><span class="line">			<span class="built_in">export</span> LC_ALL=en_US.UTF-8</span><br><span class="line">			<span class="built_in">export</span> LANG=en_US.UTF-8</span><br><span class="line">			<span class="built_in">export</span> LANGUAGE=en_US.UTF-8</span><br><span class="line">		保存退出</span><br><span class="line">	<span class="built_in">source</span>  /etc/profile    <span class="comment">#  source 立即生效</span></span><br></pre></td></tr></table></figure>






<h2 id="容器启动后端口映射"><a href="#容器启动后端口映射" class="headerlink" title="容器启动后端口映射"></a>容器启动后端口映射</h2><p>首先停止容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker stop <span class="built_in">test</span></span><br></pre></td></tr></table></figure>
<p>然后停止服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl stop docker</span><br><span class="line">```	</span><br><span class="line"></span><br><span class="line">修改配置文件&amp;emsp;&amp;emsp; ( [hash_of_the_container] 为容器id)</span><br></pre></td></tr></table></figure>
<p>vim /var/lib/docker/containers/[hash_of_the_container]/hostconfig.json<br>在 hostconfig.json 里有 “PortBindings”:{} 这个配置项，可以改成 “PortBindings”:{“9001/tcp”:[{“HostIp”:””,”HostPort”:”900”}]}<br>                                                                                前者为容器端口，后者为宿主机端口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">修改config.v2.json	&amp;emsp;	&amp;emsp;	(## 如果容器内端口从没有暴露 需要修改这个文件)</span><br><span class="line">&#96;&#96;&#96;bash</span><br><span class="line">vim &#x2F;var&#x2F;lib&#x2F;docker&#x2F;containers&#x2F;[hash_of_the_container]&#x2F;config.v2.json</span><br><span class="line">在 config.v2.json 里面添加一个配置项 &quot;ExposedPorts&quot;:&#123;&quot;80&#x2F;tcp&quot;:&#123;&#125;&#125; , ## 必须将这个配置项添加到 &quot;Tty&quot;: true, 前面</span><br></pre></td></tr></table></figure>
<p>最后重启 docker的守护进程 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl restart  docker</span><br></pre></td></tr></table></figure>
<p>然后需要启动容器id </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker start  <span class="built_in">test</span></span><br></pre></td></tr></table></figure>
<p>查看配置项已经修改成功</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker ps </span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                            NAMES</span><br><span class="line">ccc0f0ca5334        84f2139ad784        <span class="string">"/usr/sbin/init"</span>    6 weeks ago         Up 6 weeks          9001/tcp, 0.0.0.0:9090-&gt;80/tcp   <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><p>docker指令<br><br>指令：FROM <br></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">功能描述：设置基础镜像 </span><br><span class="line">语法：FROM &lt; image&gt;[:&lt; tag&gt; | @&lt; digest&gt;] </span><br><span class="line">提示：镜像都是从一个基础镜像（操作系统或其他镜像）生成，可以在一个Dockerfile中添加多条FROM指令，一次生成多个镜像 </span><br><span class="line">注意：如果忽略tag选项，会使用latest镜像</span><br></pre></td></tr></table></figure>
<p>指令：MAINTAINER </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">功能描述：设置镜像作者 </span><br><span class="line">语法：MAINTAINER &lt; name&gt;</span><br></pre></td></tr></table></figure>
<p>指令：RUN </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">功能描述： </span><br><span class="line">语法：RUN &lt; <span class="built_in">command</span>&gt; </span><br><span class="line">          RUN [“executable”,”param1”,”param2”] </span><br><span class="line">提示：RUN指令会生成容器，在容器中执行脚本，容器使用当前镜像，脚本指令完成后，Docker Daemon会将该容器提交为一个中间镜像，供后面的指令使用 </span><br><span class="line">补充：RUN指令第一种方式为shell方式，使用/bin/sh -c &lt; <span class="built_in">command</span>&gt;运行脚本，可以在其中使用\将脚本分为多行 </span><br><span class="line">          RUN指令第二种方式为<span class="built_in">exec</span>方式，镜像中没有/bin/sh或者要使用其他shell时使用该方式，其不会调用shell命令 </span><br><span class="line">例子：RUN <span class="built_in">source</span> <span class="variable">$HOME</span>/.bashrc;\ </span><br><span class="line">          <span class="built_in">echo</span> <span class="variable">$HOME</span></span><br><span class="line"></span><br><span class="line">          RUN [“/bin/bash”,”-c”,”<span class="built_in">echo</span> hello”]</span><br><span class="line"></span><br><span class="line">          RUN [“sh”,”-c”,”<span class="built_in">echo</span>”,”<span class="variable">$HOME</span>”] 使用第二种方式调用shell读取环境变量</span><br></pre></td></tr></table></figure>
<p>指令：CMD </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">功能描述：设置容器的启动命令 </span><br><span class="line">语法：CMD [“executable”,”param1”,”param2”] </span><br><span class="line">          CMD [“param1”,”param2”] </span><br><span class="line">          CMD &lt; <span class="built_in">command</span>&gt; </span><br><span class="line">提示：CMD第一种、第三种方式和RUN类似，第二种方式为ENTRYPOINT参数方式，为entrypoint提供参数列表 </span><br><span class="line">注意：Dockerfile中只能有一条CMD命令，如果写了多条则最后一条生效</span><br></pre></td></tr></table></figure>
<p>指令：LABEL </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">功能描述：设置镜像的标签 </span><br><span class="line">延伸：镜像标签可以通过docker inspect查看 </span><br><span class="line">格式：LABEL &lt; key&gt;=&lt; value&gt; &lt; key&gt;=&lt; value&gt; … </span><br><span class="line">提示：不同标签之间通过空格隔开 </span><br><span class="line">注意：每条指令都会生成一个镜像层，Docker中镜像最多只能有127层，如果超出Docker Daemon就会报错，如LABEL ..=.. &lt;假装这里有个换行&gt; LABEL ..=..合在一起用空格分隔就可以减少镜像层数量，同样，可以使用连接符\将脚本分为多行 </span><br><span class="line">          镜像会继承基础镜像中的标签，如果存在同名标签则会覆盖</span><br></pre></td></tr></table></figure>
<p>指令：EXPOSE </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">功能描述：设置镜像暴露端口，记录容器启动时监听哪些端口 </span><br><span class="line">语法：EXPOSE &lt; port&gt; &lt; port&gt; … </span><br><span class="line">延伸：镜像暴露端口可以通过docker inspect查看 </span><br><span class="line">提示：容器启动时，Docker Daemon会扫描镜像中暴露的端口，如果加入-P参数，Docker Daemon会把镜像中所有暴露端口导出，并为每个暴露端口分配一个随机的主机端口（暴露端口是容器监听端口，主机端口为外部访问容器的端口） </span><br><span class="line">注意：EXPOSE只设置暴露端口并不导出端口，只有启动容器时使用-P/-p才导出端口，这个时候才能通过外部访问容器提供的服务</span><br></pre></td></tr></table></figure>
<p>指令：ENV </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">功能描述：设置镜像中的环境变量 </span><br><span class="line">语法：ENV &lt; key&gt;=&lt; value&gt;…|&lt; key&gt; &lt; value&gt; </span><br><span class="line">注意：环境变量在整个编译周期都有效，第一种方式可设置多个环境变量，第二种方式只设置一个环境变量 </span><br><span class="line">提示：通过<span class="variable">$&#123;变量名&#125;</span>或者 $变量名使用变量，使用方式<span class="variable">$&#123;变量名&#125;</span>时可以用<span class="variable">$&#123;变量名:-default&#125;</span> <span class="variable">$&#123;变量名:+cover&#125;</span>设定默认值或者覆盖值 </span><br><span class="line">          ENV设置的变量值在整个编译过程中总是保持不变的</span><br></pre></td></tr></table></figure>
<p>指令：ADD </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">功能描述：复制文件到镜像中 </span><br><span class="line">语法：ADD &lt; src&gt;… &lt; dest&gt;|[“&lt; src&gt;”,… “&lt; dest&gt;”] </span><br><span class="line">注意：当路径中有空格时，需要使用第二种方式 </span><br><span class="line">          当src为文件或目录时，Docker Daemon会从编译目录寻找这些文件或目录，而dest为镜像中的绝对路径或者相对于WORKDIR的路径 </span><br><span class="line">提示：src为目录时，复制目录中所有内容，包括文件系统的元数据，但不包括目录本身 </span><br><span class="line">          src为压缩文件，并且压缩方式为gzip,bzip2或xz时，指令会将其解压为目录 </span><br><span class="line">          如果src为文件，则复制文件和元数据 </span><br><span class="line">          如果dest不存在，指令会自动创建dest和缺失的上级目录</span><br></pre></td></tr></table></figure>
<p>指令：COPY </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">功能描述：复制文件到镜像中 </span><br><span class="line">语法：COPY &lt; src&gt;… &lt; dest&gt;|[“&lt; src&gt;”,… “&lt; dest&gt;”] </span><br><span class="line">提示：指令逻辑和ADD十分相似，同样Docker Daemon会从编译目录寻找文件或目录，dest为镜像中的绝对路径或者相对于WORKDIR的路径</span><br></pre></td></tr></table></figure>
<p>指令：ENTRYPOINT</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">功能描述：设置容器的入口程序 </span><br><span class="line">语法：ENTRYPOINT [“executable”,”param1”,”param2”] </span><br><span class="line">          ENTRYPOINT <span class="built_in">command</span> param1 param2（shell方式） </span><br><span class="line">提示：入口程序是容器启动时执行的程序，docker run中最后的命令将作为参数传递给入口程序 </span><br><span class="line">          入口程序有两种格式：<span class="built_in">exec</span>、shell，其中shell使用/bin/sh -c运行入口程序，此时入口程序不能接收信号量 </span><br><span class="line">          当Dockerfile有多条ENTRYPOINT时只有最后的ENTRYPOINT指令生效 </span><br><span class="line">          如果使用脚本作为入口程序，需要保证脚本的最后一个程序能够接收信号量，可以在脚本最后使用<span class="built_in">exec</span>或gosu启动传入脚本的命令 </span><br><span class="line">注意：通过shell方式启动入口程序时，会忽略CMD指令和docker run中的参数 </span><br><span class="line">          为了保证容器能够接受docker stop发送的信号量，需要通过<span class="built_in">exec</span>启动程序；如果没有加入<span class="built_in">exec</span>命令，则在启动容器时容器会出现两个进程，并且使用docker stop命令容器无法正常退出（无法接受SIGTERM信号），超时后docker stop发送SIGKILL，强制停止容器 </span><br><span class="line">例子：FROM ubuntu &lt;换行&gt; ENTRYPOINT <span class="built_in">exec</span> top -b</span><br></pre></td></tr></table></figure>
<p>指令：VOLUME </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">功能描述：设置容器的挂载点 </span><br><span class="line">语法：VOLUME [“/data”] </span><br><span class="line">          VOLUME /data1 /data2 </span><br><span class="line">提示：启动容器时，Docker Daemon会新建挂载点，并用镜像中的数据初始化挂载点，可以将主机目录或数据卷容器挂载到这些挂载点</span><br></pre></td></tr></table></figure>
<p>指令：USER </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">功能描述：设置RUN CMD ENTRYPOINT的用户名或UID </span><br><span class="line">语法：USER &lt; name&gt;</span><br></pre></td></tr></table></figure>
<p>指令：WORKDIR </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">功能描述：设置RUN CMD ENTRYPOINT ADD COPY指令的工作目录 </span><br><span class="line">语法：WORKDIR &lt; Path&gt; </span><br><span class="line">提示：如果工作目录不存在，则Docker Daemon会自动创建 </span><br><span class="line">          Dockerfile中多个地方都可以调用WORKDIR，如果后面跟的是相对位置，则会跟在上条WORKDIR指定路径后（如WORKDIR /A   WORKDIR B   WORKDIR C，最终路径为/A/B/C）</span><br></pre></td></tr></table></figure>
<p>指令：ARG </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">功能描述：设置编译变量 </span><br><span class="line">语法：ARG &lt; name&gt;[=&lt; defaultValue&gt;] </span><br><span class="line">注意：ARG从定义它的地方开始生效而不是调用的地方，在ARG之前调用编译变量总为空，在编译镜像时，可以通过docker build –build-arg &lt; var&gt;=&lt; value&gt;设置变量，如果var没有通过ARG定义则Daemon会报错 </span><br><span class="line">          可以使用ENV或ARG设置RUN使用的变量，如果同名则ENV定义的值会覆盖ARG定义的值，与ENV不同，ARG的变量值在编译过程中是可变的，会对比使用编译缓存造成影响（ARG值不同则编译过程也不同） </span><br><span class="line">例子：ARG CONT_IMAG_VER &lt;换行&gt; RUN <span class="built_in">echo</span> <span class="variable">$CONT_IMG_VER</span> </span><br><span class="line">          ARG CONT_IMAG_VER &lt;换行&gt; RUN <span class="built_in">echo</span> hello </span><br><span class="line">          当编译时给ARG变量赋值hello，则两个Dockerfile可以使用相同的中间镜像，如果不为hello，则不能使用同一个中间镜像</span><br></pre></td></tr></table></figure>
<p>指令：ONBUILD </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">功能描述：设置自径想的编译钩子指令 </span><br><span class="line">语法：ONBUILD [INSTRUCTION] </span><br><span class="line">提示：从该镜像生成子镜像，在子镜像的编译过程中，首先会执行父镜像中的ONBUILD指令，所有编译指令都可以成为钩子指令</span><br></pre></td></tr></table></figure>
<p>指令：STOPSIGNAL </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">功能描述：设置容器退出时，Docker Daemon向容器发送的信号量 </span><br><span class="line">语法：STOPSIGNAL signal </span><br><span class="line">提示：信号量可以是数字或者信号量的名字，如9或者SIGKILL，信号量的数字说明在Linux系统管理中有简单介绍</span><br></pre></td></tr></table></figure>

<p>写好Dockerfile后放到一个目录中      &emsp;    &emsp; –Dockerfile里所需要copy 或者add的文件要在同目录下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build   -t  web:v1.1 .      --  -t指定名称 和 版本    . 代表上下级目录</span><br></pre></td></tr></table></figure>
<p>启动docker</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -it  --privileged=<span class="literal">true</span>  --name <span class="built_in">test</span>   -p 9090:80  -d   84f2139ad784   /usr/sbin/init    </span><br><span class="line"><span class="comment">#  --privileged=true 可以在容器中有权限启动服务     -p 端口映射 9090宿主机端口  80 容器端口</span></span><br><span class="line">``` </span><br><span class="line">```bash</span><br><span class="line"><span class="comment">##多个端口映射</span></span><br><span class="line">docker run -it  --privileged=<span class="literal">true</span>  --name lin   -p 90:80  -p 1111:9001 -p 2222:20001  -d   9aec5c5fe4ba   /usr/sbin/init</span><br></pre></td></tr></table></figure>

<p>dockerfile案例</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Base images 基础镜像</span></span><br><span class="line">FROM centos:centos7.2.1511</span><br><span class="line"></span><br><span class="line"><span class="comment">#MAINTAINER 维护者信息</span></span><br><span class="line">MAINTAINER xinlong </span><br><span class="line"></span><br><span class="line"><span class="comment">#ADD  文件放在当前目录下，拷过去会自动解压</span></span><br><span class="line">ADD node.repo.bak   /etc/yum.repos.d/</span><br><span class="line"></span><br><span class="line"><span class="comment">#RUN 执行以下命令 </span></span><br><span class="line">RUN yum clean all \</span><br><span class="line">        &amp;&amp; yum install    httpd    -y </span><br><span class="line"></span><br><span class="line"><span class="comment">#WORKDIR 相当于cd</span></span><br><span class="line">WORKDIR /var/www/html</span><br><span class="line"></span><br><span class="line">RUN <span class="built_in">echo</span> <span class="string">"dockerfile test"</span>  &gt;  index.html</span><br><span class="line"></span><br><span class="line"><span class="comment">#EXPOSE 映射端口</span></span><br><span class="line">EXPOSE 9001</span><br><span class="line">EXPOSE 20001</span><br><span class="line"></span><br><span class="line">CMD systemctl start httpd</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Base images 基础镜像</span></span><br><span class="line">FROM centos7.2.1511</span><br><span class="line"></span><br><span class="line"><span class="comment">#MAINTAINER 维护者信息</span></span><br><span class="line">MAINTAINER xinlong </span><br><span class="line"></span><br><span class="line"><span class="comment">#ADD  文件放在当前目录下，如果是压缩文件拷过去会自动解压</span></span><br><span class="line">ADD node.repo   /etc/yum.repos.d/</span><br><span class="line"></span><br><span class="line"><span class="comment">#RUN 执行以下命令 </span></span><br><span class="line">RUN yum clean all   \</span><br><span class="line">	&amp;&amp; yum install epel-release -y	\</span><br><span class="line">	&amp;&amp; yum install net-tools   httpd  vim  elinks    passwd openssl openssh-server     openssl-client  -y	\</span><br><span class="line">	&amp;&amp; /usr/sbin/sshd -D &amp;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">RUN /data/sgsm/1/web/trunk</span><br><span class="line">RUN mkdir /data/sgsm/   -p \</span><br><span class="line">	mkdir /data/sgsm/1/	\</span><br><span class="line">	mkdir         /data/sgsm/1/&#123;boss_pvp,chart_pvp,chat_pvp,city_pvp,consume_pvp,convey_pvp,five_pvp,login,ore_pvp,pay,pvp,recharge_pvp,secret_pvp,server,servers_pvp,sky,team_pvp,video,web,wusheng_pvp&#125;   \</span><br><span class="line">	mkdir /data/sgsm/1/web/&#123;logs,trunk&#125; </span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"><span class="comment">#WORKDIR 相当于cd</span></span><br><span class="line">WORKDIR /data/sgsm/1/web/trunk</span><br><span class="line">	svn co http://192.168.1.161/program/program/server/</span><br><span class="line"></span><br><span class="line"><span class="comment">#EXPOSE 映射端口  创建容器的时候还需要指定</span></span><br><span class="line">EXPOSE 9001</span><br><span class="line"></span><br><span class="line">CMD systemctl start httpd</span><br></pre></td></tr></table></figure>

<h2 id="导入导出容器"><a href="#导入导出容器" class="headerlink" title="导入导出容器"></a>导入导出容器</h2><p>导出容器–docker export 容器id &gt; /指定目录/名字.tar</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker  <span class="built_in">export</span>  ID  &gt; file.tar</span><br></pre></td></tr></table></figure>
<p>scp发送至有docker环境的服务器</p>
<p>导入容器（可以先docker images查看一下）–cat 名字.tar | docker import - 镜像名</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat  file.tar  | docker  import  - NAME</span><br></pre></td></tr></table></figure>

<h2 id="镜像导入导出和更新"><a href="#镜像导入导出和更新" class="headerlink" title="镜像导入导出和更新"></a>镜像导入导出和更新</h2><p>镜像导出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker save 镜像 xxx.tar</span><br><span class="line">```  </span><br><span class="line">镜像导入：</span><br><span class="line">```bash</span><br><span class="line">docker load -i xxx.tar</span><br></pre></td></tr></table></figure>
<p>镜像的更新：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker commit -m 提交的描述 -a 提交作者 -p 更新时暂停此容器 新镜像名</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>liunx</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>centos下生成多份密钥对</title>
    <url>/2020/06/11/ssh/</url>
    <content><![CDATA[<p>常用选项</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-t  指定秘钥类型(默认rsa)</span><br><span class="line">-f  指定秘钥文件路径(默认用户家目录.ssh下)</span><br><span class="line">-P  指定密码(可不设置)</span><br><span class="line">-c  注释内容一般填写邮件(可不指定)</span><br></pre></td></tr></table></figure>

<p>常用语法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen  -t rsa  -f ~/.ssh/xxx   -P xxx</span><br></pre></td></tr></table></figure>

<p>-f 选项的好处就是一台机器可以生成多份秘钥,因为默认的秘钥名为id_rsa和id_rsa.pub,在使用ssh-keygen生成就会覆盖</p>
<p>使用 -f 选项</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[sgsm@iZ2ze53g8gh7cdxahhcv95Z .ssh]$ ssh-keygen  -t rsa  -f ~/.ssh/mihua   -P xxx</span><br><span class="line">[sgsm@iZ2ze53g8gh7cdxahhcv95Z .ssh]$ ll</span><br><span class="line">total 32</span><br><span class="line">-rw------- 1 sgsm sgsm  2047 May 16 11:06 authorized_keys</span><br><span class="line">-rw------- 1 sgsm users  816 May 16 11:03 authorized_keys.bak</span><br><span class="line">-rw------- 1 sgsm users 1675 Apr  8 17:45 id_rsa</span><br><span class="line">-rw-r--r-- 1 sgsm users  410 Apr  8 17:45 id_rsa.pub</span><br><span class="line">-rw-r--r-- 1 sgsm users 4728 Apr 17 14:44 known_hosts</span><br><span class="line">-rw------- 1 sgsm users 1766 Jun 11 09:42 mihua</span><br><span class="line">-rw-r--r-- 1 sgsm users  410 Jun 11 09:42 mihua.pub</span><br></pre></td></tr></table></figure>
<p>现在把mihua.pub 导入需要免密登录的机器中就可以实现免密登录</p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>liunx</tag>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title>git基础操作</title>
    <url>/2020/06/09/git/</url>
    <content><![CDATA[<h2 id="Git安装"><a href="#Git安装" class="headerlink" title="Git安装"></a>Git安装</h2><p>yum安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install git -y</span><br></pre></td></tr></table></figure>
<p>源码安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载源码包</span></span><br><span class="line"><span class="built_in">cd</span> /opt/</span><br><span class="line">sudo wget https://github.com/git/git/archive/v2.14.1.zip</span><br><span class="line">unzip v2.14.1.zip</span><br><span class="line"><span class="comment"># 安装依赖包</span></span><br><span class="line"> sudo  yum  install curl-devel expat-devel gettext-devel openssl-devel zlib-devel gcc perl-ExtUtils-MakeMaker   -y </span><br><span class="line"><span class="comment"># 进入git-2.3.0，</span></span><br><span class="line"><span class="built_in">cd</span> git-2.14.1</span><br><span class="line"><span class="comment">#配置参数</span></span><br><span class="line">sudo make prefix=/usr/<span class="built_in">local</span>/ all</span><br><span class="line">sudo make prefix=/usr/<span class="built_in">local</span>/ install</span><br><span class="line"><span class="comment"># 等待一切安装完成，用git --version查看版本号，能看到即可</span></span><br><span class="line">git  --version</span><br></pre></td></tr></table></figure>
<h2 id="Git工作流程"><a href="#Git工作流程" class="headerlink" title="Git工作流程"></a>Git工作流程</h2><p>一般工作流程如下：</p>
<pre><code>克隆 Git 资源作为工作目录。
在克隆的资源上添加或修改文件。
如果其他人修改了，你可以更新资源。
在提交前查看修改。
提交修改。
在修改完成后，如果发现错误，可以撤回提交并再次修改并提交。</code></pre><p>当执行提交操作（git commit）时，暂存区的目录树写到版本库（对象库）中，master 分支会做相应的更新。即 master 指向的目录树就是提交时暂存区的目录树。</p>
<p>当执行 “git reset HEAD” 命令时，暂存区的目录树会被重写，被 master 分支指向的目录树所替换，但是工作区不受影响。</p>
<p>当执行 “git rm –cached <file>“ 命令时，会直接从暂存区删除文件，工作区则不做出改变。</file></p>
<p>当执行 “git checkout .” 或者 “git checkout – <file>“ 命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区的改动。</file></p>
<p>当执行 “git checkout HEAD .” 或者 “git checkout HEAD <file>“ 命令时，会用 HEAD 指向的 master 分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。 </file></p>
<h2 id="Git创建仓库"><a href="#Git创建仓库" class="headerlink" title="Git创建仓库"></a>Git创建仓库</h2><p>git init</p>
<p>Git 使用 git init 命令来初始化一个 Git 仓库，Git 的很多命令都需要在 Git 的仓库中运行，所以 git init 是使用 Git 的第一个命令。<br>在执行完成 git init 命令后，Git 仓库会生成一个 .git 目录，该目录包含了资源的所有元数据，其他的项目目录保持不变（不像 SVN 会在每个子目录生成 .svn 目录，Git 只在仓库的根目录生成 .git 目录）。</p>
<p>使用当前目录作为Git仓库，我们只需使它初始化。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>
<p>如果当前目录下有几个文件想要纳入版本控制，需要先用 git add 命令告诉 Git 开始对这些文件进行跟踪，然后提交： </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git add *.c</span><br><span class="line">$ git add README</span><br><span class="line">$ git commit -m <span class="string">'初始化项目版本'</span></span><br></pre></td></tr></table></figure>
<p>以上命令将目录下以 .c 结尾及 README 文件提交到仓库中。</p>
<p>git clone<br><br>我们使用 git clone 从现有 Git 仓库中拷贝项目（类似 svn checkout）<br></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> &lt;repo&gt;</span><br></pre></td></tr></table></figure>
<p>如果我们需要克隆到指定的目录，可以使用以下命令格式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> &lt;repo&gt; &lt;directory&gt;</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<pre><code>repo:Git 仓库。
directory:本地目录</code></pre><p>执行该命令后，会在当前目录下创建一个名为grit的目录，其中包含一个 .git 的目录，用于保存下载下来的所有版本记录。</p>
<p>如果要自己定义要新建的项目目录名称，可以在上面的命令末尾指定新的名字：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git://github.com/schacon/grit.git mygrit</span><br></pre></td></tr></table></figure>

<h2 id="Git基本操作"><a href="#Git基本操作" class="headerlink" title="Git基本操作"></a>Git基本操作</h2><p>创建仓库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[sgsm@centos git]$ mkdir git</span><br><span class="line">[sgsm@centos git]$ <span class="built_in">cd</span>  git</span><br><span class="line">[sgsm@centos git]$ git  init</span><br><span class="line">Initialized empty Git repository <span class="keyword">in</span> /root/git/.git/</span><br></pre></td></tr></table></figure>
<p>现在你可以看到在你的项目中生成了 .git 这个子目录。 这就是你的 Git 仓库了，所有有关你的此项目的快照数据都存放在这里</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[sgsm@centos git]$ ll -a</span><br><span class="line">total 12</span><br><span class="line">drwxr-xr-x   3 sgsm sgsm 4096 Jun 12 13:50 .</span><br><span class="line">dr-xr-x---. 11 sgsm sgsm 4096 Jun 12 13:31 ..</span><br><span class="line">drwxr-xr-x   7 sgsm sgsm 4096 Jun 12 13:50 .git</span><br></pre></td></tr></table></figure>

<p>克隆仓库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git  <span class="built_in">clone</span>  https://github.com/xinlongOB/python.github.io.git</span><br></pre></td></tr></table></figure>

<p>git add </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 创建文件</span><br><span class="line">touch  test.py</span><br><span class="line"># 添加暂存区    . 代表当前目录   也可以指定文件名</span><br><span class="line">git add  .</span><br><span class="line"># 提交并添加注释</span><br><span class="line">git commit -m &quot; add  test.py&quot;</span><br></pre></td></tr></table></figure>
<p>报错：</p>
<pre><code>*** Please tell me who you are.

Run

  git config --global user.email &quot;you@example.com&quot;
  git config --global user.name &quot;Your Name&quot;

to set your account&apos;s default identity.
Omit --global to set the identity only in this repository.

fatal: unable to auto-detect email address (got &apos;root@suyuerunCentos.(none)&apos;)</code></pre><p>因为没有添加账号密码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加邮箱和账号</span></span><br><span class="line">git config --global user.email <span class="string">"942868591@qq.com"</span></span><br><span class="line">git config --global user.name <span class="string">"long"</span></span><br></pre></td></tr></table></figure>
<p>再次提交</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[sgsm@centos python.github.io]$ git commit -m <span class="string">" add  test.py"</span>                    </span><br><span class="line">[master 49151ac]  add  test.py</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 test.py</span><br></pre></td></tr></table></figure>
<p>使用 git log 查看提交记录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@centos python.github.io]$ git <span class="built_in">log</span></span><br><span class="line">commit 49151ac5859a2227e660c25cc5d3df07b2964974 (HEAD -&gt; master)</span><br><span class="line">Author: long &lt;942868591@qq.com&gt;</span><br><span class="line">Date:   Fri Jun 12 14:05:48 2020 +0800</span><br><span class="line"></span><br><span class="line">     add  test.py</span><br></pre></td></tr></table></figure>
<p>git status<br><br>git status 以查看在你上次提交之后是否有修改<br></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@centos python.github.io]$ touch import.py   <span class="comment"># 创建文件</span></span><br><span class="line">[root@centos python.github.io]$ git status  -s   <span class="comment"># 查看是否有修改</span></span><br><span class="line">?? import.py          <span class="comment"># ? 代表不明状态  就是没有添加到暂存区</span></span><br><span class="line">[root@centos python.github.io]$ git add .     <span class="comment"># 提交</span></span><br><span class="line">[root@centos python.github.io]$ git status  -s    <span class="comment"># 查看是否有修改</span></span><br><span class="line">A  import.py          <span class="comment"># A  表示add   新增</span></span><br></pre></td></tr></table></figure>

<p>git commit</p>
<p>使用 git add 命令将想要快照的内容写入缓存区， 而执行 git commit 将缓存区内容添加到仓库中。<br><br>Git 为你的每一个提交都记录你的名字与电子邮箱地址，所以第一步需要配置用户名和邮箱地址。<br></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加邮箱和账号</span></span><br><span class="line">git config --global user.email <span class="string">"942868591@qq.com"</span></span><br><span class="line">git config --global user.name <span class="string">"long"</span></span><br></pre></td></tr></table></figure>

<p>git reset HEAD</p>
<p>git reset HEAD 命令用于取消已缓存的内容。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[sgsm@centos python.github.io]$ <span class="built_in">echo</span>  <span class="string">"print("</span><span class="built_in">test</span><span class="string">")"</span> &gt; test.py </span><br><span class="line">[sgsm@centos python.github.io]$ <span class="built_in">echo</span>  <span class="string">"print("</span>import<span class="string">")"</span> &gt; import.py            </span><br><span class="line">[sgsm@centos python.github.io]$ git add .</span><br><span class="line">[sgsm@centos python.github.io]$ git status -s                        </span><br><span class="line">A  import.py</span><br><span class="line">M  test.py</span><br><span class="line">[sgsm@centos python.github.io]$ git reset HEAD   test.py </span><br><span class="line">Unstaged changes after reset:</span><br><span class="line">M       test.py</span><br><span class="line">[sgsm@centos python.github.io]$ git status -s            </span><br><span class="line">A  import.py</span><br><span class="line"> M test.py</span><br><span class="line">[sgsm@centos python.github.io]$ git config --global user.email <span class="string">"942868591@qq.com"</span></span><br><span class="line">[sgsm@centos python.github.io]$ git config --global user.name <span class="string">"long"</span></span><br><span class="line">[sgsm@centos python.github.io]$ git commit -m <span class="string">"update"</span>                           </span><br><span class="line">[master cbd780e] update</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 import.py</span><br><span class="line"><span class="comment"># 提交日志显示只提交了一个文件 说明撤销成功了</span></span><br></pre></td></tr></table></figure>

<p>git rm</p>
<p>如果只是简单地从工作目录中手工删除文件，运行 git status 时就会在 Changes not staged for commit 的提示。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除，然后提交。可以用以下命令完成此项工作</span></span><br><span class="line">git rm &lt;file&gt; </span><br><span class="line"><span class="comment"># 如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 -f</span></span><br><span class="line">git rm -f &lt;file&gt;</span><br><span class="line"><span class="comment"># 如果把文件从暂存区域移除，但仍然希望保留在当前工作目录中，换句话说，仅是从跟踪清单中删除，使用 --cached 选项即可</span></span><br><span class="line">git rm --cached &lt;file&gt;</span><br><span class="line"><span class="comment">#  例如删除已提交的文件：</span></span><br><span class="line">[sgsm@centos python.github.io]$ git rm  -f test.py  </span><br><span class="line">rm <span class="string">'test.py'</span></span><br><span class="line">[sgsm@centos python.github.io]$ ll</span><br><span class="line">total 24</span><br><span class="line">-rw-r--r-- 1 sgsm sgsm   14 Jun 12 14:23 import.py</span><br><span class="line">-rw-r--r-- 1 sgsm sgsm 3744 Jun 12 13:53 plane_main.py</span><br><span class="line">-rw-r--r-- 1 sgsm sgsm 5113 Jun 12 13:53 plane_sprites.py</span><br><span class="line">-rw-r--r-- 1 sgsm sgsm  188 Jun 12 13:53 README.md</span><br><span class="line">drwxr-xr-x 2 sgsm sgsm 4096 Jun 12 13:53 图片</span><br><span class="line">[sgsm@centos python.github.io]$</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 例如从暂存区移除，但保留在当前工作目录</span></span><br><span class="line">[sgsm@centos python.github.io]$ <span class="built_in">echo</span>  <span class="string">"test"</span>  &gt; test.py </span><br><span class="line">[sgsm@centos python.github.io]$ git add  .    </span><br><span class="line">[sgsm@centos python.github.io]$ git status -s </span><br><span class="line">M  test.py</span><br><span class="line">[sgsm@centos python.github.io]$ ll</span><br><span class="line">total 28</span><br><span class="line">-rw-r--r-- 1 sgsm sgsm    14 Jun 12 14:23 import.py</span><br><span class="line">-rw-r--r-- 1 sgsm sgsm  3744 Jun 12 13:53 plane_main.py</span><br><span class="line">-rw-r--r-- 1 sgsm sgsm  5113 Jun 12 13:53 plane_sprites.py</span><br><span class="line">-rw-r--r-- 1 sgsm sgsm   188 Jun 12 13:53 README.md</span><br><span class="line">-rw-r--r-- 1 sgsm users    5 Jun 12 14:36 test.py</span><br><span class="line">drwxr-xr-x 2 sgsm sgsm  4096 Jun 12 13:53 图片</span><br><span class="line">[sgsm@centos python.github.io]$ git rm --cached test.py </span><br><span class="line">rm <span class="string">'test.py'</span></span><br><span class="line">[sgsm@centos python.github.io]$ ll</span><br><span class="line">total 28</span><br><span class="line">-rw-r--r-- 1 sgsm sgsm    14 Jun 12 14:23 import.py</span><br><span class="line">-rw-r--r-- 1 sgsm sgsm  3744 Jun 12 13:53 plane_main.py</span><br><span class="line">-rw-r--r-- 1 sgsm sgsm  5113 Jun 12 13:53 plane_sprites.py</span><br><span class="line">-rw-r--r-- 1 sgsm sgsm   188 Jun 12 13:53 README.md</span><br><span class="line">-rw-r--r-- 1 sgsm users    5 Jun 12 14:36 test.py</span><br><span class="line">drwxr-xr-x 2 sgsm sgsm  4096 Jun 12 13:53 图片</span><br><span class="line">[sgsm@centos python.github.io]$ git status -s </span><br><span class="line">D  test.py</span><br><span class="line">?? test.py</span><br><span class="line">[sgsm@centos python.github.io]$</span><br></pre></td></tr></table></figure>

<p> git mv</p>
<p>git mv 命令用于移动或重命名一个文件、目录、软连接</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[sgsm@centos python.github.io]$ ll</span><br><span class="line">total 24</span><br><span class="line">-rw-r--r-- 1 sgsm sgsm   14 Jun 12 14:23 import.py</span><br><span class="line">-rw-r--r-- 1 sgsm sgsm 3744 Jun 12 13:53 plane_main.py</span><br><span class="line">-rw-r--r-- 1 sgsm sgsm 5113 Jun 12 13:53 plane_sprites.py</span><br><span class="line">-rw-r--r-- 1 sgsm sgsm  188 Jun 12 13:53 README.md</span><br><span class="line">drwxr-xr-x 2 sgsm sgsm 4096 Jun 12 13:53 图片</span><br><span class="line">[sgsm@centos python.github.io]$ git status -s</span><br><span class="line">[sgsm@centos python.github.io]$ git mv  import.py   print.py</span><br><span class="line">[sgsm@centos python.github.io]$ ll</span><br><span class="line">total 24</span><br><span class="line">-rw-r--r-- 1 sgsm sgsm 3744 Jun 12 13:53 plane_main.py</span><br><span class="line">-rw-r--r-- 1 sgsm sgsm 5113 Jun 12 13:53 plane_sprites.py</span><br><span class="line">-rw-r--r-- 1 sgsm sgsm   14 Jun 12 14:23 print.py</span><br><span class="line">-rw-r--r-- 1 sgsm sgsm  188 Jun 12 13:53 README.md</span><br><span class="line">drwxr-xr-x 2 sgsm sgsm 4096 Jun 12 13:53 图片</span><br><span class="line">[sgsm@centos python.github.io]$</span><br></pre></td></tr></table></figure>

<h2 id="Git分支管理"><a href="#Git分支管理" class="headerlink" title="Git分支管理"></a>Git分支管理</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建分支</span></span><br><span class="line">[sgsm@centos python.github.io]$ git branch  python</span><br><span class="line"><span class="comment">#  切换分支</span></span><br><span class="line">[sgsm@centos python.github.io]$ git checkout  python</span><br></pre></td></tr></table></figure>
<p>查看分支(默认不加参数会列出你在本地的分支)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[sgsm@centos python.github.io]$ git branch</span><br><span class="line">* master</span><br><span class="line">  python</span><br><span class="line">[sgsm@centos python.github.io]$</span><br></pre></td></tr></table></figure>
<p>主线和分支验证</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[sgsm@centos sgsm]$ git checkout  master</span><br><span class="line">Switched to branch <span class="string">'master'</span></span><br><span class="line">[sgsm@centos sgsm]$ ll</span><br><span class="line">total 0</span><br><span class="line">-rw-r--r-- 1 sgsm users 0 Jun 12 14:56 <span class="built_in">test</span></span><br><span class="line">[sgsm@centos sgsm]$ </span><br><span class="line">[sgsm@centos sgsm]$ touch mihua                 <span class="comment"># 在master上创建一个文件</span></span><br><span class="line">[sgsm@centos sgsm]$ git add . </span><br><span class="line">[sgsm@centos sgsm]$ git  commit -m <span class="string">"mihua"</span>    <span class="comment"># 提交</span></span><br><span class="line">[master a56e6c2] mihua</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 mihua</span><br><span class="line">[sgsm@centos sgsm]$ ll                        <span class="comment"># 在master可以看到</span></span><br><span class="line">total 0</span><br><span class="line">-rw-r--r-- 1 sgsm users 0 Jun 12 14:57 mihua</span><br><span class="line">-rw-r--r-- 1 sgsm users 0 Jun 12 14:56 <span class="built_in">test</span></span><br><span class="line">[sgsm@centos sgsm]$ </span><br><span class="line">[sgsm@centos sgsm]$ git checkout  trunk         <span class="comment"># 切换到分支</span></span><br><span class="line">Switched to branch <span class="string">'trunk'</span></span><br><span class="line">[sgsm@centos sgsm]$ ll                          <span class="comment"># 没有那个文件了</span></span><br><span class="line">total 0</span><br><span class="line">-rw-r--r-- 1 sgsm users 0 Jun 12 14:56 <span class="built_in">test</span> </span><br><span class="line">[sgsm@centos sgsm]$  git checkout  master          <span class="comment"># 切换到master 就可以看到</span></span><br><span class="line">Switched to branch <span class="string">'master'</span></span><br><span class="line">[sgsm@centos sgsm]$ ll</span><br><span class="line">total 0</span><br><span class="line">-rw-r--r-- 1 sgsm users 0 Jun 12 15:00 mihua</span><br><span class="line">-rw-r--r-- 1 sgsm users 0 Jun 12 14:56 <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<p> git checkout -b (branchname) 命令来创建新分支并立即切换到该分支下，从而在该分支中操作<br> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">略</span><br></pre></td></tr></table></figure><br>删除分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -d (branchname)</span><br></pre></td></tr></table></figure>
<p>例如我们要删除v0.6.10分支：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[sgsm@centos sgsm]$ git branch</span><br><span class="line">* master</span><br><span class="line">  trunk</span><br><span class="line">  v0.6.10</span><br><span class="line">[sgsm@centos sgsm]$ </span><br><span class="line">[sgsm@centos sgsm]$ git branch -d  v0.6.10</span><br><span class="line">Deleted branch v0.6.10 (was a56e6c2).</span><br><span class="line">[sgsm@centos sgsm]$ git branch</span><br><span class="line">* master</span><br><span class="line">  trunk</span><br><span class="line">[sgsm@centos sgsm]$</span><br></pre></td></tr></table></figure>
<p>合并分支<br><br>一旦某分支有了独立内容，你终究会希望将它合并回到你的主分支。 你可以使用以下命令将任何分支合并到当前分支中去：<br></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git merge</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[sgsm@centos sgsm]$ ll            <span class="comment"># 新增finddelete.js   haha文件</span></span><br><span class="line">total 4</span><br><span class="line">-rw-r--r-- 1 sgsm users 66 Jun 12 15:58 finddelete.js</span><br><span class="line">-rw-r--r-- 1 sgsm users  0 Jun 12 14:58 haha</span><br><span class="line">-rw-r--r-- 1 sgsm users  0 Jun 12 14:56 <span class="built_in">test</span></span><br><span class="line">[sgsm@centos sgsm]$ git  add . </span><br><span class="line">[sgsm@centos sgsm]$ git commit -m <span class="string">"add  finddelete.js"</span>     <span class="comment"># 提交 </span></span><br><span class="line">[trunk c45f7e4] add  finddelete.js</span><br><span class="line"> 2 files changed, 6 insertions(+)</span><br><span class="line"> create mode 100644 finddelete.js</span><br><span class="line"> create mode 100644 haha</span><br><span class="line">[sgsm@centos sgsm]$ git checkout master         <span class="comment">#  切换到master   没有分支新提交的文件</span></span><br><span class="line">Switched to branch <span class="string">'master'</span></span><br><span class="line">[sgsm@centos sgsm]$ ll</span><br><span class="line">total 0</span><br><span class="line">-rw-r--r-- 1 sgsm users 0 Jun 12 15:59 mihua</span><br><span class="line">-rw-r--r-- 1 sgsm users 0 Jun 12 14:56 <span class="built_in">test</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[sgsm@centos sgsm]$ git merge  trunk    <span class="comment"># 把分支内容合并到主线</span></span><br><span class="line">Merge branch <span class="string">'trunk'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Please enter a commit message to explain why this merge is necessary,</span></span><br><span class="line"><span class="comment"># especially if it merges an updated upstream into a topic branch.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Lines starting with '#' will be ignored, and an empty message aborts</span></span><br><span class="line"><span class="comment"># the commit.</span></span><br><span class="line">Merge made by the <span class="string">'recursive'</span> strategy.</span><br><span class="line"> finddelete.js | 6 ++++++</span><br><span class="line"> haha          | 0</span><br><span class="line"> 2 files changed, 6 insertions(+)</span><br><span class="line"> create mode 100644 finddelete.js</span><br><span class="line"> create mode 100644 haha</span><br><span class="line">[sgsm@centos sgsm]$ ll</span><br><span class="line">total 4</span><br><span class="line">-rw-r--r-- 1 sgsm users 66 Jun 12 16:00 finddelete.js</span><br><span class="line">-rw-r--r-- 1 sgsm users  0 Jun 12 16:00 haha</span><br><span class="line">-rw-r--r-- 1 sgsm users  0 Jun 12 15:59 mihua</span><br><span class="line">-rw-r--r-- 1 sgsm users  0 Jun 12 14:56 <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<h2 id="Git查看提交历史"><a href="#Git查看提交历史" class="headerlink" title="Git查看提交历史"></a>Git查看提交历史</h2><p>git log 命令查看提交历史：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[sgsm@centos sgsm]$ git <span class="built_in">log</span></span><br><span class="line">commit 8c42560ed5c96cfa519b263a2ebd2eb8a85769a5 (HEAD -&gt; master)</span><br><span class="line">Merge: a56e6c2 c45f7e4</span><br><span class="line">Author: long &lt;942868591@qq.com&gt;</span><br><span class="line">Date:   Fri Jun 12 16:00:55 2020 +0800</span><br><span class="line"></span><br><span class="line">    Merge branch <span class="string">'trunk'</span></span><br><span class="line"></span><br><span class="line">commit c45f7e446a702b3d267498d69d5b41b818a9aa85 (trunk)</span><br><span class="line">Author: long &lt;942868591@qq.com&gt;</span><br><span class="line">Date:   Fri Jun 12 15:58:38 2020 +0800</span><br><span class="line"></span><br><span class="line">    add  finddelete.js</span><br><span class="line"></span><br><span class="line">commit a56e6c2758dcdc6101a4b3d0b9c48fb2c8cedc07</span><br><span class="line">Author: long &lt;942868591@qq.com&gt;</span><br><span class="line">Date:   Fri Jun 12 14:58:00 2020 +0800</span><br><span class="line"></span><br><span class="line">    mihua</span><br><span class="line"></span><br><span class="line">commit 9831cb0d222df1f1ea18a32754001afa02036b79</span><br><span class="line">Author: long &lt;942868591@qq.com&gt;</span><br><span class="line">Date:   Fri Jun 12 14:57:06 2020 +0800</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test</span></span><br><span class="line">[sgsm@centos sgsm]$</span><br></pre></td></tr></table></figure>
<p>–oneline 选项来查看历史记录的简洁的版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[sgsm@centos sgsm]$  git <span class="built_in">log</span> --oneline</span><br><span class="line">8c42560 (HEAD -&gt; master) Merge branch <span class="string">'trunk'</span></span><br><span class="line">c45f7e4 (trunk) add  finddelete.js</span><br><span class="line">a56e6c2 mihua</span><br><span class="line">9831cb0 <span class="built_in">test</span></span><br><span class="line">[sgsm@centos sgsm]$</span><br></pre></td></tr></table></figure>
<p>–graph 选项，查看历史中什么时候出现了分支、合并。以下为相同的命令，开启了拓扑图选项：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[sgsm@centos sgsm]$  git <span class="built_in">log</span>  --graph </span><br><span class="line">*   commit 8c42560ed5c96cfa519b263a2ebd2eb8a85769a5 (HEAD -&gt; master)</span><br><span class="line">|\  Merge: a56e6c2 c45f7e4</span><br><span class="line">| | Author: long &lt;942868591@qq.com&gt;</span><br><span class="line">| | Date:   Fri Jun 12 16:00:55 2020 +0800</span><br><span class="line">| | </span><br><span class="line">| |     Merge branch <span class="string">'trunk'</span></span><br><span class="line">| | </span><br><span class="line">| * commit c45f7e446a702b3d267498d69d5b41b818a9aa85 (trunk)</span><br><span class="line">| | Author: long &lt;942868591@qq.com&gt;</span><br><span class="line">| | Date:   Fri Jun 12 15:58:38 2020 +0800</span><br><span class="line">| | </span><br><span class="line">| |     add  finddelete.js</span><br><span class="line">| | </span><br><span class="line">* | commit a56e6c2758dcdc6101a4b3d0b9c48fb2c8cedc07</span><br><span class="line">|/  Author: long &lt;942868591@qq.com&gt;</span><br><span class="line">|   Date:   Fri Jun 12 14:58:00 2020 +0800</span><br><span class="line">|   </span><br><span class="line">|       mihua</span><br><span class="line">| </span><br><span class="line">* commit 9831cb0d222df1f1ea18a32754001afa02036b79</span><br><span class="line">  Author: long &lt;942868591@qq.com&gt;</span><br><span class="line">  Date:   Fri Jun 12 14:57:06 2020 +0800</span><br><span class="line">  </span><br><span class="line">      <span class="built_in">test</span></span><br><span class="line">[sgsm@centos sgsm]$</span><br></pre></td></tr></table></figure>

<p> –reverse 参数来逆向显示所有日志<br> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> [sgsm@centos sgsm]$  git <span class="built_in">log</span>   --reverse    <span class="comment"># 从第一次提交 --&gt;最后一次提交</span></span><br><span class="line">commit 9831cb0d222df1f1ea18a32754001afa02036b79</span><br><span class="line">Author: long &lt;942868591@qq.com&gt;</span><br><span class="line">Date:   Fri Jun 12 14:57:06 2020 +0800</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line">commit a56e6c2758dcdc6101a4b3d0b9c48fb2c8cedc07</span><br><span class="line">Author: long &lt;942868591@qq.com&gt;</span><br><span class="line">Date:   Fri Jun 12 14:58:00 2020 +0800</span><br><span class="line"></span><br><span class="line">    mihua</span><br><span class="line"></span><br><span class="line">commit c45f7e446a702b3d267498d69d5b41b818a9aa85 (trunk)</span><br><span class="line">Author: long &lt;942868591@qq.com&gt;</span><br><span class="line">Date:   Fri Jun 12 15:58:38 2020 +0800</span><br><span class="line"></span><br><span class="line">    add  finddelete.js</span><br><span class="line"></span><br><span class="line">commit 8c42560ed5c96cfa519b263a2ebd2eb8a85769a5 (HEAD -&gt; master)</span><br><span class="line">Merge: a56e6c2 c45f7e4</span><br><span class="line">Author: long &lt;942868591@qq.com&gt;</span><br><span class="line">Date:   Fri Jun 12 16:00:55 2020 +0800</span><br><span class="line"></span><br><span class="line">    Merge branch <span class="string">'trunk'</span></span><br><span class="line">[sgsm@centos sgsm]$</span><br></pre></td></tr></table></figure><br> –author 查找指定用户的提交日志<br> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> [sgsm@centos sgsm]$ git <span class="built_in">log</span> --author=long --oneline -5     </span><br><span class="line">8c42560 (HEAD -&gt; master) Merge branch <span class="string">'trunk'</span></span><br><span class="line">c45f7e4 (trunk) add  finddelete.js</span><br><span class="line">a56e6c2 mihua</span><br><span class="line">9831cb0 <span class="built_in">test</span></span><br><span class="line">[sgsm@centos sgsm]$</span><br></pre></td></tr></table></figure><br>–since 和 –before 查看指定日期的日志 (–no-merges 选项以隐藏合并提交)<br><br>例如，如果我要看 Git 项目中三周前且在四月十八日之后的所有提交<br></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> --oneline --before=&#123;3.weeks.ago&#125; --after=&#123;2010-04-18&#125; --no-merges</span><br></pre></td></tr></table></figure>

<h2 id="Git远程仓库-Github"><a href="#Git远程仓库-Github" class="headerlink" title="Git远程仓库(Github)"></a>Git远程仓库(Github)</h2><p>Git 并不像 SVN 那样有个中心服务器。<br><br>目前我们使用到的 Git 命令都是在本地执行，如果你想通过 Git 分享你的代码或者与其他开发人员合作。 你就需要将数据放到一台其他开发人员能够连接的服务器上。<br></p>
<p>添加远程库<br><br>要添加一个新的远程仓库，可以指定一个简单的名字，以便将来引用,命令格式如下：<br></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add [shortname] [url]</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建秘钥       -t  指定秘钥类型(默认就是rsa)  -P 可以指定密码   更详细的文档点击[]</span></span><br><span class="line">[sgsm@centos sgsm]$ ssh-keygen</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看秘钥并且把秘钥加到github的权限中</span></span><br><span class="line">[sgsm@centos sgsm]$ cat  ~/.ssh/id_rsa.pub </span><br><span class="line">ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEA22A+usIGhnk0rhH7bcPTf6SptnuS70kmIWvqloFFhI8kK1srQTSAPR9EeR5O6VEXk/qJmbBNmr/0WoqmRRIVNGnttZwt8LUySTDBntu0peo9LX4WureKaptmZAIp/VXn2cYYkpdf1H1OYDFJ9rARmmBas3tSp/FlcdSxfgcofAq19VHtXnoJjcJSnh45GTsihtgp2nihHPBtScTqo3zf+xw2A4RWF11qCEm4Dmvvg4LPuMUSQHEhDMQG/VHmNBqlbFrUJieEcO99SL2/BIfqsqmxFsl6zDrNUj3Y2jB69Wcu4UT6DpY0mjw9rSY/KhyXk8SCwWetdt8AQDycCKzGuQ== sgsm@centos</span><br></pre></td></tr></table></figure>
<p>github添加秘钥<br><br><img src="/2020/06/09/git/1.png" alt><br><br><img src="/2020/06/09/git/2.png" alt></p>
<p>为了验证是否成功，输入以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[sgsm@centos github]$ ssh -T git@github.com                         </span><br><span class="line">The authenticity of host <span class="string">'github.com (52.74.223.119)'</span> can<span class="string">'t be established.</span></span><br><span class="line"><span class="string">RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.</span></span><br><span class="line"><span class="string">Are you sure you want to continue connecting (yes/no)? yes</span></span><br><span class="line"><span class="string">Warning: Permanently added '</span>github.com,52.74.223.119<span class="string">' (RSA) to the list of known hosts.</span></span><br><span class="line"><span class="string">Hi xinlongOB/python.github.io! You'</span>ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure>



<p>克隆仓库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[sgsm@centos github]$ git <span class="built_in">clone</span>    https://github.com/xinlongOB/python.github.io.git</span><br><span class="line">Cloning into <span class="string">'python.github.io'</span>...</span><br><span class="line">remote: Enumerating objects: 46, <span class="keyword">done</span>.</span><br><span class="line">remote: Counting objects: 100% (46/46), <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (44/44), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 46 (delta 7), reused 0 (delta 0), pack-reused 0</span><br><span class="line">Unpacking objects: 100% (46/46), <span class="keyword">done</span>.</span><br><span class="line">[sgsm@centos github]$</span><br></pre></td></tr></table></figure>
<p>创建文件并且提交</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[sgsm@centos python.github.io]$ <span class="built_in">echo</span> <span class="string">"print("</span>hello world<span class="string">")"</span> &gt; print.py</span><br><span class="line">[sgsm@centos python.github.io]$ </span><br><span class="line">[sgsm@centos python.github.io]$ git add . </span><br><span class="line">[sgsm@centos python.github.io]$ git commit  -m <span class="string">"add print.py"</span></span><br><span class="line">[master 23b3cd1] add print.py</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 print.py</span><br><span class="line">[sgsm@centos python.github.io]$ </span><br><span class="line"><span class="comment"># 提交到 Github     因为这个github上面已经有origin   所以报错已存在  正常来说需要执行这一步</span></span><br><span class="line">[sgsm@centos python.github.io]$ git remote add origin   https://github.com/xinlongOB/python.github.io.git</span><br><span class="line">fatal: remote origin already exists.</span><br><span class="line"><span class="comment"># 推送到远程仓库</span></span><br><span class="line">[sgsm@centos python.github.io]$ git push  origin master</span><br><span class="line">Username <span class="keyword">for</span> <span class="string">'https://github.com'</span>: xinlongOB     <span class="comment"># 第一次需要输入账号</span></span><br><span class="line">Password <span class="keyword">for</span> <span class="string">'https://xinlongOB@github.com'</span>:      <span class="comment">#  密码</span></span><br><span class="line">Counting objects: 3, <span class="keyword">done</span>.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (2/2), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (3/3), 284 bytes | 284.00 KiB/s, <span class="keyword">done</span>.</span><br><span class="line">Total 3 (delta 1), reused 0 (delta 0)</span><br><span class="line">remote: Resolving deltas: 100% (1/1), completed with 1 <span class="built_in">local</span> object.</span><br><span class="line">To https://github.com/xinlongOB/python.github.io.git</span><br><span class="line">   e4e3a59..23b3cd1  master -&gt; master</span><br><span class="line">[sgsm@centos python.github.io]$ </span><br><span class="line"></span><br><span class="line">删除远程仓库</span><br><span class="line">```bash</span><br><span class="line">git remote rm [别名]</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote rm  origin</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>liunx</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>TortoiseSVN使用</title>
    <url>/2020/06/08/TortoiseSVN/</url>
    <content><![CDATA[<h2 id="部署subversion服务器"><a href="#部署subversion服务器" class="headerlink" title="部署subversion服务器"></a>部署subversion服务器</h2><p><a href="https://xinlong.youare.ink/2019/12/03/test/#4" target="_blank" rel="noopener">subversion安装部署</a></p>
<h2 id="TortoiseSVN-安装"><a href="#TortoiseSVN-安装" class="headerlink" title="TortoiseSVN 安装"></a>TortoiseSVN 安装</h2><p>下载地址：<a href="https://tortoisesvn.net/downloads.html" target="_blank" rel="noopener">https://tortoisesvn.net/downloads.html</a>, 页面里有语言包补丁的下载链接。</p>
<h2 id="TortoiseSVN检出代码"><a href="#TortoiseSVN检出代码" class="headerlink" title="TortoiseSVN检出代码"></a>TortoiseSVN检出代码</h2><p><br><img src="/2020/06/08/TortoiseSVN/5.png" alt><br><br><img src="/2020/06/08/TortoiseSVN/6.png" alt></p>
<h2 id="更新代码"><a href="#更新代码" class="headerlink" title="更新代码"></a>更新代码</h2><p><br><img src="/2020/06/08/TortoiseSVN/7.png" alt><br></p>
<h2 id="提交代码"><a href="#提交代码" class="headerlink" title="提交代码"></a>提交代码</h2><p><br><img src="/2020/06/08/TortoiseSVN/8.png" alt><br><br><img src="/2020/06/08/TortoiseSVN/9.png" alt></p>
<h2 id="切新分支"><a href="#切新分支" class="headerlink" title="切新分支"></a>切新分支</h2><p><br><img src="/2020/06/08/TortoiseSVN/10.png" alt><br><br><img src="/2020/06/08/TortoiseSVN/14.png" alt><br><br>切出后查看内容<br><br><img src="/2020/06/08/TortoiseSVN/15.png" alt><br><br>主线内容<br><br><img src="/2020/06/08/TortoiseSVN/16.png" alt></p>
<h2 id="查看提交记录"><a href="#查看提交记录" class="headerlink" title="查看提交记录"></a>查看提交记录</h2><p><br><img src="/2020/06/08/TortoiseSVN/18.png" alt><br><br><img src="/2020/06/08/TortoiseSVN/19.png" alt><br><br><img src="/2020/06/08/TortoiseSVN/20.png" alt><br><br><img src="/2020/06/08/TortoiseSVN/21.png" alt><br><br><img src="/2020/06/08/TortoiseSVN/22.png" alt><br></p>
<h2 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h2><p>一般公司都是在分支开发合并到主线，因为版本比较多所以我们公司是在主线开发合并到各个版本的分支<br><br>合并分支案例<br><br><img src="/2020/06/08/TortoiseSVN/33.png" alt><br><br><img src="/2020/06/08/TortoiseSVN/34.png" alt><br><br><img src="/2020/06/08/TortoiseSVN/35.png" alt><br><br><img src="/2020/06/08/TortoiseSVN/36.png" alt><br><br><img src="/2020/06/08/TortoiseSVN/37.png" alt><br><br><img src="/2020/06/08/TortoiseSVN/38.png" alt><br><br><img src="/2020/06/08/TortoiseSVN/39.png" alt><br><br><img src="/2020/06/08/TortoiseSVN/40.png" alt><br><br><img src="/2020/06/08/TortoiseSVN/41.png" alt><br><br><img src="/2020/06/08/TortoiseSVN/42.png" alt><br><br><img src="/2020/06/08/TortoiseSVN/43.png" alt><br><br><img src="/2020/06/08/TortoiseSVN/44.png" alt><br><br><img src="/2020/06/08/TortoiseSVN/45.png" alt></p>
<h2 id="报错解决："><a href="#报错解决：" class="headerlink" title="报错解决："></a>报错解决：</h2><p>提交报错：could not begin a transaction<br><br><img src="/2020/06/08/TortoiseSVN/1.png" alt><br><br>解决办法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span>  /data/svn/program</span><br><span class="line">sudo chown -R apache:apache  ./</span><br></pre></td></tr></table></figure>
<p>修改之前：<br><br><img src="/2020/06/08/TortoiseSVN/2.png" alt><br><br>修改之后：<br><br><img src="/2020/06/08/TortoiseSVN/3.png" alt><br><br>再次提交：<br><br><img src="/2020/06/08/TortoiseSVN/4.png" alt><br></p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>liunx</tag>
        <tag>subversion</tag>
      </tags>
  </entry>
  <entry>
    <title>redis基础配置-运维篇</title>
    <url>/2020/06/06/redis/</url>
    <content><![CDATA[<h2 id="Redis-必知"><a href="#Redis-必知" class="headerlink" title="Redis 必知"></a>Redis 必知</h2><p><br>redis基本的数据结构<br><br>最最最重要的并且是最基础的知识–记不住千万别说了解redis,本人有被羞辱的案例</p>
<pre><code>string：字符串
hash：散列
list：列表
set：集合
sorted set：有序集合</code></pre><h2 id="Redis-简介"><a href="#Redis-简介" class="headerlink" title="Redis 简介"></a>Redis 简介</h2><p> Redis 是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库。<br><br> Redis 与其他 key - value 缓存产品有以下三个特点：<br></p>
<pre><code>Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。
Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。
Redis支持数据的备份，即master-slave模式的数据备份。 </code></pre><h2 id="Redis-优势"><a href="#Redis-优势" class="headerlink" title="Redis 优势"></a>Redis 优势</h2><p>性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。<br><br>丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。<br><br>原子 – Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。<br><br>丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性<br></p>
<h2 id="Linux-下安装redis"><a href="#Linux-下安装redis" class="headerlink" title="Linux 下安装redis"></a>Linux 下安装redis</h2><p><br>下载地址：<a href="http://redis.io/download，下载最新稳定版本。" target="_blank" rel="noopener">http://redis.io/download，下载最新稳定版本。</a><br></p>
<pre><code>$ wget http://download.redis.io/releases/redis-2.8.17.tar.gz
$ tar xzf redis-2.8.17.tar.gz
$ cd redis-2.8.17
$ make</code></pre><p> make完后 redis-2.8.17目录下会出现编译后的redis服务程序redis-server,还有用于测试的客户端程序redis-cli,两个程序位于安装目录 src 目录下：</p>
<p>下面启动redis服务</p>
<pre><code>$ cd src
$ ./redis-server</code></pre><p>注意这种方式启动redis 使用的是默认配置。也可以通过启动参数告诉redis使用指定配置文件使用下面命令启动。 </p>
<pre><code>$ cd src
$ ./redis-server ../redis.conf</code></pre><p> redis.conf 是一个默认的配置文件。我们可以根据需要使用自己的配置文件。<br><br>启动redis服务进程后，就可以使用测试客户端程序redis-cli和redis服务交互了。 比如：<br></p>
<pre><code>$ redis-cli -h  192.168.1.163
192.168.1.163:6379&gt; AUTH mima
OK
192.168.1.163:6379&gt; keys *</code></pre><h2 id="Redis-配置文件"><a href="#Redis-配置文件" class="headerlink" title="Redis 配置文件"></a>Redis 配置文件</h2><p>主要用到的配置项</p>
<pre><code># 绑定的IP     redis-cli 的时候需要 加-h 选项 指定ip
bind 192.168.1.163  

# redis监听的端口号
port 6379        

# 此参数确定了TCP连接中已完成队列(完成三次握手之后)的长度， 当然此值必须不大于Linux系统定义的/proc/sys/net/core/somaxconn值，默认是511，而Linux的默认参数值是128。当系统并发量大并且客户端速度缓慢的时候，可以将这二个参数一起参考设定。该内核参数默认值一般是128，对于负载很大的服务程序来说大大的不够。一般会将它修改为2048或者更大。在/etc/sysctl.conf中添加:net.core.somaxconn = 2048，然后在终端中执行sysctl -p
tcp-backlog 511

# 此参数为设置客户端空闲超过timeout，服务端会断开连接，为0则服务端不会主动断开连接，不能小于0
timeout 300

# tcp keepalive参数。如果设置不为0，就使用配置tcp的SO_KEEPALIVE值，使用keepalive有两个好处:检测挂掉的对端。降低中间设备出问题而导致网络看似连接却已经与对端端口的问题。在Linux内核中，设置了keepalive，redis会定时给对端发送ack。检测到对端关闭需要两倍的设置值
tcp-keepalive 300

# 是否在后台执行，yes：后台运行；no：不是后台运行
daemonize yes

# redis进程文件路径
pidfile /var/run/redis.pid

# 日志等级
loglevel notice

# 日志路径
logfile /data/log/redis/redis-server.log

# 设置db库数量，默认16个库
databases 16

# 在900 秒内有一个键内容发生更改触发快照机制
save 900 1

# 在300 秒内有10个键内容发生更改触发快照机制
save 300 10

# 在10000 秒内有60个键内容发生更改触发快照机制
save 60 10000

# 久化到 RDB 文件时，是否压缩，&quot;yes&quot; 为压缩，“no” 则反之
rdbcompression yes

# 是否开启RC64校验，默认是开启
rdbchecksum yes

# 快照文件名
dbfilename dump.rdb

# 快照文件路径
dir /data/lib/redis

# 如果slave-serve-stale-data设置为yes(默认设置)，从库会继续响应客户端的请求。2) 如果slave-serve-stale-data设置为no，INFO,replicaOF, AUTH, PING, SHUTDOWN, REPLCONF, ROLE, CONFIG,SUBSCRIBE, UNSUBSCRIBE,PSUBSCRIBE, PUNSUBSCRIBE, PUBLISH, PUBSUB,COMMAND, POST, HOST: and LATENCY命令之外的任何请求都会返回一个错误”SYNC with master in progress”。
slave-serve-stale-data yes

# 配置Redis的Slave实例是否接受写操作，即Slave是否为只读Redis。默认值为yes
slave-read-only yes

# 主从数据复制是否使用无硬盘复制功能。默认值为no。
repl-diskless-sync no

# 当启用无硬盘备份，服务器等待一段时间后才会通过套接字向从站传送RDB文件，这个等待时间是可配置的。  这一点很重要，因为一旦传送开始，就不可能再为一个新到达的从站服务。从站则要排队等待下一次RDB传送。因此服务器等待一段  时间以期更多的从站到达。延迟时间以秒为单位，默认为5秒。要关掉这一功能，只需将它设置为0秒，传送会立即启动。默认值为5
repl-diskless-sync-delay 5

# 同步之后是否禁用从站上的TCP_NODELAY 如果你选择yes，redis会使用较少量的TCP包和带宽向从站发送数据。但这会导致在从站增加一点数据的延时。  Linux内核默认配置情况下最多40毫秒的延时。如果选择no，从站的数据延时不会那么多，但备份需要的带宽相对较多。默认情况下我们将潜在因素优化，但在高负载情况下或者在主从站都跳的情况下，把它切换为yes是个好主意。默认值为no。
repl-disable-tcp-nodelay no

# 当 master 不可用，Sentinel 会根据 slave 的优先级选举一个 master 。最低的优先级的 slave ，当选 master 。而配置成 0，永远不会被选举
slave-priority 100

# 是否开启 AOF 日志 记录 默认 redis使用的是 rdb 方式持久化，这种方式在许多应用中已经足够用了。但是 redis 如果中途宕机，会导致可能有几分钟的数据丢失
appendonly no

# 指定本地数据库文件名，默认值为 appendonly.aof
appendfilename &quot;appendonly.aof&quot;

# aof 持久化策略的配置 no 表示不执行 fsync 由操作系统保证数据同步到磁盘 ,always 表示每次写入都执行 fsync ，以保证数据同步到磁盘 ,everysec 表示每秒执行一次 fsync ，可能会导致丢失这 1s 数据。
appendfsync everysec

# （推荐为yes） 在 aof rewrite 期间 是否对 aof 新记录的 append 暂缓使用文件同步策略 主要考虑磁盘 IO 开支和请求阻塞时间。默认为 no, 表示不暂缓新的 aof 记录仍然会被立即同步Linux 的默认fsync策略是30 秒，如果为 yes 可能丢失 30 秒数据 ，但由于yes性能较好,而且会避免出现阻塞, 因此比较推荐
no-appendfsync-on-rewrite yes

# 当 Aof log增长超过指定百分比例时，重写 logfile设置为0表示不自动重写 Aof 日志，重写是为了使 aof 体积保持最小，而确保保存最完整的数据
auto-aof-rewrite-percentage 100

# # 触发 aof rewrite 的最小文件大小
auto-aof-rewrite-min-size 64mb

# aof文件可能在尾部是不完整的，当redis启动的时候，aof文件的数据被载入内存。重启可能发生在redis所在的主机操作系统宕机后，尤其在ext4文件系统没有加上data=ordered选项（redis宕机或者异常终止不会造成尾部不完整现象。）出现这种现象，可以选择让redis退出，或者导入尽可能多的数据。如果选择的是yes，当截断的aof文件被导入的时候，会自动发布一个log给客户端然后load。如果是no，用户必须手动redis-check-aof修复AOF文件才可以
aof-load-truncated yes

# 一个lua脚本执行的最大时间，单位为ms。默认值为5000
lua-time-limit 5000

# 只记录大于等于下边设置的值的操作。0的话，就是关闭监视。默认延迟监控功能是关闭的，如果你需要打开，也可以通过CONFIG SET命令动态设置
latency-monitor-threshold 0

# 数据量小于等于hash-max-ziplist-entries的用ziplist，大于hash-max-ziplist-entries用hash
hash-max-ziplist-entries 512

# value大小小于等于hash-max-ziplist-value的用ziplist，大于hash-max-ziplist-value用hash
hash-max-ziplist-value 64

#-5:最大大小：64 KB&lt;--不建议用于正常工作负载
#-4:最大大小：32 KB&lt;--不推荐
#-3:最大大小：16 KB&lt;--可能不推荐
#-2:最大大小：8kb&lt;--良好
#-1:最大大小：4kb&lt;--良好
list-max-ziplist-size -2

# 数据量小于等于set-max-intset-entries用iniset，大于set-max-intset-entries用set
set-max-intset-entries 512

# 数据量小于等于zset-max-ziplist-entries用ziplist，大于zset-max-ziplist-entries用zset
zset-max-ziplist-entries 128

# value大小小于等于zset-max-ziplist-value用ziplist，大于zset-max-ziplist-value用zset
zset-max-ziplist-value 64

# rename-command：命令重命名，对于一些危险命令例如  FLUSHDB（清空数据库）　FLUSHALL（清空所有记录） CONFIG（客户端连接后可配置服务器）  EVAL (Eval 命令使用 Lua 解释器执行脚本)
rename-command FLUSHALL &quot;&quot;
rename-command FLUSHDB &quot;&quot;
rename-command CONFIG &quot;&quot;
rename-command EVAL &quot;&quot;

# redis 认证密码
requirepass GwJMMSdSHezfeMRMP34fQ0F0F</code></pre><h2 id="Redis-语法"><a href="#Redis-语法" class="headerlink" title="Redis 语法"></a>Redis 语法</h2><p>连接redis</p>
<pre><code>redis-cli -h host -p port -a password</code></pre><p>查看所有的键值对–一般大公司是禁止使用keys *</p>
<pre><code>192.168.1.163:6379&gt; keys *</code></pre><p>正则表达式匹配键值对</p>
<pre><code>192.168.1.163:6379&gt; keys *info*water*
1) &quot;info:&quot;
2) &quot;info:hero&quot;
3) &quot;info:serverInfo&quot;</code></pre><p>查看hash值</p>
<pre><code>192.168.1.163:6379&gt; HGETALL &quot;xxxxxx&quot;
1) &quot;1001&quot;
2) &quot;\&quot;{\\\&quot;roleInfoList\\\&quot;: xxxxx}\&quot;&quot;</code></pre><p>查看有序集合</p>
<pre><code>192.168.1.163:6379&gt; ZREVRANGE &quot;xxxxxxxx&quot; 0 10      # 0表示第一个      
1) &quot;id&quot;
192.168.1.163:6379&gt; ZREVRANGE &quot;xxxxxxxx&quot; 0 10  WITHSCORES   #  加上WITHSCORES可以打印积分
1) &quot;id&quot;
2) &quot;integral&quot;</code></pre><p>删除有序集合成员</p>
<pre><code>ZREM  key  value</code></pre><p>删除键值</p>
<pre><code>del  key</code></pre><p>修改集合</p>
<pre><code>hset keys   更改后的内容</code></pre><p>备份</p>
<pre><code>redis 192.168.1.163:6379&gt; SAVE 
OK</code></pre><h2 id="Redis迁移"><a href="#Redis迁移" class="headerlink" title="Redis迁移"></a>Redis迁移</h2><p>先备份</p>
<pre><code>[root@izm5ea99qngm2vazfs49svz ~]# redis-cli 
127.0.0.1:6379&gt;  AUTH mima      #  认证
OK
127.0.0.1:6379&gt;  SAVE         # 保存数据
OK
127.0.0.1:6379&gt;  CONFIG GET dir       # 查看保存数据位置
1) &quot;dir&quot;
2) &quot;/var/lib/redis&quot;</code></pre><p>需要先把远程服务器的redis停止  然后备份一下当前的快照 不然直接scp过去 会有问题</p>
<pre><code>cd  /var/lib/redis
mv   dump.rdb  dump.rdb.bak</code></pre><p>把快照文件发送到远程服务器</p>
<pre><code>cd  /var/lib/redis  
scp    dump.rdb   user@IP:/var/lib/redis</code></pre><p>启动redis</p>
<pre><code>sudo  redis-server   /etc/redis/redis.conf</code></pre><p>进去redis查看是否迁移成功</p>
<pre><code>[root@test ~]# redis-cli 
127.0.0.1:6379&gt;  AUTH mima  
OK
127.0.0.1:6379&gt;  keys *
1) &quot;info:&quot;
2) &quot;info:hero&quot;
3) &quot;info:serverInfo&quot;</code></pre><p>命令行执行redis语句</p>
<pre><code>redis-cli  -h  127.0.0.1  -p 6379  -a &quot;mima&quot;  del  

echo  &apos;set aaa aaaa&apos; |redis-cli -h   127.0.0.1  -a mima</code></pre><p>附一个redis批量操作的脚本</p>
<pre><code>server=$1     # 传入的第一个参数定义为server
host=$2     # 传入的第二个参数定义为host
echo   &quot;AUTH mima  
ZREVRANGE  chart:newbox@$server:6  0 -1 &quot; &gt; $1.txt        # echo 密码和 语句到$1.txt文件
cat  $1.txt |   redis-cli  -h  $host    &gt;  $1_linshi.txt    命令行执行redis语句   语句内容就是$1.txt文件中的内容   执行结果重定向到  $1_linshi.txt 


cat $1_linshi.txt   |sed  1d  &gt;  $1_redis.txt     # 删除 $1_linshi.txt  文件的第一行


echo   &quot;AUTH mima&quot;  &gt; insert.txt      # echo 密码到insert.txt文件
for role in  `cat  $1_redis.txt`
do

  echo &quot;ZADD  chart:newbox@$server:6  0  $role &quot;  &gt;&gt; insert.txt

done            # for循环 $1_linshi.txt 文件   添加0 到每个键值对中
cat  insert.txt |   redis-cli  -h  $host     执行redis语句</code></pre>]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>liunx</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>kubernetes服务原理</title>
    <url>/2020/06/06/kubernetesyuanli/</url>
    <content><![CDATA[<h2 id="容器编排系统的具体任务"><a href="#容器编排系统的具体任务" class="headerlink" title="容器编排系统的具体任务"></a>容器编排系统的具体任务</h2><pre><code>服务注册和服务发现
负载均衡
配置和存储管理
健康状态监测
自动扩容、缩容、重启
0宕机部署</code></pre><h2 id="容器编排系统工具"><a href="#容器编排系统工具" class="headerlink" title="容器编排系统工具"></a>容器编排系统工具</h2><pre><code>kubernetes
docker swarm
apache mesos and marathon</code></pre><h2 id="此篇文档主要介绍kubernetes"><a href="#此篇文档主要介绍kubernetes" class="headerlink" title="此篇文档主要介绍kubernetes"></a>此篇文档主要介绍kubernetes</h2><p><br>kubernetes是一个开源的平台、自动部署伸缩、自动运维容器化应用平台，支持跨主机的集群多节点。<br></p>
<p>kubernetes集群节点由master和node以及插件组成<br><br>多个master是为了冗余<br><br>而node节点就是工作节点</p>
<h2 id="master组成部分"><a href="#master组成部分" class="headerlink" title="master组成部分"></a>master组成部分</h2><p>  API server api入口 是一个数据  负责接受用户的请求 语法没问题 放到etcd<br>  scheduler    调度器  查看那台服务器适合执行node 会一直watch apiserver上是否有新建资源<br>  <br>  controller    控制器（一直循环 也成控制循环器）  负责让调度器调用镜像启动容器，确保容器正常运行，自动重启 重启失败直接干掉  controller 会一直watch apiserver上的资源变动 如果有变动  会立即执行用户的请求 <br><br>  还有个额外的etcd  会存储各种k v 规范数据   规范是apisever定义的</p>
<h2 id="node组成部分"><a href="#node组成部分" class="headerlink" title="node组成部分"></a>node组成部分</h2><p>  kubelet 一直watch apiserver  如果需要创建容器 会去调用docker docker去调用region（镜像仓库）<br>   <br>  docker 容器  <br><br>  pod   容器外壳，一个pod中可以存在多个容器<br>   <br>  proxy  <br> </p>
<p>kubernetes 运行的核心基本单元是pod(原子单元)而不是容器</p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>docker容器是利用内核的六种名称空间技术 来实现程序运行环境的隔离<br><br>pid  网络  文件系统  ipc  user uts（域名和主机名）<br></p>
<p>docker的四种网络模型  </p>
<pre><code>封闭网络   closed
桥接网络   bridge
联盟网络 joined（两个宿主机共享network 和 ipc uts） 
共享宿主机  host</code></pre><h2 id="kubernetes常用的资源类型"><a href="#kubernetes常用的资源类型" class="headerlink" title="kubernetes常用的资源类型"></a>kubernetes常用的资源类型</h2><p><br>pod  service（服务）  namespace（名称空间） volume（存储卷）<br></p>
<h2 id="kubernetes的各种IP"><a href="#kubernetes的各种IP" class="headerlink" title="kubernetes的各种IP"></a>kubernetes的各种IP</h2><p>service（服务）  客户端访问的不是pod_ip 而是访问的service_ip 这样pod宕机后被移除，新添加的pod的ip会是新分配的<br><br>pod_ip  每一个pod都有一个虚拟ip<br><br>service_ip  通过标签选择来管理pod_ip<br><br>DNS  主要管理service_ip 如果 service被意外删除 或者其他情况无法使用  调度器会立即创建新的service_ip  dns动态获取A记录<br><br>node_ip  是节点网卡的ip</p>
<p>访问流程</p>
<pre><code>客户端访问  需要先访问service_ip  然后service_ip 访问pod组件 而pod组件是pod的管理器创建的
例如：客户端访问nginx    会先访问service_ip 然后service_ip转到nginx的pod       nginx_pod 是由pod控制器的管理创建的   
    nginx在访问tomcat的service_ip    tomcat的service_ip 在转到tomcat tomcat_pod也有一个控制器</code></pre><p>kubernetes有三种网络：</p>
<pre><code>节点网络
pod网络  每个pod都是想通的
service网络</code></pre><p>部署</p>
<p>  测试环境</p>
<pre><code>可以使用单点master节点，单etcd实例，node节点按需而定，nfs或者glusterfs等存储系统</code></pre><p>  生产环境</p>
<pre><code>高可用etcd，建立3、5或者7个节点
高可用master
    kube-apiserver 无状态，可多实例
              借助keepalived进行vip流动实现多实例冗余
              或在多实例前端通过haproxy或者nginx反代，并借助于keepalived对代理服务器进行冗余
    kubu-scheduler及kube-controller-manager各自只能有一个活动实例，但可以有多个备用
              各自自带leader选举的功能，并且默认处于启动状态
  多node主机，数量越多，冗余能力越强
  ceph，glusterfs，iscsi， fc san及各种云存储等</code></pre><p>  常用的部署环境</p>
<pre><code>iaas公有云环境：aws，gce，azure等
iaas私有云或者公有云环境，OpenStack和vsphere等
物理服务器或者独立的虚拟机等</code></pre><p>  常用的部署工具</p>
<pre><code>kubeadm(官方工具)
kops(aws专用工具)
kubespray
kontena Pharos</code></pre><p>  其他二次封装的常用发行版</p>
<pre><code>Rancher
Tectonic
Openshift(redhat公司k8s发行版)</code></pre><h2 id="安装文档"><a href="#安装文档" class="headerlink" title="安装文档"></a>安装文档</h2><p><a href="https://xinlong.youare.ink/2020/05/22/kubeadm/" target="_blank" rel="noopener">使用kubeadm安装kubernetes</a></p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>liunx</tag>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>jenkins报错--秘钥认证失败</title>
    <url>/2020/06/01/jenkinsbaocuo/</url>
    <content><![CDATA[<p>测试服更换机器后，新服务器把旧服务器ip顶替，但是秘钥不同。构建的时候报错</p>
<p>报错日志：</p>
<pre><code>Pseudo-terminal will not be allocated because stdin is not a terminal.
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!
Someone could be eavesdropping on you right now (man-in-the-middle attack)!
It is also possible that a host key has just been changed.
The fingerprint for the RSA key sent by the remote host is
SHA256:y0IuKOX1vqISQPtpFZ3zbC+DtBqRMQfd1dXj8foo3Fs.
Please contact your system administrator.
Add correct host key in /var/lib/jenkins/.ssh/known_hosts to get rid of this message.
Offending ECDSA key in /var/lib/jenkins/.ssh/known_hosts:7
Password authentication is disabled to avoid man-in-the-middle attacks.
Keyboard-interactive authentication is disabled to avoid man-in-the-middle attacks.
Permission denied (publickey,gssapi-keyex,gssapi-with-mic,password).
Build step &apos;Execute shell&apos; marked build as failure
Finished: FAILURE</code></pre><p>解决办法：</p>
<pre><code>vim  /var/lib/jenkins/.ssh/known_hosts</code></pre><p>找到对应的IP数据删除整行的秘钥</p>
<p>重新执行构建就ok了</p>
]]></content>
      <tags>
        <tag>liunx</tag>
        <tag>jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>nodejs之事件监听</title>
    <url>/2020/05/30/nodejs5/</url>
    <content><![CDATA[<h2 id="事件概述"><a href="#事件概述" class="headerlink" title="事件概述"></a>事件概述</h2><p>大多数 Node.js 核心 API 构建于惯用的异步事件驱动架构，其中某些类型的对象（又称触发器，Emitter）会触发命名事件来调用函数（又称监听器，Listener）。比如：fs.readStream 打开文件时会发出一个事件。可以通过 require(“events”); 获得 event 模块。通常，事件名采用“小驼峰式”（即第一个单词全小写，后面的单词首字母大写，其它字母小写）命名方式。</p>
<p>所有能触发事件的对象都是EventEmitter类的实例，这些对象有一个eventEmitter.on()函数，用于将一个或多个函数绑定到命名事件上。当EventEmitter对象触发一个事件时，所有绑定在该事件上的函数都会被同步地调用</p>
<p>EventEmitter类获取</p>
<pre><code>// 引入 events模块
var events = require(&quot;events&quot;)
// 创建 eventEmitter对象
var eventEmitter = new events.EventEmitter();</code></pre><h2 id="添加监听器"><a href="#添加监听器" class="headerlink" title="添加监听器"></a>添加监听器</h2><p>emitter.on(eventName,listener)<br><br>使用emitter.on(eventName,listener)方法为指定事件注册一个监听器，添加listener函数到名为eventname的事件的监听器数组的末尾，不会检查listener是否已被添加。多次调用并传入相同的eventname 与 listener会导致listener会被添加多次<br></p>
<p>  参数说明：</p>
<pre><code>eventName：事件名称，string类型。
listener：回调函数</code></pre><p>例子：</p>
<pre><code>// 引入events模块
var events = require(&quot;events&quot;);
// 创建emitter 对象
var emitter = new events.EventEmitter();
// 为 connection 事件注册一个监听器
emitter.on(&quot;connection&quot;,function(){
    console.log(&quot;已连接&quot;);
});

// 一秒后调用监视器
setTimeout(function(){
    emitter.emit(&quot;connection&quot;);
},1000)</code></pre><p>运行结果：</p>
<pre><code>$ node listener.js
已连接    // 一秒后打印已连接</code></pre><p>默认情况下，事件监听器会按照添加的顺序依次调用。emitter.prependListener() 方法可用于将事件监听器添加到监听器数组的开头。比如：</p>
<pre><code>// 引入events模块
var events = require(&quot;events&quot;);
// 创建emitter 对象
var emitter = new events.EventEmitter();
// 为 connection 事件注册一个监听器
emitter.on(&quot;connection&quot;,function(){
    console.log(&quot;我是a&quot;);
});

emitter.prependListener(&quot;connection&quot;,function(){
    console.log(&quot;我是b&quot;);
});


// 一秒后调用监视器
setTimeout(function(){
    emitter.emit(&quot;connection&quot;);
},1000)</code></pre><p>运行结果：</p>
<pre><code>$ node listener.js
我是b
我是a</code></pre><p>注：emitter.addListener(eventName, listener) 是 emitter.on(eventName, listener) 的别名。</p>
<h2 id="调用监听器"><a href="#调用监听器" class="headerlink" title="调用监听器"></a>调用监听器</h2><p><br>使用emitter.emit(eventName[, …args])按照监听器注册的顺序，同步地调用每个注册到名为eventName的事件监听器，并传入提供的参数。如果事件有注册监听返回True，否则返回false<br></p>
<p>  参数说明：</p>
<pre><code>eventName：事件名称
args：传递的参数，多个，类型为任意</code></pre><p>例如：</p>
<pre><code>// 引入event模块
var events = require(&quot;events&quot;);
// 创建emitter 对象
var emitter = new events.EventEmitter();
// 定义一个回调函数
var callback1 = function(arg1,arg2){
    console.log(&quot;print&quot;,arg1,arg2);
};

var callback2 = function(arg3,arg4){
    console.log(&quot;echo &quot;,arg3,arg4);
};

// 为 connection 事件注册监听器
emitter.on(&quot;connection&quot;,callback1)
emitter.on(&quot;connection&quot;,callback2)

// 调用监听器
emitter.emit(&quot;connection&quot;,&quot;愿你&quot;,&quot;安好&quot;)</code></pre><p>运行结果：</p>
<pre><code>$ node emit.js
print 愿你 安好
echo 愿你 安好</code></pre><h2 id="只执行一次的监听器"><a href="#只执行一次的监听器" class="headerlink" title="只执行一次的监听器"></a>只执行一次的监听器</h2><p><br>当时用eventEmitter.on(eventName,listener)注册监听器时，监听器会在每次触发命名事件时被调用。比如：<br></p>
<pre><code>// 引入 events模块
var  events = require(&quot;events&quot;);
// 创建emitter对象
var emitter = new events.EventEmitter();
// 为 connectio 事件注册一个监听器
var n = 0;
emitter.on(&quot;connection&quot;,function(){
    ++n;
    console.log(&quot;调用第&quot; + n + &quot;次&quot;);
})

// 调用监听器
emitter.emit(&quot;connection&quot;)
emitter.emit(&quot;connection&quot;)
emitter.emit(&quot;connection&quot;)
emitter.emit(&quot;connection&quot;)</code></pre><p>运行结果：</p>
<pre><code>$ node while.js
调用第1次
调用第2次
调用第3次
调用第4次</code></pre><p>使用 eventEmitter.once(eventName, listener) 可以注册最多可调用一次的监听器。当事件被触发时，监听器会被注销，然后再调用。比如：</p>
<pre><code>// 引入 events模块
var  events = require(&quot;events&quot;);
// 创建emitter对象
var emitter = new events.EventEmitter();
// 为 connectio 事件注册一个监听器
var n = 0;
emitter.once(&quot;connection&quot;,function(){    // 把emitter.on  换为 emitter.once
    ++n;
    console.log(&quot;调用第&quot; + n + &quot;次&quot;);
})

// 调用监听器
emitter.emit(&quot;connection&quot;)
emitter.emit(&quot;connection&quot;)
emitter.emit(&quot;connection&quot;)
emitter.emit(&quot;connection&quot;)</code></pre><p>运行结果：</p>
<pre><code>$ node while.js
调用第1次</code></pre><p>默认情况下，事件监听器会按照添加的顺序依次调用。emitter.prependOnceListener() 方法可用于将事件监听器添加到监听器数组的开头。用法与我们前面所学的 emitter.prependListener() 方法一致，区别在于这个方法注册的监听器最多只能调用一次</p>
<h2 id="移除监听器"><a href="#移除监听器" class="headerlink" title="移除监听器"></a>移除监听器</h2><p><br>使用emitter.removeListener(eventName.listener)移除监听器<br><br>参数说明：</p>
<pre><code>eventName：事件名称
listener：监听器也就是回调函数名称</code></pre><p>例如：</p>
<pre><code>// 引入 events 模块
var events = require(&quot;events&quot;);
// 创建 emitter 对象
var emitter = new events.EventEmitter();
// 定义一个回调函数
var callback = function () {
  console.log(&quot;syl&quot;);
};
// 为 connection 事件注册一个监听器
emitter.on(&quot;connection&quot;, callback);
// 为 connection 事件移除监听器
emitter.removeListener(&quot;connection&quot;, callback);
// 调用监听器
emitter.emit(&quot;connection&quot;);</code></pre><p>运行结果</p>
<pre><code>Administrator@WF-20180726HPZY MINGW64 /e/coding/nodejs
$ node emit.js

Administrator@WF-20180726HPZY MINGW64 /e/coding/nodejs</code></pre><p>注：removeListener() 最多只会从监听器数组中移除一个监听器。我们可以多次调用 removeListener() 的方式来一个个的移除我们需要移除掉的监听器。</p>
<p>一旦事件被触发，所有绑定到该事件的监听器都会按顺序依次调用。也就是说在事件触发之后、且最后一个监听器执行完成之前，removeListener() 或 removeAllListeners() 不会从 emit() 中移除它们。</p>
<p>例如：</p>
<pre><code>// 引入 events 模块
var events = require(&quot;events&quot;);
// 创建 emitter 对象
var emitter = new events.EventEmitter();
// 定义回调函数
var callback1 = function () {
  console.log(&quot;我是1&quot;);
  emitter.removeListener(&quot;connection&quot;, callback2);
};
var callback2 = function () {
  console.log(&quot;我是2&quot;);
};
// 为 connection 事件注册监听器
emitter.on(&quot;connection&quot;, callback1);
emitter.on(&quot;connection&quot;, callback2);
// 第一次调用监听器，callback1 移除了监听器 callback2，但它依然会被调用。触发时内部的监听器数组为 [callback1, callback2]
emitter.emit(&quot;connection&quot;);
// 第二次调用监听器，此时 callback2 已经被移除了。内部的监听器数组为 [callback1]
emitter.emit(&quot;connection&quot;);</code></pre><p>运行结果：</p>
<pre><code>$ node emit.js
我是1
我是2
我是1</code></pre>]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>liunx</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>nodejs之基础函数</title>
    <url>/2020/05/30/nodejs4/</url>
    <content><![CDATA[<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>在JavaScript中，一个函数可以作为另一个函数的参数。我们可以先定义一个函数，然后传递，也可以在传递参数的地方直接定义函数。</p>
<p>Node.js中函数的使用与Javascript类似，举例来说，你可以这样做： </p>
<pre><code>function say(word) {
  console.log(word);
}

function execute(someFunction, value) {
  someFunction(value);
}

execute(say, &quot;Hello&quot;);</code></pre><p>执行结果</p>
<pre><code>Administrator@WF-20180726HPZY MINGW64 /e/coding/nodejs
$ node test.js
word</code></pre><p> 以上代码中，我们把 say 函数作为execute函数的第一个变量进行了传递。这里传递的不是 say 的返回值，而是 say 本身！<br><br>这样一来， say 就变成了execute 中的本地变量 someFunction ，execute可以通过调用 someFunction() （带括号的形式）来使用 say 函数。<br><br>当然，因为 say 有一个变量， execute 在调用 someFunction 时可以传递这样一个变量。 </p>
<h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p><br>我们可以把一个函数作为变量传递，但是我们不一样要绕这个”先定义，在传递”的圈子，我们可以直接在另一个函数的括号中定义和传递这个参数：<br></p>
<pre><code>function execute(someFunction,value){
    someFunction(value);
}
execute(function(word){console.log(word)},&quot;hello&quot;)</code></pre><p>运行结果：</p>
<pre><code>$ node test.js
hello</code></pre><p> 我们在 execute 接受第一个参数的地方直接定义了我们准备传递给 execute 的函数。用这种方式，我们甚至不用给这个函数起名字，这也是为什么它被叫做匿名函数 。 </p>
<h2 id="导出函数"><a href="#导出函数" class="headerlink" title="导出函数"></a>导出函数</h2><pre><code>function say(word){
      console.log(&quot;word&quot;);
  }

  exports.say = say;</code></pre><p>接收函数</p>
<pre><code>var test = require(&quot;./test.js&quot;)

test.say();</code></pre><p>执行结果</p>
<pre><code>$ node a.js
word</code></pre>]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>liunx</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>nodejs模块</title>
    <url>/2020/05/29/nodejs3/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><br>包用于管理多个模块及依赖关系，可以对多个模块进行封装，包的根目录必须包含package.jsonwenjian，package.json文件是commonjs规范用于描述包的文件，符合commonjs规范的package.json文件一般包含以下字段：<br><br>  1、name：包名。包名是唯一的，只能包含小写字母、数字和下划线<br>  2、version：包版本号<br>  3、description：包说明<br>  4、keywords：关键字数组，用于搜索<br>  5、homepage：项目主页<br>  6、bugs：提交bug的地址<br>  7、license：许可证<br>  8、maintainers：维护者数组<br>  9、contribution：贡献者数组<br>  10、repositories：项目仓库托管地址数组<br>  11、dependencies：包依赖</p>
<p>下面是一个package.json示例：</p>
<pre><code>{
  &quot;name&quot;: &quot;shiyanlou&quot;,
  &quot;description&quot;: &quot;Shiyanlou test package.&quot;,
  &quot;version&quot;: &quot;0.1.0&quot;,
  &quot;keywords&quot;: [&quot;shiyanlou&quot;, &quot;nodejs&quot;],
  &quot;maintainers&quot;: [
    {
      &quot;name&quot;: &quot;test&quot;,
      &quot;email&quot;: &quot;test@shiyanlou.com&quot;
    }
  ],
  &quot;contributors&quot;: [
    {
      &quot;name&quot;: &quot;test&quot;,
      &quot;web&quot;: &quot;http://www.shiyanlou.com/&quot;
    }
  ],
  &quot;bugs&quot;: {
    &quot;mail&quot;: &quot;test@shiyanlou.com&quot;,
    &quot;web&quot;: &quot;http://www.shiyanlou.com/&quot;
  },
  &quot;licenses&quot;: [
    {
      &quot;type&quot;: &quot;Apache License v2&quot;,
      &quot;url&quot;: &quot;http://www.apache.org/licenses/apache2.html&quot;
    }
  ],
  &quot;repositories&quot;: [
    {
      &quot;type&quot;: &quot;git&quot;,
      &quot;url&quot;: &quot;http://github.com/test/test.git&quot;
    }
  ],
  &quot;dependencies&quot;: {
    &quot;webkit&quot;: &quot;1.2&quot;,
    &quot;ssl&quot;: {
      &quot;gnutls&quot;: [&quot;1.0&quot;, &quot;2.0&quot;],
      &quot;openssl&quot;: &quot;0.9.8&quot;
    }
  }
}</code></pre><p>注：package.json 文件可以自己手动编辑，还可以通过 npm init 命令进行生成。你可以自己尝试在终端中输入 npm init 命令来生成一个包含 package.json 文件的包。直接输入 npm init –yes 跳过回答问题步骤，直接生成默认值的 package.json 文件。此外，我们在 github 上传自己项目的时候，通常是不会把 node_modules 这个文件夹传上去的（太大了），只需要有 package.json 就能通过 npm install 命令安装所有依赖</p>
<pre><code>npm init --yes</code></pre><p>执行结果</p>
<pre><code>Wrote to E:\程序代码\nodejs\package.json:

{
  &quot;name&quot;: &quot;nodejs&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;scripts&quot;: {
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;
  },
  &quot;keywords&quot;: [],
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;ISC&quot;
}</code></pre><p>注：执行init的文件夹名称必须要符合要求不可以包含中文以及特殊字符</p>
<h2 id="包操作"><a href="#包操作" class="headerlink" title="包操作"></a>包操作</h2><p>通过命令npm  install  xxx来安装包。比如：<br><br>安装包<br></p>
<pre><code>npm install  express</code></pre><p>更新包</p>
<pre><code>npm update  express</code></pre><p>删除包</p>
<pre><code>npm  uninstall express</code></pre><p>搜索包</p>
<pre><code>npm search express</code></pre><p>注：安装包的时候指定版本使用@  例如： npm install <a href="mailto:pm2@2.8.0">pm2@2.8.0</a></p>
<p>在JavaScripts中，我们通常把 JavaScript 代码分为几个 js 文件，然后在浏览器中将这些 js 文件合并运行，但是在 Node.js 中，是通过以模块为单位来划分所有功能的。每一个模块为一个 js 文件，每一个模块中定义的全局变量和函数的作用范围也被限定在这个模块之内，只有使用 exports 对象才能传递到外部使用。Node.js 官方提供了很多模块，这些模块分别实现了一种功能，如操作文件及文件系统的模块 fs，构建 http 服务的模块 http，处理文件路径的模块 path 等。当然我们也可以自己编写模块。</p>
<p>模块的使用<br><br>在nodejs创建模块很简单，比如我们创建一个myMoudule.js的文件<br></p>
<pre><code>function foo(){
  console.log(&quot;hello world&quot;)
}</code></pre><p>这样就创建好了一个模块，但是别的模块如何来访问它呢？我们使用 module.exports 来导出它。也就是说把 myModule.js 的代码改写成下面这样：</p>
<pre><code>function foo(){
  console.log(&quot;hello world&quot;)
}
module.exports.foo = foo;</code></pre><p>最后我们在创建一个index.js的文件，使用require()函数来访问上面的模块。输入一下代码：</p>
<pre><code>var hello = require(&quot;./myModule.js&quot;);
hello.foo();</code></pre><p>运行结果：</p>
<pre><code>$ node myModule.js 


$ node index.js
hello world</code></pre><p>注：require() 加载模块，以 ‘/‘ 为前缀的模块是文件的绝对路径。’./‘ 为前缀的模块是相对于调用 require() 的文件的，上面的例子中 index.js 和 myModule.js 是在同一个目录下（project 目录）。当没有以 ‘/‘、’./‘ 或 ‘../‘ 开头来表示文件时，这个模块必须是一个核心模块或加载自 node_modules 目录。如果给定的路径不存在，则 require() 会抛出一个 code 属性为 ‘MODULE_NOT_FOUND’ 的 Error。</p>
<h2 id="核心模块"><a href="#核心模块" class="headerlink" title="核心模块"></a>核心模块</h2><p><br>核心模块定义在nodejs源代码的lib/ 目录下。require()总是会优先加载核心模块。例如：require(‘http’)始终返回内置的HTTP模块，即使有同名文件<br></p>
<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p><br>当循环调用require()时，一个模块可能在未完成执行时被返还。比如：<br></p>
<p>a.js 的代码为：</p>
<pre><code>console.log(&quot;a 开始&quot;);
exports.done = false;
var b = require(&quot;./b.js&quot;);
console.log(&quot;在 a 中，b.done = %j&quot;, b.done);
exports.done = true;
console.log(&quot;a 结束&quot;);</code></pre><p>b.js 的代码为：</p>
<pre><code>console.log(&quot;b 开始&quot;);
exports.done = false;
var a = require(&quot;./a.js&quot;);
console.log(&quot;在 b 中，a.done = %j&quot;, a.done);
exports.done = true;
console.log(&quot;b 结束&quot;);</code></pre><p>main.js 的代码为：</p>
<pre><code>console.log(&quot;main 开始&quot;);
var a = require(&quot;./a.js&quot;);
var b = require(&quot;./b.js&quot;);
console.log(&quot;在 main 中，a.done=%j，b.done=%j&quot;, a.done, b.done);</code></pre><p>运行效果为：</p>
<pre><code>silly dog@LAPTOP-OEVDT7RG MINGW64 /e/程序代码/nodejs
$ node main.js
main 开始
a 开始
b 开始
在 b 中，a.done = false
b 结束
在a 中,b.done = true
a 结束
在 main 中，a.done=true，b.done=true

silly dog@LAPTOP-OEVDT7RG MINGW64 /e/程序代码/nodejs</code></pre><p>也就是说当 main.js 加载 a.js 时，a.js 又加载 b.js。此时，b.js 会尝试去加载 a.js。为了防止无限的循环，会返回一个 a.js 的 exports 对象的未完成的副本给 b.js 模块。然后 b.js 完成加载，并将 exports 对象提供给 a.js 模块。</p>
<p>module.exports 和 exports 的区别<br><br>我们发现每次导出接口成员的时候都通过module.exports.xxx = xxx 的方式很麻烦，点儿的太多了。所以，nodejs为了简化你的操作，专门提供了一个变量：exports 等于 module.exports。也就是说在模块中还有这么一句代码<br></p>
<pre><code>var exports = module.exports;</code></pre><p>我们前面案例中的代码也就可以简写了：</p>
<pre><code>module.exports.foo = foo;
exports.foo = foo; // 这两行代码效果是一样的</code></pre><p>但是需要注意的是：就像任何变量，如果一个新的值被赋值给 exports，它就不再绑定到 module.exports。我们具体来看个例子：</p>
<p>a.js 的代码:</p>
<pre><code>console.log(module.exports === exports);</code></pre><p>运行结果</p>
<pre><code>silly dog@LAPTOP-OEVDT7RG MINGW64 /e/程序代码/nodejs
$ node 1.js
true

silly dog@LAPTOP-OEVDT7RG MINGW64 /e/程序代码/nodejs</code></pre><p>两者一致，说明我们可以用任意一个来导出内部成员</p>
<p>b.js 的代码：</p>
<pre><code>exports = {
  a: 3,
};
console.log(exports);
console.log(module.exports);
console.log(exports === module.exports);</code></pre><p>运行结果</p>
<pre><code>silly dog@LAPTOP-OEVDT7RG MINGW64 /e/程序代码/nodejs
$ node 1.js
{ a: 3 }
{}
false

silly dog@LAPTOP-OEVDT7RG MINGW64 /e/程序代码/nodejs</code></pre><p>也就是说给 exports 赋值会断开和 module.exports 之间的引用，同样的给 module.exports 重新赋值也会断开它们之间的引用。但是最终导出的是 module.exports，在上面的例子中我们另外一个文件来用 require() 加载 b.js 只会得到 {} 而不是 {a:3}。</p>
<p>总结：require() 得到的是 module.exports 导出的值，导出多个成员可以用 module.exports 和 exports，导出单个成员只能用 module.exports。如果你实在不好区分，那就全部都使用 module.exports 也是没问题的。</p>
]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>liunx</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js 创建第一个应用</title>
    <url>/2020/05/28/nodejs2/</url>
    <content><![CDATA[<p>  1、引入 required 模块：使用 required 指令来载入 Node.js 模块。<br>  2、创建服务器：服务器可以监听客户端的请求，类似于 Apache、Nginx 等 HTTP 服务器。<br>  3、接受请求与响应请求。</p>
<p>新建一个名为 server.js 的文件</p>
<pre><code>var http = require(&quot;http&quot;); // 加载 http 模块，并将实例化的 HTTP 赋值给变量 http

http
  .createServer(function (request, response) {
    // 发送 HTTP 头部
    // HTTP 状态值: 200 : OK
    // 内容类型: text/plain
    response.writeHead(200, { &quot;Content-Type&quot;: &quot;text/plain&quot; });

    response.end(&quot;Hello World\n&quot;); // 发送响应数据 &quot;Hello World&quot;
  })
  .listen(8080);

// 终端打印如下信息
console.log(&quot;Server running at http://127.0.0.1:8080/&quot;);</code></pre><p>以上代码我们完成了一个可以工作的 HTTP 服务器。本地计算机使用 node server.js 命令后，直接在浏览器中访问 <a href="http://127.0.0.1:8888/，你会看到一个写着" target="_blank" rel="noopener">http://127.0.0.1:8888/，你会看到一个写着</a> “Hello World”的网页</p>
<p>由于我的环境部署在centos系统上，可以直接使用elinks访问，访问结果</p>
<pre><code>[sgsm@iZ2ze53g8gh7cdxahhcv95Z ~]$ elinks  http://127.0.0.1:8080
                                                                                                                  http://127.0.0.1:8080/ 
Hello World     </code></pre>]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>liunx</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>初学nodejs</title>
    <url>/2020/05/28/nodejs1/</url>
    <content><![CDATA[<h2 id="Node-js-概述"><a href="#Node-js-概述" class="headerlink" title="Node.js 概述"></a>Node.js 概述</h2><p>Node.js 是一个能够在服务器端运行 JavaScript 的开放源代码、跨平台 JavaScript 运行环境。Node.js 由 Node.js 基金会持有和维护，并与 Linux 基金会有合作关系。Node.js 采用 Google 开发的 V8 运行代码，使用事件驱动、非阻塞和异步输入输出模型等技术来提高性能，可优化应用程序的传输量和规模。这些技术通常用于数据密集的即时应用程序。</p>
<p>Node.js 大部分基本模块都用 JavaScript 语言编写。在 Node.js 出现之前，JavaScript 通常作为客户端程序设计语言使用，以 JavaScript 写出的程序常在用户的浏览器上运行。Node.js 的出现使 JavaScript 也能用于服务端编程。Node.js 含有一系列内置模块，使得程序可以脱离 Apache HTTP Server 或 IIS，作为独立服务器运行。</p>
<p>注：定义来自维基百科。</p>
<h2 id="Node-js-特点"><a href="#Node-js-特点" class="headerlink" title="Node.js 特点"></a>Node.js 特点</h2><p>  1、它是一个 JavaScript 运行环境。<br>  <br>2、依赖于 Chrome V8 引擎进行代码解释。<br><br>  3、事件驱动：在 Node.js 中，客户端请求建立连接，提交数据等行为，会触发相应的事件。Node.js 在一个时刻，只能执行一个事件回调函数，但是在执行一个事件回调函数的中途，可以转而处理其他事件，然后返回继续执行原事件的回调函数。<br>  <br>4、非阻塞 I/O：Node.js 中采用了非阻塞型 I/O 机制，在执行了访问数据库的代码之后，将立即转而执行其后面的代码，把数据库返回结果的处理代码放在回调函数中，从而提高了程序的执行效率。<br><br>  5、轻量可伸缩，适用于实时数据交互应用。<br>  <br>6、单线程：好处是减少内存开销，不用像多线程编程那样处处在意状态同步的问题。缺点是错误会引起整个应用的退出。<br></p>
<h2 id="Node-js-适用场景"><a href="#Node-js-适用场景" class="headerlink" title="Node.js 适用场景"></a>Node.js 适用场景</h2><p>我们从 Node.js 的特点中可以知道 Node.js 擅长处理 I/O，不善于计算（单线程的缺点），因此 Node.js 适用于：当应用程序需要处理大量并发的 I/O，而在向客户端发出响应之前，应用程序内部并不需要进行非常复杂的处理的时候，Node.js 也非常适合与 Web socket 配合，开发长连接的实时交互应用程序。比如：聊天室，博客系统，考试系统等。</p>
<h2 id="NPM介绍"><a href="#NPM介绍" class="headerlink" title="NPM介绍"></a>NPM介绍</h2><p>npm是随同nodejs一起安装的包管理工具</p>
<p>在中断中查看系统nodejs的版本：</p>
<pre><code>node -v</code></pre><p>查看系统中npm版本</p>
<pre><code>npm  -v</code></pre><h2 id="启动node终端"><a href="#启动node终端" class="headerlink" title="启动node终端"></a>启动node终端</h2><p><br>类似于python的终端，启动node终端直接输入node</p>
<pre><code>node</code></pre><p>基础的计算</p>
<pre><code>&gt; 1 + 1
2
&gt; 2 * 2
4
&gt; 6 / 2
3
&gt; 2+(8*3)-10
16
&gt; </code></pre><p>多行表达式</p>
<pre><code>&gt; for(var i=0; i &lt; 8 ; i++){
... console.log(i);
... }
0
1
2
3
4
5
6
7
undefined
&gt; </code></pre><p>三个点的符号是系统自动生成的，回车换行后即可。Node.js 会自动检测是否为连续的表达式。</p>
<p>下划线变量 – 可以使用下划线（_）获取上一个表达式的运算结果：</p>
<pre><code>&gt; var a = 10 ; var b = 20 ; a + b;
30
&gt; var num = _;
undefined
&gt; console.log(num)
30
undefined
&gt; </code></pre><p>REPL 常用命令</p>
<pre><code>Ctrl + C - 退出当前终端。
Ctrl + C - 连续按两次退出 Node REPL。
Ctrl + D - 退出 Node REPL。
向上/向下键 - 查看输入的历史命令</code></pre><p>运行 JavaScript 文件</p>
<p>新建两个 JavaScript 文件名为为 test.j写下如下代码：</p>
<p>test.js 中的代码：</p>
<pre><code>console.log(&quot;hello world&quot;);</code></pre><p>运行结果</p>
<pre><code>[sgsm@localhost nodejs]$ node  test.js 
hello world</code></pre><h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><p>按照 ECMAScript 的定义，满足以下条件的变量是全局变量：</p>
<pre><code>在最外层定义的变量。
全局对象的属性。
隐式定义的变量（未定义直接赋值的变量）。</code></pre><p>注：当你定义一个全局变量的时候，这个变量同时也会成为全局对象的属性，反之亦然。在 Node.js 中你不可能在最外层定义变量，因为所有用户代码都是属于当前模块的，而模块本身不是最外层上下文。定义变量一定要使用 var 关键字，因为全局变量会污染命名空间。</p>
<p>下面介绍一些常用的全局变量和全局函数：</p>
<p>  __filename 表示当前正在执行的脚本的文件名。它将输出文件所在位置的绝对路径，且和命令行参数所指定的文件名不一定相同。如果在模块中，返回的值是模块文件的路径。比如创建一个叫 fnTest.js 的文件，输入以下代码：</p>
<pre><code>console.log(__filename);</code></pre><p>  运行结果</p>
<pre><code>[sgsm@bogon nodejs]$ node fnTest.js
/home/sgsm/nodejs/fnTest.js</code></pre><p>  __dirname 表示当前执行脚本所在的目录。比如创建一个 dnTest.js 的文件，输入以下代码：</p>
<pre><code>console.log(__dirname);</code></pre><p>  运行结果</p>
<pre><code>[sgsm@bogon nodejs]$ node dnTest.js 
/home/sgsm/nodejs</code></pre><p>  setTimeout(cb, ms) 全局函数在指定的毫秒（ms）数后执行指定函数（cb），只执行一次函数。比如创建一个 st.js 的文件，输入以下代码：</p>
<pre><code>function foo() {
  console.log(&quot;Hello, syl!&quot;);
}
// 三秒后执行以上函数
setTimeout(foo, 3000);</code></pre><p>  运行结果</p>
<pre><code>[sgsm@bogon nodejs]$ node  st.js 
Hello, syl!
[sgsm@bogon nodejs]$</code></pre><p>  clearTimeout(t) 用于停止一个之前通过 setTimeout() 创建的定时器。参数 t 是通过 setTimeout() 函数创建的定时器。比如清除上面案例的定时器：</p>
<pre><code>function foo() {
  console.log(&quot;Hello, syl!&quot;);
}
// 三秒后执行以上函数
var t = setTimeout(foo, 3000);
// 清除定时器
clearTimeout(t);</code></pre><p>  运行结果</p>
<pre><code>[sgsm@bogon nodejs]$ node  st.js 
[sgsm@bogon nodejs]$ </code></pre><p>  setInterval(cb, ms) 与 setTimeout(cb, ms) 类似，不同的是这个方法会不停的执行函数。直到 clearInterval() 被调用或窗口被关闭，也可以按 Ctrl + C 停止。比如创建一个 sI.js 的文件，输入以下代码：</p>
<pre><code>function foo() {
  console.log(&quot;Hello, syl!&quot;);
}
// 三秒后执行以上函数
var t = setInterval(foo, 3000);
// 清除定时器
clearInterval(t);</code></pre><p>  运行结果</p>
<pre><code>[sgsm@bogon nodejs]$ node  st.js 
[sgsm@bogon nodejs]$ </code></pre><p>  如果不加clearInterval的运行结果</p>
<pre><code>[sgsm@iZ2ze53g8gh7cdxahhcv95Z nodejs]$ node st.js 
Hello, syl!
Hello, syl!
Hello, syl!</code></pre><p>  console.log() 是个全局函数用于进行标准输出流的输出，即在控制台中显示一行字符串，和 JavaScript 中的使用一样</p>
]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>liunx</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>centos7设置python3环境</title>
    <url>/2020/05/26/python3huanjing/</url>
    <content><![CDATA[<h2 id="配置yum源-使用阿里云的镜像"><a href="#配置yum源-使用阿里云的镜像" class="headerlink" title="配置yum源-使用阿里云的镜像"></a>配置yum源-使用阿里云的镜像</h2><pre><code>sudo  wget http://mirrors.aliyun.com/repo/Centos-7.repo
sudo  wget http://mirrors.aliyun.com/repo/epel-7.repo
yum clean  all</code></pre><p>安装依赖工具包</p>
<pre><code>sudo  yum -y install zlib-devel bzip2-devel openssl-devel openssl-static ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel libffi-devel lzma gcc</code></pre><h2 id="下载python3-7安装包"><a href="#下载python3-7安装包" class="headerlink" title="下载python3.7安装包"></a>下载python3.7安装包</h2><pre><code>cd /opt/
sudo   wget https://www.python.org/ftp/python/3.7.0/Python-3.7.0.tar.xz</code></pre><p>解压–&gt;配置–&gt;编译–&gt;安装</p>
<pre><code>sudo tar xf  Python-3.7.0.tar.xz    -C /usr/local/
cd  /usr/local/Python-3.7.0/
sudo  ./configure --prefix=/usr/local/sbin/python-3.7
sudo   make &amp;&amp; sudo  make install</code></pre><p>  安装成功会打印</p>
<pre><code>Collecting setuptools
Collecting pip
Installing collected packages: setuptools, pip
Successfully installed pip-10.0.1 setuptools-39.0.1</code></pre><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><pre><code>[sgsm@bogon Python-3.7.0]$ /usr/local/sbin/python-3.7/bin/python3
Python 3.7.0 (default, Jun  3 2020, 23:49:44) 
[GCC 4.8.5 20150623 (Red Hat 4.8.5-39)] on linux
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt; exit()</code></pre><h2 id="创建软连接"><a href="#创建软连接" class="headerlink" title="创建软连接"></a>创建软连接</h2><p><br>查看目前的链接文件<br></p>
<pre><code>[sgsm@bogon Python-3.7.0]$ ll /usr/bin/ |grep python
lrwxrwxrwx.   1 root root           7 4月  13 2017 python -&gt; python2
lrwxrwxrwx.   1 root root           9 4月  13 2017 python2 -&gt; python2.7
-rwxr-xr-x.   1 root root        7136 11月  6 2016 python2.7
-rwxr-xr-x.   1 root root        1835 11月  6 2016 python2.7-config
lrwxrwxrwx.   1 root root          16 4月  13 2017 python2-config -&gt; python2.7-config
lrwxrwxrwx.   1 root root          14 4月  13 2017 python-config -&gt; python2-config</code></pre><p>删除原来的连接文件</p>
<pre><code>sudo rm -rf /usr/bin/python</code></pre><p>创建新的连接文件</p>
<pre><code>sudo  ln -s /usr/local/sbin/python-3.7/bin/python3   /usr/bin/python</code></pre><p>查看现在的版本</p>
<pre><code>[sgsm@bogon Python-3.7.0]$ python -V
Python 3.7.0</code></pre><h2 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h2><p><br>修改完python默认版本之后，会存不能执行yum命令，需要做一些修改，如下<br></p>
<pre><code> 将/usr/bin/yum的顶部的：

!/usr/bin/python  改成  !/usr/bin/python2.7 

将/usr/libexec/urlgrabber-ext-down的顶部的：

/usr/bin/python  改为   /usr/bin/python2.7

将/usr/bin/yum-config-manager的顶部的

#!/usr/bin/python 改为 #!/usr/bin/python2.7 </code></pre><p>最后将pip指向到python3.7</p>
<pre><code>[sgsm@bogon Python-3.7.0]$ sudo ln -s /usr/local/sbin/python-3.7/bin/pip3 /usr/bin/pip 
[sgsm@bogon Python-3.7.0]$ 
[sgsm@bogon Python-3.7.0]$ pip -v
pip 10.0.1 from /usr/local/sbin/python-3.7/lib/python3.7/site-packages/pip (python 3.7)</code></pre>]]></content>
      <categories>
        <category>运维</category>
        <category>开发</category>
      </categories>
      <tags>
        <tag>liunx</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>centos下清除记录的svn用户名和密码</title>
    <url>/2020/05/26/svn-remove-passwd/</url>
    <content><![CDATA[<h2 id="centos下清除记录的svn用户名和密码"><a href="#centos下清除记录的svn用户名和密码" class="headerlink" title="centos下清除记录的svn用户名和密码"></a>centos下清除记录的svn用户名和密码</h2><p><br>由于公司人员的变动，离职人员的svn账号也会被删除，使用之前账号检出的代码执行svn update的时候会显示报错<br></p>
<pre><code>svn: E210005: Unable to connect to a repository at URL &apos;svn://xxx&apos;
svn: E210005: No repository found in &apos;svn://xxx&apos;</code></pre><p>是因为检出代码的是提示是否保存明文密码然后用户选择的yes</p>
<p><br>解决办法<br><br>linux下删除~/.subversion/auth即可清除之前的用户名和密码：</p>
<pre><code>rm -rf ~/.subversion/auth</code></pre><p>以后再操作svn会提示你输入root密码以及svn用户名和密码，这样就可以输入正常的账号密码了</p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>liunx</tag>
        <tag>subversion</tag>
      </tags>
  </entry>
  <entry>
    <title>python-1</title>
    <url>/2020/05/26/python-1/</url>
    <content><![CDATA[<h2 id="双引号和单引号的作用"><a href="#双引号和单引号的作用" class="headerlink" title="双引号和单引号的作用"></a>双引号和单引号的作用</h2><pre><code>str = &quot;我是谁&quot;
print(str)
str1 = &apos;我是&quot;谁&quot;&apos;
print(str1)</code></pre>]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>liunx</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>kube-flannel</title>
    <url>/2020/05/24/kube-flannel/</url>
    <content><![CDATA[<pre><code>---
apiVersion: policy/v1beta1
kind: PodSecurityPolicy
metadata:
  name: psp.flannel.unprivileged
  annotations:
    seccomp.security.alpha.kubernetes.io/allowedProfileNames: docker/default
    seccomp.security.alpha.kubernetes.io/defaultProfileName: docker/default
    apparmor.security.beta.kubernetes.io/allowedProfileNames: runtime/default
    apparmor.security.beta.kubernetes.io/defaultProfileName: runtime/default
spec:
  privileged: false
  volumes:
    - configMap
    - secret
    - emptyDir
    - hostPath
  allowedHostPaths:
    - pathPrefix: &quot;/etc/cni/net.d&quot;
    - pathPrefix: &quot;/etc/kube-flannel&quot;
    - pathPrefix: &quot;/run/flannel&quot;
  readOnlyRootFilesystem: false
  # Users and groups
  runAsUser:
    rule: RunAsAny
  supplementalGroups:
    rule: RunAsAny
  fsGroup:
    rule: RunAsAny
  # Privilege Escalation
  allowPrivilegeEscalation: false
  defaultAllowPrivilegeEscalation: false
  # Capabilities
  allowedCapabilities: [&apos;NET_ADMIN&apos;]
  defaultAddCapabilities: []
  requiredDropCapabilities: []
  # Host namespaces
  hostPID: false
  hostIPC: false
  hostNetwork: true
  hostPorts:
  - min: 0
    max: 65535
  # SELinux
  seLinux:
    # SELinux is unused in CaaSP
    rule: &apos;RunAsAny&apos;
---
kind: ClusterRole
apiVersion: rbac.authorization.k8s.io/v1beta1
metadata:
  name: flannel
rules:
  - apiGroups: [&apos;extensions&apos;]
    resources: [&apos;podsecuritypolicies&apos;]
    verbs: [&apos;use&apos;]
    resourceNames: [&apos;psp.flannel.unprivileged&apos;]
  - apiGroups:
      - &quot;&quot;
    resources:
      - pods
    verbs:
      - get
  - apiGroups:
      - &quot;&quot;
    resources:
      - nodes
    verbs:
      - list
      - watch
  - apiGroups:
      - &quot;&quot;
    resources:
      - nodes/status
    verbs:
      - patch
---
kind: ClusterRoleBinding
apiVersion: rbac.authorization.k8s.io/v1beta1
metadata:
  name: flannel
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: flannel
subjects:
- kind: ServiceAccount
  name: flannel
  namespace: kube-system
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: flannel
  namespace: kube-system
---
kind: ConfigMap
apiVersion: v1
metadata:
  name: kube-flannel-cfg
  namespace: kube-system
  labels:
    tier: node
    app: flannel
data:
  cni-conf.json: |
    {
      &quot;name&quot;: &quot;cbr0&quot;,
      &quot;cniVersion&quot;: &quot;0.3.1&quot;,
      &quot;plugins&quot;: [
        {
          &quot;type&quot;: &quot;flannel&quot;,
          &quot;delegate&quot;: {
            &quot;hairpinMode&quot;: true,
            &quot;isDefaultGateway&quot;: true
          }
        },
        {
          &quot;type&quot;: &quot;portmap&quot;,
          &quot;capabilities&quot;: {
            &quot;portMappings&quot;: true
          }
        }
      ]
    }
  net-conf.json: |
    {
      &quot;Network&quot;: &quot;10.244.0.0/16&quot;,
      &quot;Backend&quot;: {
        &quot;Type&quot;: &quot;vxlan&quot;
      }
    }
---
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: kube-flannel-ds-amd64
  namespace: kube-system
  labels:
    tier: node
    app: flannel
spec:
  selector:
    matchLabels:
      app: flannel
  template:
    metadata:
      labels:
        tier: node
        app: flannel
    spec:
      affinity:
        nodeAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
            nodeSelectorTerms:
              - matchExpressions:
                  - key: kubernetes.io/os
                    operator: In
                    values:
                      - linux
                  - key: kubernetes.io/arch
                    operator: In
                    values:
                      - amd64
      hostNetwork: true
      tolerations:
      - operator: Exists
        effect: NoSchedule
      serviceAccountName: flannel
      initContainers:
      - name: install-cni
        image: quay.io/coreos/flannel:v0.12.0-amd64
        command:
        - cp
        args:
        - -f
        - /etc/kube-flannel/cni-conf.json
        - /etc/cni/net.d/10-flannel.conflist
        volumeMounts:
        - name: cni
          mountPath: /etc/cni/net.d
        - name: flannel-cfg
          mountPath: /etc/kube-flannel/
      containers:
      - name: kube-flannel
        image: quay.io/coreos/flannel:v0.12.0-amd64
        command:
        - /opt/bin/flanneld
        args:
        - --ip-masq
        - --kube-subnet-mgr
        resources:
          requests:
            cpu: &quot;100m&quot;
            memory: &quot;50Mi&quot;
          limits:
            cpu: &quot;100m&quot;
            memory: &quot;50Mi&quot;
        securityContext:
          privileged: false
          capabilities:
            add: [&quot;NET_ADMIN&quot;]
        env:
        - name: POD_NAME
          valueFrom:
            fieldRef:
              fieldPath: metadata.name
        - name: POD_NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
        volumeMounts:
        - name: run
          mountPath: /run/flannel
        - name: flannel-cfg
          mountPath: /etc/kube-flannel/
      volumes:
        - name: run
          hostPath:
            path: /run/flannel
        - name: cni
          hostPath:
            path: /etc/cni/net.d
        - name: flannel-cfg
          configMap:
            name: kube-flannel-cfg
---
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: kube-flannel-ds-arm64
  namespace: kube-system
  labels:
    tier: node
    app: flannel
spec:
  selector:
    matchLabels:
      app: flannel
  template:
    metadata:
      labels:
        tier: node
        app: flannel
    spec:
      affinity:
        nodeAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
            nodeSelectorTerms:
              - matchExpressions:
                  - key: kubernetes.io/os
                    operator: In
                    values:
                      - linux
                  - key: kubernetes.io/arch
                    operator: In
                    values:
                      - arm64
      hostNetwork: true
      tolerations:
      - operator: Exists
        effect: NoSchedule
      serviceAccountName: flannel
      initContainers:
      - name: install-cni
        image: quay.io/coreos/flannel:v0.12.0-arm64
        command:
        - cp
        args:
        - -f
        - /etc/kube-flannel/cni-conf.json
        - /etc/cni/net.d/10-flannel.conflist
        volumeMounts:
        - name: cni
          mountPath: /etc/cni/net.d
        - name: flannel-cfg
          mountPath: /etc/kube-flannel/
      containers:
      - name: kube-flannel
        image: quay.io/coreos/flannel:v0.12.0-arm64
        command:
        - /opt/bin/flanneld
        args:
        - --ip-masq
        - --kube-subnet-mgr
        resources:
          requests:
            cpu: &quot;100m&quot;
            memory: &quot;50Mi&quot;
          limits:
            cpu: &quot;100m&quot;
            memory: &quot;50Mi&quot;
        securityContext:
          privileged: false
          capabilities:
            add: [&quot;NET_ADMIN&quot;]
        env:
        - name: POD_NAME
          valueFrom:
            fieldRef:
              fieldPath: metadata.name
        - name: POD_NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
        volumeMounts:
        - name: run
          mountPath: /run/flannel
        - name: flannel-cfg
          mountPath: /etc/kube-flannel/
      volumes:
        - name: run
          hostPath:
            path: /run/flannel
        - name: cni
          hostPath:
            path: /etc/cni/net.d
        - name: flannel-cfg
          configMap:
            name: kube-flannel-cfg
---
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: kube-flannel-ds-arm
  namespace: kube-system
  labels:
    tier: node
    app: flannel
spec:
  selector:
    matchLabels:
      app: flannel
  template:
    metadata:
      labels:
        tier: node
        app: flannel
    spec:
      affinity:
        nodeAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
            nodeSelectorTerms:
              - matchExpressions:
                  - key: kubernetes.io/os
                    operator: In
                    values:
                      - linux
                  - key: kubernetes.io/arch
                    operator: In
                    values:
                      - arm
      hostNetwork: true
      tolerations:
      - operator: Exists
        effect: NoSchedule
      serviceAccountName: flannel
      initContainers:
      - name: install-cni
        image: quay.io/coreos/flannel:v0.12.0-arm
        command:
        - cp
        args:
        - -f
        - /etc/kube-flannel/cni-conf.json
        - /etc/cni/net.d/10-flannel.conflist
        volumeMounts:
        - name: cni
          mountPath: /etc/cni/net.d
        - name: flannel-cfg
          mountPath: /etc/kube-flannel/
      containers:
      - name: kube-flannel
        image: quay.io/coreos/flannel:v0.12.0-arm
        command:
        - /opt/bin/flanneld
        args:
        - --ip-masq
        - --kube-subnet-mgr
        resources:
          requests:
            cpu: &quot;100m&quot;
            memory: &quot;50Mi&quot;
          limits:
            cpu: &quot;100m&quot;
            memory: &quot;50Mi&quot;
        securityContext:
          privileged: false
          capabilities:
            add: [&quot;NET_ADMIN&quot;]
        env:
        - name: POD_NAME
          valueFrom:
            fieldRef:
              fieldPath: metadata.name
        - name: POD_NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
        volumeMounts:
        - name: run
          mountPath: /run/flannel
        - name: flannel-cfg
          mountPath: /etc/kube-flannel/
      volumes:
        - name: run
          hostPath:
            path: /run/flannel
        - name: cni
          hostPath:
            path: /etc/cni/net.d
        - name: flannel-cfg
          configMap:
            name: kube-flannel-cfg
---
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: kube-flannel-ds-ppc64le
  namespace: kube-system
  labels:
    tier: node
    app: flannel
spec:
  selector:
    matchLabels:
      app: flannel
  template:
    metadata:
      labels:
        tier: node
        app: flannel
    spec:
      affinity:
        nodeAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
            nodeSelectorTerms:
              - matchExpressions:
                  - key: kubernetes.io/os
                    operator: In
                    values:
                      - linux
                  - key: kubernetes.io/arch
                    operator: In
                    values:
                      - ppc64le
      hostNetwork: true
      tolerations:
      - operator: Exists
        effect: NoSchedule
      serviceAccountName: flannel
      initContainers:
      - name: install-cni
        image: quay.io/coreos/flannel:v0.12.0-ppc64le
        command:
        - cp
        args:
        - -f
        - /etc/kube-flannel/cni-conf.json
        - /etc/cni/net.d/10-flannel.conflist
        volumeMounts:
        - name: cni
          mountPath: /etc/cni/net.d
        - name: flannel-cfg
          mountPath: /etc/kube-flannel/
      containers:
      - name: kube-flannel
        image: quay.io/coreos/flannel:v0.12.0-ppc64le
        command:
        - /opt/bin/flanneld
        args:
        - --ip-masq
        - --kube-subnet-mgr
        resources:
          requests:
            cpu: &quot;100m&quot;
            memory: &quot;50Mi&quot;
          limits:
            cpu: &quot;100m&quot;
            memory: &quot;50Mi&quot;
        securityContext:
          privileged: false
          capabilities:
            add: [&quot;NET_ADMIN&quot;]
        env:
        - name: POD_NAME
          valueFrom:
            fieldRef:
              fieldPath: metadata.name
        - name: POD_NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
        volumeMounts:
        - name: run
          mountPath: /run/flannel
        - name: flannel-cfg
          mountPath: /etc/kube-flannel/
      volumes:
        - name: run
          hostPath:
            path: /run/flannel
        - name: cni
          hostPath:
            path: /etc/cni/net.d
        - name: flannel-cfg
          configMap:
            name: kube-flannel-cfg
---
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: kube-flannel-ds-s390x
  namespace: kube-system
  labels:
    tier: node
    app: flannel
spec:
  selector:
    matchLabels:
      app: flannel
  template:
    metadata:
      labels:
        tier: node
        app: flannel
    spec:
      affinity:
        nodeAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
            nodeSelectorTerms:
              - matchExpressions:
                  - key: kubernetes.io/os
                    operator: In
                    values:
                      - linux
                  - key: kubernetes.io/arch
                    operator: In
                    values:
                      - s390x
      hostNetwork: true
      tolerations:
      - operator: Exists
        effect: NoSchedule
      serviceAccountName: flannel
      initContainers:
      - name: install-cni
        image: quay.io/coreos/flannel:v0.12.0-s390x
        command:
        - cp
        args:
        - -f
        - /etc/kube-flannel/cni-conf.json
        - /etc/cni/net.d/10-flannel.conflist
        volumeMounts:
        - name: cni
          mountPath: /etc/cni/net.d
        - name: flannel-cfg
          mountPath: /etc/kube-flannel/
      containers:
      - name: kube-flannel
        image: quay.io/coreos/flannel:v0.12.0-s390x
        command:
        - /opt/bin/flanneld
        args:
        - --ip-masq
        - --kube-subnet-mgr
        resources:
          requests:
            cpu: &quot;100m&quot;
            memory: &quot;50Mi&quot;
          limits:
            cpu: &quot;100m&quot;
            memory: &quot;50Mi&quot;
        securityContext:
          privileged: false
          capabilities:
            add: [&quot;NET_ADMIN&quot;]
        env:
        - name: POD_NAME
          valueFrom:
            fieldRef:
              fieldPath: metadata.name
        - name: POD_NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
        volumeMounts:
        - name: run
          mountPath: /run/flannel
        - name: flannel-cfg
          mountPath: /etc/kube-flannel/
      volumes:
        - name: run
          hostPath:
            path: /run/flannel
        - name: cni
          hostPath:
            path: /etc/cni/net.d
        - name: flannel-cfg
          configMap:
            name: kube-flannel-cfg</code></pre>]]></content>
  </entry>
  <entry>
    <title>kubernetes-1.18.2常见报错--持续更新</title>
    <url>/2020/05/24/error/</url>
    <content><![CDATA[<h2 id="初始化时端口已经启动"><a href="#初始化时端口已经启动" class="headerlink" title="初始化时端口已经启动"></a>初始化时端口已经启动</h2><pre><code>[root@k8s-master01 ~]# kubeadm init --config config.yaml

[init] Using Kubernetes version: v1.10.0
[init] Using Authorization modes: [Node RBAC]
[preflight] Running pre-flight checks.
[preflight] Some fatal errors occurred:
        [ERROR Port-6443]: Port 6443 is in use
        [ERROR Port-10250]: Port 10250 is in use
        [ERROR Port-10251]: Port 10251 is in use
        [ERROR Port-10252]: Port 10252 is in use
        [ERROR FileAvailable--etc-kubernetes-manifests-kube-apiserver.yaml]: /etc/kubernetes/manifests/kube-apiserver.yaml already exists
        [ERROR FileAvailable--etc-kubernetes-manifests-kube-controller-manager.yaml]: /etc/kubernetes/manifests/kube-controller-manager.yaml already exists
        [ERROR FileAvailable--etc-kubernetes-manifests-kube-scheduler.yaml]: /etc/kubernetes/manifests/kube-scheduler.yaml already exists
[preflight] If you know what you are doing, you can make a check non-fatal with `--ignore-preflight-errors=...`



解决方案：发现杀死进程都没有用，最终重启一下kubeadm就可以了，如下：

[root@k8s-master01 ~]# kubeadm reset</code></pre><h2 id="无法拉取镜像"><a href="#无法拉取镜像" class="headerlink" title="无法拉取镜像"></a>无法拉取镜像</h2><p>使用kubeadm配置文件，通过在配置文件中指定docker仓库地址，便于内网快速部署。</p>
<p>生成配置文件</p>
<pre><code>kubeadm config print init-defaults ClusterConfiguration &gt;kubeadm.conf</code></pre><p>修改kubeadm.conf</p>
<pre><code>vi kubeadm.conf
修改 imageRepository: k8s.gcr.io
改为 registry.aliyuncs.com/google_containers
imageRepository: registry.aliyuncs.com/google_containers
修改kubernetes版本kubernetesVersion: v1.13.0
改为kubernetesVersion: v1.18.2
kubernetesVersion: v1.18.2</code></pre><p>  再次查看kubeadm config所需的镜像</p>
<pre><code>[root@master01 ~]# kubeadm config images list --config kubeadm.conf
W0524 14:25:08.505708   14715 configset.go:202] WARNING: kubeadm cannot validate component configs for API groups [kubelet.config.k8s.io kubeproxy.config.k8s.io]
registry.aliyuncs.com/google_containers/kube-apiserver:v1.18.2
registry.aliyuncs.com/google_containers/kube-controller-manager:v1.18.2
registry.aliyuncs.com/google_containers/kube-scheduler:v1.18.2
registry.aliyuncs.com/google_containers/kube-proxy:v1.18.2
registry.aliyuncs.com/google_containers/pause:3.2
registry.aliyuncs.com/google_containers/etcd:3.4.3-0
registry.aliyuncs.com/google_containers/coredns:1.6.7</code></pre><p>拉取镜像并初始化</p>
<pre><code>kubeadm config images pull --config kubeadm.conf

kubeadm init --kubernetes-version=1.18.2 --apiserver-advertise-address=192.168.1.100  --image-repository registry.aliyuncs.com/google_containers  --service-cidr=10.10.0.0/16 --pod-network-cidr=10.122.0.0/16  </code></pre><h2 id="初始化报错"><a href="#初始化报错" class="headerlink" title="初始化报错"></a>初始化报错</h2><pre><code>W0523 10:11:56.806416  112153 configset.go:202] WARNING: kubeadm cannot validate component configs for API groups [kubelet.config.k8s.io kubeproxy.config.k8s.io]
[init] Using Kubernetes version: v1.18.3
[preflight] Running pre-flight checks
error execution phase preflight: [preflight] Some fatal errors occurred:
        [ERROR DirAvailable--var-lib-etcd]: /var/lib/etcd is not empty
[preflight] If you know what you are doing, you can make a check non-fatal with `--ignore-preflight-errors=...`</code></pre><p>删除文件</p>
<pre><code>rm -rf /var/lib/etcd</code></pre><p>就可以继续初始化了</p>
<h2 id="无法下载flannel网络插件"><a href="#无法下载flannel网络插件" class="headerlink" title="无法下载flannel网络插件"></a>无法下载flannel网络插件</h2><pre><code>[root@master01 ~]# wget https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml
--2020-05-24 14:32:30--  https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml
正在解析主机 raw.githubusercontent.com (raw.githubusercontent.com)... 0.0.0.0, ::
正在连接 raw.githubusercontent.com (raw.githubusercontent.com)|0.0.0.0|:443... 失败：拒绝连接。
正在连接 raw.githubusercontent.com (raw.githubusercontent.com)|::|:443... 失败：拒绝连接。

[root@master01 ~]# kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml
The connection to the server raw.githubusercontent.com was refused - did you specify the right host or port?</code></pre><p>  如果无法访问网站需要手动创建文件    kube-flannel.yaml<br>  <br>由于内容太长保存在下面网站中：<br><br>    <a href="https://xinlong.youare.ink/2020/05/24/kube-flannel/" target="_blank" rel="noopener">https://xinlong.youare.ink/2020/05/24/kube-flannel/</a><br>  <br>然后执行<br></p>
<pre><code>kubectl apply -f kube-flannel.yaml</code></pre><p>  稍等几秒后使用如下命令确认其输出结果中Pod的状态为“Running”，</p>
<pre><code>kubectl get pods -n kube-system -l app=flannel</code></pre><p>  类似如下所示：</p>
<pre><code>NAME READY STATUS RESTARTS AGE

kube-flannel-ds-amd64-wscnz 1/1 Running 0 14m</code></pre><p>  验正master节点已经就绪</p>
<pre><code>kubectl get nodes</code></pre><p>  上述命令应该会得到类似如下输出：</p>
<pre><code>NAME STATUS ROLES AGE VERSION

master01.ilinux.io Ready master 4m9s v1.12.1</code></pre><h2 id="添加node节点报错"><a href="#添加node节点报错" class="headerlink" title="添加node节点报错"></a>添加node节点报错</h2><p>node节点报错<br>    [root@node01 yum.repos.d]# kubectl get node<br>    The connection to the server localhost:8080 was refused - did you specify the right host or port?    </p>
<pre><code>kubeadm join 192.168.1.100:6443 --token 946w2y.xhj1wukp35zu6ppb     --discovery-token-ca-cert-hash sha256:93253b79ac5f2a3f32ee7d76e4d7d75cb2bbcd9190132a931c7ea5d5985521a1         </code></pre><p>在node上执行kubeadm join后 在master服务器查询状态为 NotReady 在node上查询报错为上述日志<br><br>解决办法：<br></p>
<p>在node服务器上执行scp  把master上的admin.conf文件拉取到/etc/kubernetes/admin.conf             </p>
<pre><code>scp root@192.168.1.100:/etc/kubernetes/admin.conf /etc/kubernetes/admin.conf             </code></pre><p>设置环境变量</p>
<pre><code>export KUBECONFIG=/etc/kubernetes/admin.conf </code></pre><p>再次执行 kubectl get node </p>
<pre><code>[root@node01 yum.repos.d]# kubectl get node 
NAME       STATUS   ROLES    AGE     VERSION
master01   Ready    master   7h58m   v1.18.3
master02   Ready    &lt;none&gt;   14m     v1.18.3</code></pre><p>master执行 kubectl get node </p>
<pre><code>[root@master01 ~]# kubectl get nodes
NAME       STATUS   ROLES    AGE     VERSION
master01   Ready    master   7h58m   v1.18.3
master02   Ready    &lt;none&gt;   14m     v1.18.3</code></pre>]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>liunx</tag>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>使用kubeadm安装kubernetes</title>
    <url>/2020/05/22/kubeadm/</url>
    <content><![CDATA[<p>Kubernetes技术已经成为了原生云技术的事实标准，它是目前基础软件领域最为热门的分布式调度和管理平台。于是，Kubernetes也几乎成了时下开发工程师和运维工程师必备的技能之一。</p>
<h2 id="一、主机环境预设"><a href="#一、主机环境预设" class="headerlink" title="一、主机环境预设"></a>一、主机环境预设</h2><p>1、测试环境说明</p>
<p>  测试使用的Kubernetes集群可由一个master主机及一个以上（建议至少两个）node主机组成，这些主机可以是物理服务器，也可以运行于vmware、virtualbox或kvm等虚拟化平台上的虚拟机，甚至是公有云上的VPS主机。</p>
<p>  本测试环境将由master01、node01和node02三个独立的主机组成，它们分别拥有4核心的CPU及4G的内存资源，操作系统环境均为CentOS 7.5 1804，域名为ilinux.io。此外，需要预设的系统环境如下：</p>
<p>   （1）借助于NTP服务设定各节点时间精确同步；</p>
<p>  （2）通过DNS完成各节点的主机名称解析，测试环境主机数量较少时也可以使用hosts文件进行；</p>
<p>  （3）关闭各节点的iptables或firewalld服务，并确保它们被禁止随系统引导过程启动；</p>
<p>  （4）各节点禁用SELinux；</p>
<p>  （5）各节点禁用所有的Swap设备；</p>
<p>  （6）若要使用ipvs模型的proxy，各节点还需要载入ipvs相关的各模块；</p>
<p>2、设定时钟同步</p>
<p>  若节点可直接访问互联网，直接启动chronyd系统服务，并设定其随系统引导而启动。</p>
<pre><code>systemctl start chronyd.service

systemctl enable chronyd.service</code></pre><p>  不过，建议用户配置使用本地的的时间服务器，在节点数量众多时尤其如此。存在可用的本地时间服务器时，修改节点的/etc/crhony.conf配置文件，并将时间服务器指向相应的主机即可，配置格式如下：</p>
<pre><code>server CHRONY-SERVER-NAME-OR-IP iburst</code></pre><p>  或者使用ntpdate</p>
<pre><code>yum -y install wget vim net-tools ntpdate
ntpdate time.pool.aliyun.com</code></pre><p>3、主机名称解析</p>
<p>  出于简化配置步骤的目的，本测试环境使用hosts文件进行各节点名称解析，文件内容如下所示：</p>
<pre><code>[root@master01 ~]# cat /etc/hosts
127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
::1         localhost localhost.localdomain localhost6 localhost6.localdomain6
192.168.1.100 master01

192.168.1.101 node1

192.168.1.102 node2</code></pre><p>4、关闭iptables或firewalld服务</p>
<p>  在CentOS7上，iptables或firewalld服务通常只会安装并启动一种，在不确认具体启动状态的前提下，这里通过同时关闭并禁用二者即可简单达到设定目标。</p>
<pre><code>systemctl stop firewalld.service

systemctl stop iptables.service

systemctl disable firewalld.service

systemctl disable iptables.service</code></pre><p>5、关闭并禁用SELinux</p>
<p>  若当前启用了SELinux，则需要编辑/etc/sysconfig/selinux文件,禁用SELinux，并临时设置其当前状态为permissive：</p>
<pre><code>sed -i ‘s@^\(SELINUX=\).*@\1disabled@‘  /etc/sysconfig/selinux

setenforce 0</code></pre><p>6、禁用Swap设备</p>
<p>  部署集群时，kubeadm默认会预先检查当前主机是否禁用了Swap设备，并在未禁用时强制终止部署过程。因此，在主机内存资源充裕的条件下，需要禁用所有的Swap设备，否则，就需要在后文的kubeadm init及kubeadm join命令执行时额外使用相关的选项忽略检查错误。</p>
<p>  关闭Swap设备，需要分两步完成。首先是关闭当前已启用的所有Swap设备：</p>
<pre><code>swapoff -a</code></pre><p>  而后编辑/etc/fstab配置文件，注释用于挂载Swap设备的所有行。</p>
<p>7、启用ipvs内核模块</p>
<p>  创建内核模块载入相关的脚本文件/etc/sysconfig/modules/ipvs.modules，设定自动载入的内核模块。文件内容如下：</p>
<pre><code>#!/bin/bash

ipvs_modules_dir=&quot;/usr/lib/modules/$(uname -r)/kernel/net/netfilter/ipvs&quot;

for i in $(ls $ipvs_modules_dir | sed -r ‘s@(.*).ko.xz@\1@‘); do

/sbin/modinfo -F filename $i &amp;&gt; /dev/null

if [ $? -eq 0 ]; then

/sbin/modprobe $i

fi

done</code></pre><p>  修改文件权限，并手动为当前系统加载内核模块：</p>
<pre><code>chmod +x /etc/sysconfig/modules/ipvs.modules

bash /etc/sysconfig/modules/ipvs.modules</code></pre><p>8、master对node节点ssh互信</p>
<pre><code>ssh-keygen
ssh-copy-id node01
ssh-copy-id node02</code></pre><h2 id="二、安装程序包（在各主机上完成如下设定）"><a href="#二、安装程序包（在各主机上完成如下设定）" class="headerlink" title="二、安装程序包（在各主机上完成如下设定）"></a>二、安装程序包（在各主机上完成如下设定）</h2><p>1、生成yum仓库配置</p>
<p>  首先获取docker-ce的配置仓库配置文件：</p>
<pre><code> yum install wget  -y
wget https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo -O /etc/yum.repos.d/docker.repo</code></pre><p>  而后手动生成kubernetes的yum仓库配置文件/etc/yum.repos.d/kubernetes.repo，内容如下：</p>
<pre><code>[kubernetes]
name=Kubernetes
baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/
gpgcheck=1
gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg
enabled=1</code></pre><p>2、安装相关的程序包</p>
<p>  Kubernetes会对经过充分验正的Docker程序版本进行认证，目前认证完成的最高版本是17.03，但docker-ce的最新版本已经高出了几个版本号。管理员可忽略此认证而直接使用最新版本的docker-ce程序，不过，建议根据后面的说明，将安装命令替换为安装17.03版。</p>
<pre><code>yum install docker-ce

yum install kubelet kubeadm kubectl</code></pre><p>  如果要安装目前经过Kubernetes认证的docker-17版本，可以将上面第一条安装命令替换为如下命令：</p>
<pre><code>yum install -y --setopt=obsoletes=0 docker-ce-17.03.2.ce docker-ce-selinux-17.03.2.ce</code></pre><h2 id="三、配置并启动docker服务（在各节点执行）"><a href="#三、配置并启动docker服务（在各节点执行）" class="headerlink" title="三、配置并启动docker服务（在各节点执行）"></a>三、配置并启动docker服务（在各节点执行）</h2><p>安装组件的几种方法：</p>
<p>1、从阿里云镜像仓库拉取镜像</p>
<pre><code>docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/kube-apiserver:v1.13.0      </code></pre><p>  修改镜像tag</p>
<pre><code>docker tag  registry.cn-hangzhou.aliyuncs.com/google_containers/kube-apiserver:v1.13.0  k8s.gcr.io/kube-apiserver:v1.13.0
docker images</code></pre><p>  使用docker pull镜像后  就不用修改代理配置了<br> <br> 批量修改脚本： <br> </p>
<pre><code>#!/bin/bash
KUBE_VERSION=v1.13.0
KUBE_PAUSE_VERSION=3.1
ETCD_VERSION=3.1.12
DNS_VERSION=1.14.8
GCR_URL=k8s.gcr.io
ALIYUN_URL=registry.cn-shenzhen.aliyuncs.com/cookcodeblog
images=(kube-proxy:${KUBE_VERSION}
kube-scheduler:${KUBE_VERSION}
kube-controller-manager:${KUBE_VERSION}
kube-apiserver:${KUBE_VERSION}
pause:${KUBE_PAUSE_VERSION}
etcd:${ETCD_VERSION}
k8s-dns-sidecar:${DNS_VERSION}
k8s-dns-kube-dns:${DNS_VERSION}
k8s-dns-dnsmasq-nanny:${DNS_VERSION})


for imageName in ${images[@]} ; do
  docker pull $ALIYUN_URL/$imageName
  docker tag  $ALIYUN_URL/$imageName $GCR_URL/$imageName
  docker rmi $ALIYUN_URL/$imageName
done

docker images</code></pre><p>2、若要通过默认的k8s.gcr.io镜像仓库获取Kubernetes系统组件的相关镜像，需要配置docker Unit  #File（/usr/lib/systemd/system/docker.service文件）中的Environment变量，为其定义合用的HTTPS_PROXY，格式如下：</p>
<pre><code>Environment=&quot;HTTPS_PROXY=PROTOCOL://HOST:PORT&quot;

Environment=&quot;NO_PROXY=172.20.0.0/16,127.0.0.0/8&quot;</code></pre><p>  如果没有国外的服务器最好还是先使用docker pull下镜像 然后修改</p>
<p>3、生成配置文件</p>
<pre><code>kubeadm config print init-defaults ClusterConfiguration &gt;kubeadm.conf  </code></pre><p>  修改kubeadm.conf</p>
<pre><code>  vi kubeadm.conf
# 修改 imageRepository: k8s.gcr.io
# 改为 registry.aliyuncs.com/google_containers
imageRepository: registry.aliyuncs.com/google_containers
# 修改kubernetes版本kubernetesVersion: v1.13.0
# 改为kubernetesVersion: v1.18.2
kubernetesVersion: v1.18.2</code></pre><p>  查看所以下载的镜像</p>
<pre><code>kubeadm config images list --config kubeadm.conf

  W0524 14:25:08.505708   14715 configset.go:202] WARNING: kubeadm cannot validate component configs for API groups [kubelet.config.k8s.io kubeproxy.config.k8s.io]
  registry.aliyuncs.com/google_containers/kube-apiserver:v1.18.2
  registry.aliyuncs.com/google_containers/kube-controller-manager:v1.18.2
  registry.aliyuncs.com/google_containers/kube-scheduler:v1.18.2
  registry.aliyuncs.com/google_containers/kube-proxy:v1.18.2
  registry.aliyuncs.com/google_containers/pause:3.2
  registry.aliyuncs.com/google_containers/etcd:3.4.3-0
  registry.aliyuncs.com/google_containers/coredns:1.6.7</code></pre><p>  拉取镜像</p>
<pre><code>kubeadm config images pull --config kubeadm.conf</code></pre><p>4、初始化的时候指定镜像库 – 个人推荐这种方式比较简单<br><br>例如：<br></p>
<pre><code>kubeadm init --kubernetes-version=1.18.2 --apiserver-advertise-address=192.168.1.100  --image-repository registry.aliyuncs.com/google_containers  --service-cidr=10.10.0.0/16 --pod-network-cidr=10.122.0.0/16  </code></pre><p>  另外，docker自1.13版起会自动设置iptables的FORWARD默认策略为DROP，这可能会影响Kubernetes集群依赖的报文转发功能，因此，需要在docker服务启动后，重新将FORWARD链的默认策略设备为ACCEPT，方式是修改/usr/lib/systemd/system/docker.service文件，在“ExecStart=/usr/bin/dockerd”一行之后新增一行如下内容：</p>
<pre><code>ExecStartPost=/usr/sbin/iptables -P FORWARD ACCEPT</code></pre><p>  重载完成后即可启动docker服务：</p>
<pre><code>systemctl daemon-reload

systemctl start docker.service</code></pre><p>  而后设定docker和kubelet随系统引导自动启动：</p>
<pre><code>systemctl enable docker kubelet</code></pre><h2 id="四、初始化主节点（在master01上完成如下操作）"><a href="#四、初始化主节点（在master01上完成如下操作）" class="headerlink" title="四、初始化主节点（在master01上完成如下操作）"></a>四、初始化主节点（在master01上完成如下操作）</h2><p>1、初始化init</p>
<pre><code>kubeadm init --kubernetes-version=1.18.2 --apiserver-advertise-address=192.168.1.100  --image-repository registry.aliyuncs.com/google_containers  --service-cidr=10.10.0.0/16 --pod-network-cidr=10.122.0.0/16  </code></pre><p>  master初始化日志</p>
<pre><code>[mark-control-plane] Marking the node master01 as control-plane by adding the taints [node-role.kubernetes.io/master:NoSchedule]
[bootstrap-token] Using token: 946w2y.xhj1wukp35zu6ppb
[bootstrap-token] Configuring bootstrap tokens, cluster-info ConfigMap, RBAC Roles
[bootstrap-token] configured RBAC rules to allow Node Bootstrap tokens to get nodes
[bootstrap-token] configured RBAC rules to allow Node Bootstrap tokens to post CSRs in order for nodes to get long term certificate credentials
[bootstrap-token] configured RBAC rules to allow the csrapprover controller automatically approve CSRs from a Node Bootstrap Token
[bootstrap-token] configured RBAC rules to allow certificate rotation for all node client certificates in the cluster
[bootstrap-token] Creating the &quot;cluster-info&quot; ConfigMap in the &quot;kube-public&quot; namespace
[kubelet-finalize] Updating &quot;/etc/kubernetes/kubelet.conf&quot; to point to a rotatable kubelet client certificate and key
[addons] Applied essential addon: CoreDNS
[addons] Applied essential addon: kube-proxy

Your Kubernetes control-plane has initialized successfully!

To start using your cluster, you need to run the following as a regular user:

  mkdir -p $HOME/.kube
  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
  sudo chown $(id -u):$(id -g) $HOME/.kube/config

You should now deploy a pod network to the cluster.
Run &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at:
  https://kubernetes.io/docs/concepts/cluster-administration/addons/

Then you can join any number of worker nodes by running the following on each as root:

kubeadm join 192.168.1.100:6443 --token 946w2y.xhj1wukp35zu6ppb \
    --discovery-token-ca-cert-hash sha256:93253b79ac5f2a3f32ee7d76e4d7d75cb2bbcd9190132a931c7ea5d5985521a1 </code></pre><p>  上面master初始化的日志需要保留   token值创建node节点的时候需要用到</p>
<p>2、初始化kubectl</p>
<p>  kubectl是kube-apiserver的命令行客户端程序，实现了除系统部署之外的几乎全部的管理操作，是kubernetes管理员使用最多的命令之一。kubectl需经由API server认证及授权后方能执行相应的管理操作，kubeadm部署的集群为其生成了一个具有管理员权限的认证配置文件/etc/kubernetes/admin.conf，它可由kubectl通过默认的“$HOME/.kube/config”的路径进行加载。当然，用户也可在kubectl命令上使用–kubeconfig选项指定一个别的位置。</p>
<p>  下面复制认证为Kubernetes系统管理员的配置文件至目标用户（例如当前用户root）的家目录下：</p>
<pre><code>mkdir -p $HOME/.kube
cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
chown $(id -u):$(id -g) $HOME/.kube/config</code></pre><p>  而后，即可通过kubectl进行客户端命令测试，并借此了解集群组件的当前状态：</p>
<pre><code>kubectl get componentstatus</code></pre><p>一个正常的输出应该类似如下输出结果所示：</p>
<pre><code>NAME STATUS MESSAGE ERROR

controller-manager Healthy ok

scheduler Healthy ok

etcd-0 Healthy {&quot;health&quot;: &quot;true&quot;}</code></pre><p>3、添加flannel网络附件  </p>
<p>  Kubernetes系统上Pod网络的实现依赖于第三方插件进行，这类插件有近数十种之多，较为著名的有flannel、calico、canal和kube-router等，简单易用的实现是为CoreOS提供的flannel项目。下面的命令用于在线部署flannel至Kubernetes系统之上：</p>
<pre><code>kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</code></pre><p>  如果无法访问网站需要手动创建文件    kube-flannel.yaml<br>  <br>由于内容太长保存在下面网站中：<br><br>    <a href="https://xinlong.youare.ink/2020/05/24/kube-flannel/" target="_blank" rel="noopener">https://xinlong.youare.ink/2020/05/24/kube-flannel/</a><br>  <br>然后执行<br></p>
<pre><code>kubectl apply -f kube-flannel.yaml</code></pre><p>  稍等几秒后使用如下命令确认其输出结果中Pod的状态为“Running”，</p>
<pre><code>kubectl get pods -n kube-system -l app=flannel</code></pre><p>  类似如下所示：</p>
<pre><code>NAME READY STATUS RESTARTS AGE

kube-flannel-ds-amd64-wscnz 1/1 Running 0 14m</code></pre><p>4、验正master节点已经就绪</p>
<pre><code>kubectl get nodes</code></pre><p>  上述命令应该会得到类似如下输出：</p>
<pre><code>NAME STATUS ROLES AGE VERSION

master01.ilinux.io Ready master 4m9s v1.12.1</code></pre><h2 id="五、添加节点到集群中（在node01和node02上分别完成如下操作）"><a href="#五、添加节点到集群中（在node01和node02上分别完成如下操作）" class="headerlink" title="五、添加节点到集群中（在node01和node02上分别完成如下操作）"></a>五、添加节点到集群中（在node01和node02上分别完成如下操作）</h2><p>1、忽略Swap相关的预检错误</p>
<p>  若未禁用Swap设备，编辑kubelet的配置文件/etc/sysconfig/kubelet，设置其忽略Swap启用的状态错误，内容如下：</p>
<pre><code>KUBELET_EXTRA_ARGS=&quot;--fail-swap-on=false&quot;</code></pre><p>  提示：若节点禁用了所有的Swap设备，并无须执行此步骤。</p>
<p>2、添加节点</p>
<p> 将节点加入第二步中创建的master的集群中，要使用主节点初始化过程中记录的kubeadm join命令，并且在未禁用Swap设备的情况下，额外附加“–ignore-preflight-errors=Swap”选项；下面的命令来自于前面初始master时运行的kubeadm init命令的输出结果。</p>
<p>   kubeadm join 192.168.1.100:6443 –token 946w2y.xhj1wukp35zu6ppb     –discovery-token-ca-cert-hash sha256:93253b79ac5f2a3f32ee7d76e4d7d75cb2bbcd9190132a931c7ea5d5985521a1     –ignore-preflight-errors=Swap</p>
<p>在node服务器上执行scp  把master上的admin.conf文件拉取到/etc/kubernetes/admin.conf             </p>
<pre><code>scp root@192.168.1.100:/etc/kubernetes/admin.conf /etc/kubernetes/admin.conf             </code></pre><p>设置环境变量</p>
<pre><code>export KUBECONFIG=/etc/kubernetes/admin.conf </code></pre><p>  在每个节点添加完成后，即可通过kubectl验正添加结果。下面的命令及其输出是在node01和node02均添加完成后运行的，其输出结果表明两个Node已经准备就绪。</p>
<pre><code>kubectl get nodes</code></pre><p>  输出：</p>
<pre><code>NAME STATUS ROLES AGE VERSION

master01.magedu.com Ready master 31m v1.12.1

node01.magedu.com Ready &lt;none&gt; 3m8s v1.12.1

node02.magedu.com Ready &lt;none&gt; 2m25s v1.12.1</code></pre><p>  到此为止，一个master，并附带有两个node的kubernetes集群基础设施已经部署完成，用户随后即可测试其核心功能。例如，下面的命令可将myapp以Pod的形式编排运行于集群之上，并通过在集群外部进行访问：</p>
<pre><code>kubectl create deployment myapp --image=ikubernetes/myapp:v1

kubectl create service nodeport myapp --tcp=80:80</code></pre><p>  而后，使用如下命令了解Service对象myapp使用的NodePort，以便于在集群外部进行访问：</p>
<pre><code>kubectl get svc -l app=myapp</code></pre><p>  输出：</p>
<pre><code>NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE

myapp NodePort 10.102.254.75 &lt;none&gt; 80:31257/TCP 2m32s</code></pre><p>myapp是一个web应用，因此，用户可以于集群外部通过“<a href="http://NodeIP:31257”这个URL访问myapp上的应用，例如于集群外通过浏览器访问“http://172.20.0.61:31257”。">http://NodeIP:31257”这个URL访问myapp上的应用，例如于集群外通过浏览器访问“http://172.20.0.61:31257”。</a></p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>liunx</tag>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>史上最全breeze安装k8s文档</title>
    <url>/2020/05/21/breeze/</url>
    <content><![CDATA[<p>在我们的实验环境中准备了四台服务器，配置与角色如下（如果需要增加 Minion/Worker 节点请自行准备即可）：<br><img src="/2020/05/21/breeze/1.png" alt></p>
<h2 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h2><h2 id="一、准备部署主机（deploy-192-168-9-10）"><a href="#一、准备部署主机（deploy-192-168-9-10）" class="headerlink" title="一、准备部署主机（deploy / 192.168.9.10）"></a>一、准备部署主机（deploy / 192.168.9.10）</h2><p>（1）以标准 Minimal 方式安装 CentOS 7.6 (1810) x64 之后(7.4 和 7.5 也支持)，登录 shell 环境，执行以下命令关闭防火墙：<br>setenforce 0</p>
<pre><code>systemctl stop firewalld.service

systemctl stop iptables.service

systemctl disable firewalld.service

systemctl disable iptables.service</code></pre><p>（2）安装 docker-compose 命令</p>
<pre><code>curl -L https://github.com/docker/compose/releases/download/1.21.2/docker-compose-$(uname -s)-$(uname -m) -o /usr/local/bin/docker-compose

chmod +x /usr/local/bin/docker-compose</code></pre><p>（3）安装 docker</p>
<pre><code>yum install docker
systemctl enable docker &amp;&amp; systemctl start docker</code></pre><p>（4）建立部署主机到其它所有服务器的 ssh 免密登录途径<br>    a) 生成秘钥，执行：</p>
<pre><code>    ssh-keygen

b) 针对目标服务器做 ssh 免密登录，依次执行：

    ssh-copy-id 192.168.1.100
    ssh-copy-id 192.168.1.101
    ssh-copy-id 192.168.1.102
    ssh-copy-id 192.168.1.103
    ssh-copy-id 192.168.1.104</code></pre><h2 id="二、获取针对-K8S-某个具体版本的-Breeze-资源文件并启动部署工具，例如此次实验针对刚刚发布的-K8S-v1-13-1"><a href="#二、获取针对-K8S-某个具体版本的-Breeze-资源文件并启动部署工具，例如此次实验针对刚刚发布的-K8S-v1-13-1" class="headerlink" title="二、获取针对 K8S 某个具体版本的 Breeze 资源文件并启动部署工具，例如此次实验针对刚刚发布的 K8S v1.13.1"></a>二、获取针对 K8S 某个具体版本的 Breeze 资源文件并启动部署工具，例如此次实验针对刚刚发布的 K8S v1.13.1</h2><pre><code>curl -L https://raw.githubusercontent.com/wise2c-devops/breeze/v1.13.1/docker-compose.yml -o docker-compose.yml</code></pre><p>  如果无法访问此网站，复制一下内容到文件中命名为   docker-compose.yml</p>
<pre><code>vim   docker-compose.yml

  version: &apos;2&apos;
  services:
    deploy:
      container_name: deploy-main
      image: registry.cn-shenzhen.aliyuncs.com/breeze-project/pagoda:v1.2.0
      restart: always
      entrypoint: sh
      command:
      - -c
      - &quot;/root/pagoda -logtostderr -v 4 -w /workspace&quot;
      ports:
      - 88:80
      - 8088:8080
      volumes:
      - $HOME/.ssh:/root/.ssh
      - $PWD/deploy:/deploy
      volumes_from:
      - playbook
    ui:
      container_name: deploy-ui
      image: registry.cn-shenzhen.aliyuncs.com/breeze-project/deploy-ui:v1.8
      restart: always
      network_mode: &quot;service:deploy&quot;
    playbook:
      container_name: deploy-playbook
      image: registry.cn-shenzhen.aliyuncs.com/breeze-project/playbook:v1.18.2
      volumes:
      - playbook:/workspace
    yum-repo:
      container_name: deploy-yumrepo
      image: registry.cn-shenzhen.aliyuncs.com/breeze-project/yum-repo:v1.18.2
      ports:
      - 2009:2009 
      restart: always
  volumes:
    playbook:
      external: false</code></pre><h2 id="三、访问部署工具的浏览器页面-部署机-IP-及端口-88-，开始部署工作"><a href="#三、访问部署工具的浏览器页面-部署机-IP-及端口-88-，开始部署工作" class="headerlink" title="三、访问部署工具的浏览器页面(部署机 IP 及端口 88)，开始部署工作"></a>三、访问部署工具的浏览器页面(部署机 IP 及端口 88)，开始部署工作</h2><p>  <a href="http://192.168.1.199:88" target="_blank" rel="noopener">http://192.168.1.199:88</a></p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>liunx</tag>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>ssl证书申请</title>
    <url>/2020/05/21/ssl/</url>
    <content><![CDATA[<h2 id="SSL证书申请"><a href="#SSL证书申请" class="headerlink" title="SSL证书申请"></a>SSL证书申请</h2><p><br>1、 购买证书 （免费版一年）<br><br>2、证书申请   –&gt; 绑定域名    子域名随便起   例如     qwer.effc.ltd    qwer任意<br><br>3、在此域名解析看到有一条TXT记录值，然后返回证书申请点击认证  然后提交<br></p>
<p>认证通过后直接下载证书   （nginx证书   会有.key    .pem  两个秘钥文件）</p>
]]></content>
      <categories>
        <category>阿里云</category>
      </categories>
      <tags>
        <tag>liunx</tag>
        <tag>阿里云</tag>
      </tags>
  </entry>
  <entry>
    <title>pm2安装报错</title>
    <url>/2020/05/20/pm2/</url>
    <content><![CDATA[<h2 id="使用npm安装pm2报错"><a href="#使用npm安装pm2报错" class="headerlink" title="使用npm安装pm2报错"></a>使用npm安装pm2报错</h2><pre><code>sudo  npm  -g  install   pm2  </code></pre><p>报错日志</p>
<pre><code>gyp WARN EACCES user &quot;root&quot; does not have permission to access the dev dir &quot;/root/.node-gyp/4.9.1&quot;
gyp WARN EACCES attempting to reinstall using temporary dev dir &quot;/usr/lib/node_modules/pm2/node_modules/@pm2/agent/node_modules/utf-8-validate/.node-gyp&quot;
make: Entering directory `/usr/lib/node_modules/pm2/node_modules/@pm2/agent/node_modules/utf-8-validate/build&apos;
  CC(target) Release/obj.target/validation/src/validation.o
make: cc: Command not found
make: *** [Release/obj.target/validation/src/validation.o] Error 127
make: Leaving directory `/usr/lib/node_modules/pm2/node_modules/@pm2/agent/node_modules/utf-8-validate/build&apos;
gyp ERR! build error 
gyp ERR! stack Error: `make` failed with exit code: 2
gyp ERR! stack     at ChildProcess.onExit (/usr/lib/node_modules/npm/node_modules/node-gyp/lib/build.js:276:23)
gyp ERR! stack     at emitTwo (events.js:87:13)
gyp ERR! stack     at ChildProcess.emit (events.js:172:7)
gyp ERR! stack     at Process.ChildProcess._handle.onexit (internal/child_process.js:211:12)
gyp ERR! System Linux 3.10.0-957.el7.x86_64
gyp ERR! command &quot;/usr/bin/node&quot; &quot;/usr/lib/node_modules/npm/node_modules/node-gyp/bin/node-gyp.js&quot; &quot;rebuild&quot;
gyp ERR! cwd /usr/lib/node_modules/pm2/node_modules/@pm2/agent/node_modules/utf-8-validate
gyp ERR! node -v v4.9.1
gyp ERR! node-gyp -v v3.4.0
gyp ERR! not ok </code></pre><p>这个意思是因为node版本太低很多依赖库无法使用</p>
<p>更换镜像重试下</p>
<pre><code>sudo  npm install -g pm2 --registry=https://registry.npm.taobao.org  </code></pre><p>使用cnpm安装试下</p>
<pre><code>sudo  npm install -g cnpm --registry=https://registry.npm.taobao.org  
sudo  cnpm install -g  pm2</code></pre><p>还是报错，只有升级node的版本了</p>
<h2 id="node有一个模块叫-n-，是专门用来管理node-js的版本的"><a href="#node有一个模块叫-n-，是专门用来管理node-js的版本的" class="headerlink" title="node有一个模块叫 n ，是专门用来管理node.js的版本的"></a>node有一个模块叫 n ，是专门用来管理node.js的版本的</h2><p><br>第一步：首先安装n模块:<br></p>
<pre><code>sudo  npm install -g n</code></pre><p>第二步：升级node.js到最新稳定版</p>
<pre><code>n stable</code></pre><p>第二步：n后面也可以跟随版本号比如</p>
<pre><code>n v0.10.26
n 0.10.26</code></pre><p>安装管理命令</p>
<pre><code>sudo npm install -g n  

[sgsm@f069vn-thamdinh yum.repos.d]$ sudo n stable

  installing : node-v12.16.3
      mkdir : /usr/local/n/versions/node/12.16.3
      fetch : https://nodejs.org/dist/v12.16.3/node-v12.16.3-linux-x64.tar.xz
  installed : v12.16.3 to /usr/local/bin/node
      active : v4.9.1 at /bin/node</code></pre><p>升级node之后就可以安装pm2了</p>
<pre><code>[sgsm@f069vn-thamdinh yum.repos.d]$ pm2 list             

                        -------------

__/\\\\\\\\\\\\\____/\\\\____________/\\\\____/\\\\\\\\\_____
_\/\\\/////////\\\_\/\\\\\\________/\\\\\\__/\\\///////\\\___
  _\/\\\_______\/\\\_\/\\\//\\\____/\\\//\\\_\///______\//\\\__
  _\/\\\\\\\\\\\\\/__\/\\\\///\\\/\\\/_\/\\\___________/\\\/___
    _\/\\\/////////____\/\\\__\///\\\/___\/\\\________/\\\//_____
    _\/\\\_____________\/\\\____\///_____\/\\\_____/\\\//________
      _\/\\\_____________\/\\\_____________\/\\\___/\\\/___________
      _\/\\\_____________\/\\\_____________\/\\\__/\\\\\\\\\\\\\\\_
        _\///______________\///______________\///__\///////////////__


                          Runtime Edition

        PM2 is a Production Process Manager for Node.js applications
                    with a built-in Load Balancer.

                Start and Daemonize any application:
                $ pm2 start app.js

                Load Balance 4 instances of api.js:
                $ pm2 start api.js -i 4

                Monitor in production:
                $ pm2 monitor

                Make pm2 auto-boot at server restart:
                $ pm2 startup

                To go further checkout:
                http://pm2.io/


                        -------------

[PM2] Spawning PM2 daemon with pm2_home=/home/sgsm/.pm2
[PM2] PM2 Successfully daemonized
┌─────┬───────────┬─────────────┬─────────┬─────────┬──────────┬────────┬──────┬───────────┬──────────┬──────────┬──────────┬──────────┐
│ id  │ name      │ namespace   │ version │ mode    │ pid      │ uptime │ ↺    │ status    │ cpu      │ mem      │ user     │ watching │
└─────┴───────────┴─────────────┴─────────┴─────────┴──────────┴────────┴──────┴───────────┴──────────┴──────────┴──────────┴──────────┘</code></pre><p>其实到这里就出现了很大的问题了，首先应该需要确定下代码是否支持node的高版本，所以更改node版本后其他进程就会有问题<br><br>(还好是测试服，如果正式服我估计现在已经没办法写这个文档了)<br></p>
<p>最后只能还原node版本</p>
<pre><code>sudo n   v4.4.4</code></pre><h2 id="然后把进程启动，关于安装pm2只能使用下面的办法了"><a href="#然后把进程启动，关于安装pm2只能使用下面的办法了" class="headerlink" title="然后把进程启动，关于安装pm2只能使用下面的办法了"></a>然后把进程启动，关于安装pm2只能使用下面的办法了</h2><p><br>找一个同版本node并且已经安装pm2的机器<br></p>
<pre><code>[sgsm@f069vn-thamdinh ~]$ rpm -ql  nodejs  |head  -30
/usr/bin/node
/usr/bin/npm
/usr/lib/node_modules
/usr/lib/node_modules/npm
/usr/lib/node_modules/npm/.mailmap
/usr/lib/node_modules/npm/.npmignore
/usr/lib/node_modules/npm/.travis.yml
/usr/lib/node_modules/npm/AUTHORS
/usr/lib/node_modules/npm/CHANGELOG.md
/usr/lib/node_modules/npm/CONTRIBUTING.md
/usr/lib/node_modules/npm/LICENSE
/usr/lib/node_modules/npm/Makefile</code></pre><p>查看到nodejs模板文件的安装位置然后进入目录</p>
<pre><code>cd /usr/lib/node_modules/</code></pre><p>ls会查看到有一个pm2的目录</p>
<pre><code>[sgsm@localhost node_modules]$ ll
总用量 4
drwxr-xr-x 9 root   root  4096 12月 12 2018 npm
drwxr-xr-x 5 nobody users  320 5月   6 2019 pm2
drwxr-xr-x 8 nobody root   267 12月 12 2018 pomelo</code></pre><p>直接使用tar打包</p>
<pre><code>tar czf  pm2.tar.gz  pm2/</code></pre><p>最后传到需要安装pm2的机器</p>
<p>然后去相同的目录解压</p>
<pre><code>sudo  tar  xf  pm2.tar.gz </code></pre><p>设置环境变量</p>
<pre><code>sudo vim /etc/profile
    export PM2_HOME=/usr/lib/node_modules/pm2
    export PATH=$PM2_HOME/bin:$PATH</code></pre><p>生效环境变量</p>
<pre><code>source  /etc/profile</code></pre><p>由于pm2这个命令在pm2/bin/下面 所以设置个软连接 方便使用</p>
<pre><code>sudo ln -s /usr/lib/node_modules/pm2/bin/pm2 /usr/bin/pm2</code></pre><p>执行试下是否报错 </p>
<pre><code>pm2 list </code></pre><p>我这里是遇到了权限的问题给下用户权限就可以了</p>
<pre><code>sudo chown  sgsm.sgsm   pm2 -R</code></pre><p>至此pm2 成功安装</p>
<p>最后最后最后最后最后最后  经过神秘大佬的指点</p>
<pre><code>sudo  npm -g install  pm2@版本号</code></pre><p>可以安装指定的低版本pm2</p>
<p>写完这篇文档就GG</p>
<p>等下 还有几个npm的常用命令分享</p>
<pre><code>npm -v #显示版本，检查npm 是否正确安装。

npm install express #安装express模块

npm install -g express #全局安装express模块

npm list #列出已安装模块

npm show express #显示模块详情

npm update #升级当前目录下的项目的所有模块

npm update express #升级当前目录下的项目的指定模块

npm update -g express #升级全局安装的express模块

npm uninstall express #删除指定的模块</code></pre>]]></content>
      <categories>
        <category>运维</category>
        <category>开发</category>
      </categories>
      <tags>
        <tag>liunx</tag>
        <tag>pm2</tag>
      </tags>
  </entry>
  <entry>
    <title>一个奇怪的报错</title>
    <url>/2020/05/19/strange/</url>
    <content><![CDATA[<p>前因：因为程序需要node的启动进行需要改到80端口，改过之后却报错</p>
<pre><code>Error: listen EACCES 0.0.0.0:80</code></pre><p>过程：这个报错是端口冲突，然后就排查服务器是否某个进程把80端口占用</p>
<pre><code>sudo netstat -ntpla  |grep  80</code></pre><p>结果什么都没有</p>
<pre><code>sudo  lsof -i:80</code></pre><p>也没有查到这个端口，百度各种搜资料也是无望马上要爆炸的时候一位神秘的大佬给了一个网站</p>
<p><img src="/2020/05/19/strange/1.png" alt><br>看到后就崩溃了</p>
<pre><code>翻译：如果 需要在80端口上运行服务，则需要使用反向代理（如nginx），它将使用首选端口上的系统账户运行，并将请求代理到运行在未观端口（&gt;1024）</code></pre><p>结语：官方文档看到不够多</p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>liunx</tag>
      </tags>
  </entry>
  <entry>
    <title>mvn环境配置</title>
    <url>/2020/05/18/mvn/</url>
    <content><![CDATA[<h2 id="配置jdk环境变量"><a href="#配置jdk环境变量" class="headerlink" title="配置jdk环境变量"></a>配置jdk环境变量</h2><p>创建目录</p>
<pre><code>mkdir /application/ </code></pre><p>解压jdk包到创建的目录中</p>
<pre><code>tar xf jdk-8u60-linux-x64.tar.gz   -C /application/</code></pre><p>做软连接</p>
<pre><code>ln -s  /application/jdk1.8.0_60/ /application/jdk</code></pre><p>设置环境变量</p>
<pre><code>sed -i.ori &apos;$a export  JAVA_HOME=/application/jdk\nexport PATH=$JAVA_HOME/bin:$JAVA_HOME/jre/bin:$PATH\nexport  CLASSPATH=.$CLASSPATH:$JAVA_HOME/lib:$JAVA_HOME/jre/lib:$JAVA_HOME/lib/tools.jar&apos;  /etc/profile</code></pre><p>source一下生效环境变量</p>
<h2 id="配置mvn环境变量"><a href="#配置mvn环境变量" class="headerlink" title="配置mvn环境变量"></a>配置mvn环境变量</h2><pre><code>cd /application/ </code></pre><p>下载mvn包</p>
<pre><code>wget http://mirrors.hust.edu.cn/apache/maven/maven-3/3.5.4/binaries/apache-maven-3.5.4-bin.tar.gz</code></pre><p>解压</p>
<pre><code>tar -zxvf apache-maven-3.5.4-bin.tar.gz</code></pre><p>vim /etc/profile</p>
<pre><code>export MAVEN_HOME=/application/apache-maven-3.0.5
export PATH=$PATH:$MAVEN_HOME/bin</code></pre><p>source一下生效环境变量</p>
<p>最后可以使用mvn -v 查看</p>
<pre><code>[sgsm@localhost weblog]$ mvn  -v
Apache Maven 3.5.4 (1edded0938998edf8bf061f1ceb3cfdeccf443fe; 2018-06-18T02:33:14+08:00)
Maven home: /home/sgsm/test3/apache-maven-3.5.4
Java version: 1.8.0_60, vendor: Oracle Corporation, runtime: /application/jdk1.8.0_60/jre
Default locale: zh_CN, platform encoding: UTF-8
OS name: &quot;linux&quot;, version: &quot;3.10.0-514.21.2.el7.x86_64&quot;, arch: &quot;amd64&quot;, family: &quot;unix&quot;</code></pre><p>接下来就可以使用mvn打jar包了</p>
<pre><code>mvn clean package </code></pre>]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>liunx</tag>
        <tag>mvn</tag>
      </tags>
  </entry>
  <entry>
    <title>Git无法添加主题文件夹</title>
    <url>/2020/05/17/gitremove/</url>
    <content><![CDATA[<p>由于主题都是在git上下载的所以默认会有一个.git的文件，这样导致提交的时候无法提交主题文件<br><br>解决办法<br></p>
<p>删除主题文件夹下.git</p>
<pre><code>git rm --cached themes/hexo-theme-ayer
git add .
git commit -m &quot;xxx&quot;
git push origin master</code></pre>]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>liunx</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>大于2T的硬盘需要parted磁盘分区</title>
    <url>/2020/05/16/parted/</url>
    <content><![CDATA[<h2 id="首先安装parted"><a href="#首先安装parted" class="headerlink" title="首先安装parted"></a>首先安装parted</h2><pre><code>yum install parted   -y</code></pre><p>查看硬盘情况使用fdisk -l 查看分区情况，对于大于2TB的硬盘用parted分区<br><br>格式化 /dev/sdb<br></p>
<pre><code>parted /dev/sdb</code></pre><p>使用print打印分区信息</p>
<pre><code>(parted) print</code></pre><p>将分区设置成gpt格式</p>
<pre><code>mklabel gpt    </code></pre><p>将所有空间创建一个分区</p>
<pre><code>mkpart primary 0 100%</code></pre><p>退出</p>
<pre><code>quit</code></pre><h2 id="将硬盘分为两个主分区"><a href="#将硬盘分为两个主分区" class="headerlink" title="将硬盘分为两个主分区"></a>将硬盘分为两个主分区</h2><pre><code>[root@localhost ~]# parted /dev/sdb   
GNU Parted 1.8.1 Using /dev/sdb Welcome to GNU Parted! Type ‘help’ to view a list of commands.
(parted) mklabel gpt           # 将MBR磁盘格式化为GPT
(parted) print                       #打印当前分区
(parted) mkpart primary 0 4.5TB                # 分一个4.5T的主分区
(parted) mkpart primary 4.5TB 12TB      # 分一个7.5T的主分区
(parted) print                         #打印当前分区
(parted) quit 退出</code></pre>]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>liunx</tag>
        <tag>parted</tag>
      </tags>
  </entry>
  <entry>
    <title>centos安装samba文件共享--隐藏目录</title>
    <url>/2020/05/14/samba/</url>
    <content><![CDATA[<h2 id="配置环境–关闭防火墙和selinux"><a href="#配置环境–关闭防火墙和selinux" class="headerlink" title="配置环境–关闭防火墙和selinux"></a>配置环境–关闭防火墙和selinux</h2><p><br>centos6<br></p>
<pre><code>service  iptables  stop
service  ip6tables  stop</code></pre><p>centos7</p>
<pre><code>systemctl stop  firewalld</code></pre><p>永久关闭</p>
<pre><code>chkconfig  iptables  off   
chkconfig  ip6tables  off   </code></pre><p>临时关闭selinux</p>
<pre><code>setenforce 0</code></pre><p>永久关闭selinux</p>
<pre><code>vim  /etc/selinux/config
    SELINUX=disabled</code></pre><p>重启生效</p>
<h2 id="安装samba服务"><a href="#安装samba服务" class="headerlink" title="安装samba服务"></a>安装samba服务</h2><pre><code>yum  install samba  samba-client  samba-common  samba-doc  -y </code></pre><h2 id="配置samba服务"><a href="#配置samba服务" class="headerlink" title="配置samba服务"></a>配置samba服务</h2><pre><code>cp  /etc/samba/smb.conf  /etc/samba/smb.conf_bak
vim /etc/samba/smb.conf
[global]     #定义全局策略
    workgroup = MYGROUP   #定义工作组
    server string = Samba Server Version %v #服务器提示字符，默认显示samba版本
    log file = /var/log/samba/log.%m    #定义日志文件
    max log size = 50      #定义日志文件单个文件最大容量为50KB
    security = user        #security选项将会影响客户端访问方式       #可以设置user、share、server、domain。User代表用户名和密码验证；share代表匿名访问；server代表基于验证身份的访问，账户信息在另一台SMB服务器上；domain:同样基于验证身份验证，账户信息在活动目录中    
    passdb backend = tdbsam    #账户与密码存储方式，smbpasswd使用老的明文格式存储账户及密码；tdbsam代表基于TDB的密文格式存储；ldapsam代表使用LDAP存储账户资料。
    load printers = yes        #客户端在10分钟内没有打开任何Samba资源，服务器将自动关闭回话。
    cups options = raw       #打印属性

    config file = /etc/samba/%U.smb.conf   #指定扩展文件


[dome]       #共享名称为dome
    comment = Common share
    path = /common        #指定共享目录
    valid users = tom jerry    #有效账户列表
    create mask = 0750        #客户端上传文件的默认权限
    directorymask = 0775       #客户端创建目录的默认权限 
    browseable = yes       #客户端是否对所有人可见    
    writable= no          #是否允许写入
    write list = tom       #写权限账户列表
    admin users = tom       #该共享的管理员，具有完全权限
    invalid users = root bin    #禁止root与bin访问common共享
      guest ok = no       #是否允许匿名访问


[server]
    path = /share/samba/server
    directory  mask = 0755
    create mask = 0644
    valid users = yanfa
    browseable = no

[meishu]
    path = /share/samba/meishu
    directory  mask =0755
    create mask =0644
    valid users = meishu
    browseable = no

[yunyingmeishu]
    path = /share/samba/yunyingmeishu
    directory  mask =0755
    create mask =0644
    valid users = yunying
    browseable = no</code></pre><h2 id="创建扩展文件"><a href="#创建扩展文件" class="headerlink" title="创建扩展文件"></a>创建扩展文件</h2><pre><code>cd /etc/samba/

vim   yanfa.smb.conf  
    [share]
    security = user
    path = /share/samba/yanfa
    valid users = @yanfa
    read list = @yanfa
    write list = @yanfa
    writable = yes
    create mask = 0644
    directory mask = 0755 


vim   meishu.smb.conf   
    [meishu]
    security = user
    path = /share/samba/meishu
    valid users = @meishu
    read list = @meishu
    write list = @meishu
    writable = yes
    create mask = 0644
    directory mask = 0755


vim   yunying.smb.conf 
    [yunying]
    security = user
    path = /share/samba/yunyingmeishu
    valid users = @yunying
    read list = @yunying
    write list = @yunying
    writable = yes
    create mask = 0644
    directory mask = 0755</code></pre><h2 id="创建共享文件夹"><a href="#创建共享文件夹" class="headerlink" title="创建共享文件夹"></a>创建共享文件夹</h2><p>  mkdir /share/samba/{yanfa,meishu,yunyingmeishu}    -p</p>
<h2 id="创建登录用户"><a href="#创建登录用户" class="headerlink" title="创建登录用户"></a>创建登录用户</h2><pre><code>useradd  yanfa
useradd  meishu
useradd  yunying</code></pre><h2 id="创建samba用户–需要交互式输入密码，此密码和系统用户密码无关"><a href="#创建samba用户–需要交互式输入密码，此密码和系统用户密码无关" class="headerlink" title="创建samba用户–需要交互式输入密码，此密码和系统用户密码无关"></a>创建samba用户–需要交互式输入密码，此密码和系统用户密码无关</h2><pre><code>pdbedit -a  yanfa
pdbedit -a  meishu
pdbedit -a  yunying</code></pre><p>pdbedit常用参数</p>
<pre><code>pdbedit -L  ：查看samba用户
pdbedit -Lv：列出Samba用户列表详细信息
pdbedit -a  -u  user：添加samba用户
pdbedit -r  -u  user：修改samba用户信息
pdbedit -x  -u  user： 删除samba用户</code></pre><h2 id="共享文件夹更改权限"><a href="#共享文件夹更改权限" class="headerlink" title="共享文件夹更改权限"></a>共享文件夹更改权限</h2><pre><code>cd  /share/samba/
chown  meishu.meishu  meishu/ -R
chown   yunying.yunying  yunyingmeishu/ -R
chown  yanfa.yanfa  yanfa/ -R</code></pre><h2 id="启动服务就可以访问了"><a href="#启动服务就可以访问了" class="headerlink" title="启动服务就可以访问了"></a>启动服务就可以访问了</h2><pre><code>/etc/init.d/smb  start
/etc/init.d/nmb  start</code></pre><h2 id="好礼大放送–wind客户端清理已保存的samba用户和密码"><a href="#好礼大放送–wind客户端清理已保存的samba用户和密码" class="headerlink" title="好礼大放送–wind客户端清理已保存的samba用户和密码"></a>好礼大放送–wind客户端清理已保存的samba用户和密码</h2><pre><code>net  use      # 查看已保存的用户和密码

net use  *  /del   /y     # 清除所有账号密码</code></pre>]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>liunx</tag>
        <tag>samba</tag>
      </tags>
  </entry>
  <entry>
    <title>Mongo常见报错</title>
    <url>/2020/05/14/MongoError/</url>
    <content><![CDATA[<p>mongod宕机常见报错</p>
<pre><code>/data/lib/mongo//WiredTiger.turtle: handle-open: open: Permission denied</code></pre><p>  解决办法直接给权限</p>
<pre><code>sudo chown  mongod.mongod   ./*  -R</code></pre><p>还有一种是非正常关闭mongo再次启动会失败  使用</p>
<pre><code>sudo  journalctl -xe</code></pre><p>查看到报错</p>
<pre><code>Error starting mongod. /var/run/mongodb/mongod.pid exists.</code></pre><p>是因为非正常关闭mongo的时候pid文件还存在，删除后启动就正常了</p>
<p>锁文件报错</p>
<pre><code>2020-06-20T19:55:41.371+0800 W -        [initandlisten] Detected unclean shutdown - /data/lib/mongo/mongod.lock is not empty.</code></pre><p>解决办法</p>
<pre><code>sudo  rm   /data/lib/mongo/mongod.lock</code></pre><p>最大连接数报错</p>
<pre><code>[1592654142:807610][13609:0x7fb0fc34bdc0], file:collection-1898--8679891645894746372.wt, WT_SESSION.open_cursor: /data/lib/mongo//collection-1898--8679891645894746372.wt: handle-open: open: Too many open files
2020-06-20T19:55:42.807+0800 I -        [initandlisten] Invariant failure: ret resulted in status UnknownError: 24: Too many open files at src/mongo/db/storage/wiredtiger/wiredtiger_session_cache.cpp 79</code></pre><p>解决办法</p>
<pre><code>ulimit -n 4096</code></pre><p>查看mongo连接数</p>
<pre><code>db.serverStatus().connections
{ &quot;current&quot; : 80, &quot;available&quot; : 52348, &quot;totalCreated&quot; : NumberLong(367) }</code></pre><p>Current表示当前到实例上正在运行的连接数。<br><br>Available表示当前实例还可以支持的并发连接数。<br></p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>mongo</tag>
        <tag>liunx</tag>
      </tags>
  </entry>
  <entry>
    <title>lamp</title>
    <url>/2020/05/13/lamp/</url>
    <content><![CDATA[<!-- 文章头部设置 -->

<blockquote>
<p>&amp;  表示任务在后台执行，如要在后台运行redis-server,则有  redis-server &amp;<br>&amp;&amp; 表示前一条命令执行成功时，才执行后一条命令 ，如 echo ‘1’ &amp;&amp; echo ‘2’<br>| 表示管道，上一条命令的输出，作为下一条命令参数，如 echo ‘yes’ | wc -l<br>|| 表示上一条命令执行失败后，才执行下一条命令，如 cat nofile || echo “fail”</p>
</blockquote>
<h1 id="安装apache"><a href="#安装apache" class="headerlink" title="安装apache"></a>安装apache</h1><h2 id="下载和安装依赖"><a href="#下载和安装依赖" class="headerlink" title="下载和安装依赖"></a>下载和安装依赖</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install autoconf libtool gcc expat expat-devel make zlib-devel gcc-c++ openssl-devel pcre-devel openssl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入 https://mirror.bit.edu.cn/apache//apr/ 找到最新的 apr 和 apr-util 包即可</span></span><br><span class="line">wget https://mirror.bit.edu.cn/apache//apr/apr-1.7.0.tar.gz</span><br><span class="line">wget https://mirror.bit.edu.cn/apache/httpd/httpd-2.4.43.tar.gz</span><br><span class="line">wget https://mirror.bit.edu.cn/apache//apr/apr-util-1.6.1.tar.gz</span><br></pre></td></tr></table></figure>

<h2 id="编译安装apr"><a href="#编译安装apr" class="headerlink" title="编译安装apr"></a>编译安装apr</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 编辑 configure文件，查找 $RM "$cfgfile" 这个地方，用#注释掉</span></span><br><span class="line">31880行 <span class="comment">#    $RM "$cfgfile"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在configure里面 RM='$RM  -f' 这里的$RM后面一定有一个空格。 如果后面没有空格，直接连接减号，就依然会报错。把 RM='$RM' 改为 RM='$RM -f'</span></span><br><span class="line">31279行     RM=<span class="string">'$RM -f'</span></span><br><span class="line"><span class="comment"># 更改上面两行，否则./configure会报错：rm: cannot remove `libtoolT': No such file or directory</span></span><br><span class="line">./configure --prefix=/home/lamp/apr</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<h2 id="编译安装apr-util"><a href="#编译安装apr-util" class="headerlink" title="编译安装apr-util"></a>编译安装apr-util</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指明apr的安装位置--with-apr=/home/lamp/apr</span></span><br><span class="line">./configure --prefix=/home/lamp/apr-util --with-apr=/home/lamp/apr</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<h2 id="编译安装apache"><a href="#编译安装apache" class="headerlink" title="编译安装apache"></a>编译安装apache</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./configure --prefix=/home/lamp/apache2 --with-apr=/home/lamp/apr --with-apr-util=/home/lamp/apr-util</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<h1 id="启动apache"><a href="#启动apache" class="headerlink" title="启动apache"></a>启动apache</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/lamp/apache2</span><br><span class="line"><span class="comment"># 修改端口为800</span></span><br><span class="line">./bin/httpd -k start</span><br><span class="line">curl localhost:800</span><br><span class="line"><span class="comment"># 显示&lt;html&gt;&lt;body&gt;&lt;h1&gt;It works!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="配置基于域名访问不同资源目录"><a href="#配置基于域名访问不同资源目录" class="headerlink" title="配置基于域名访问不同资源目录"></a>配置基于域名访问不同资源目录</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 编辑httpd.conf，在文件最后加入以下几行：</span></span><br><span class="line"></span><br><span class="line">&lt;/IfModule&gt;</span><br><span class="line">&lt;VirtualHost *:800&gt;</span><br><span class="line">    DocumentRoot <span class="string">"/home/lamp/apache2/htdocs/"</span></span><br><span class="line">    ServerName www.example.com</span><br><span class="line">    <span class="comment"># 访问www.example.com会访问/home/lamp/apache2/htdocs/目录下的资源</span></span><br><span class="line"></span><br><span class="line">&lt;/VirtualHost&gt;</span><br><span class="line"></span><br><span class="line">&lt;VirtualHost *:800&gt;</span><br><span class="line">    DocumentRoot <span class="string">"/home/lamp/apache2/htdocs/org/"</span></span><br><span class="line">    ServerName www.example.org</span><br><span class="line">    <span class="comment"># 访问www.example.org会访问/home/lamp/apache2/htdocs/org/目录下的资源</span></span><br><span class="line"></span><br><span class="line">&lt;/VirtualHost&gt;</span><br></pre></td></tr></table></figure>

<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置hosts文件！！！</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /home/lamp/apache2/</span><br><span class="line">mkdir htdocs/org/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑htdocs/index.html填入www.example.com</span></span><br><span class="line">cat &gt; htdocs/index.html &lt;&lt; EOF</span><br><span class="line">www.example.com</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑htdocs/org/index.html填入www.example.org</span></span><br><span class="line">cat &gt; htdocs/org/index.html &lt;&lt; EOF</span><br><span class="line">www.example.org</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启 访问</span></span><br><span class="line">./bin/httpd -k restart</span><br><span class="line"></span><br><span class="line">[root@www apache2]<span class="comment"># curl www.example.org:800</span></span><br><span class="line">www.example.org</span><br><span class="line">[root@www apache2]<span class="comment"># curl www.example.com:800</span></span><br><span class="line">www.example.com</span><br></pre></td></tr></table></figure>

<h2 id="配置基于端口访问不同资源目录"><a href="#配置基于端口访问不同资源目录" class="headerlink" title="配置基于端口访问不同资源目录"></a>配置基于端口访问不同资源目录</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在上文的基础上增加www.example.com:8000端口，直接在配置文件最下面添加以下内容</span></span><br><span class="line">&lt;VirtualHost *:8000&gt;</span><br><span class="line">    DocumentRoot <span class="string">"/home/lamp/apache2/htdocs/8000/"</span></span><br><span class="line">    ServerName www.example.com</span><br><span class="line">    <span class="comment"># 访问www.example.com:8000会访问/htdocs/8000/目录下的资源</span></span><br><span class="line"></span><br><span class="line">&lt;/VirtualHost&gt;</span><br><span class="line"><span class="comment"># 在监听端口下面增加新的监听端口</span></span><br><span class="line">Listen 800</span><br><span class="line">Listen 8000</span><br></pre></td></tr></table></figure>

<h3 id="验证-1"><a href="#验证-1" class="headerlink" title="验证"></a>验证</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir htdocs/8000</span><br><span class="line"></span><br><span class="line">cat &gt; htdocs/8000/index.html &lt;&lt; EOF</span><br><span class="line">www.example.com:8000</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查</span></span><br><span class="line">./bin/httpd -t   <span class="comment"># 显示Syntax OK即可</span></span><br><span class="line"></span><br><span class="line">./bin/httpd -k restart</span><br><span class="line"></span><br><span class="line">[root@www apache2]<span class="comment"># curl www.example.com:8000</span></span><br><span class="line">www.example.com:8000</span><br><span class="line">[root@www apache2]<span class="comment"># curl www.example.com:800</span></span><br><span class="line">www.example.com</span><br><span class="line">[root@www apache2]<span class="comment"># curl www.example.org:800</span></span><br><span class="line">www.example.org</span><br></pre></td></tr></table></figure>

<h2 id="配置基于虚拟主机访问不同资源目录"><a href="#配置基于虚拟主机访问不同资源目录" class="headerlink" title="配置基于虚拟主机访问不同资源目录"></a>配置基于虚拟主机访问不同资源目录</h2><p>&emsp;&emsp;注释掉上面的3个配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 增加新的配置</span></span><br><span class="line"><span class="comment"># 注意！IP地址是主机自带的IP地址，并非虚拟不存在的。改完配置要修改hosts解析！！！</span></span><br><span class="line">&lt;VirtualHost 192.168.1.100&gt;</span><br><span class="line">    DocumentRoot <span class="string">"/home/lamp/apache2/htdocs/100/"</span></span><br><span class="line">    ServerName www.example.com</span><br><span class="line">    <span class="comment"># 访问www.example.com:800会访问htdocs/100/目录下的资源</span></span><br><span class="line"></span><br><span class="line">&lt;/VirtualHost&gt;</span><br><span class="line"></span><br><span class="line">&lt;VirtualHost 192.168.1.200&gt;</span><br><span class="line">    DocumentRoot <span class="string">"/home/lamp/apache2/htdocs/200/"</span></span><br><span class="line">    ServerName www.example.org</span><br><span class="line">    <span class="comment"># 访问www.example.org:800会访问htdocs/200/目录下的资源</span></span><br><span class="line"></span><br><span class="line">&lt;/VirtualHost&gt;</span><br></pre></td></tr></table></figure>
<h3 id="验证-2"><a href="#验证-2" class="headerlink" title="验证"></a>验证</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./bin/httpd -k restart</span><br><span class="line"></span><br><span class="line">mkdir htdocs/&#123;1,2&#125;00</span><br><span class="line">cat &gt; htdocs/100/index.html &lt;&lt; EOF</span><br><span class="line">www.example.com  100</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">cat &gt; htdocs/200/index.html &lt;&lt; EOF</span><br><span class="line">www.example.org  200</span><br><span class="line">EOF</span><br><span class="line">./bin/httpd -k restart</span><br><span class="line"></span><br><span class="line">[root@www apache2]<span class="comment"># curl www.example.com:800</span></span><br><span class="line">www.example.com  100</span><br><span class="line">[root@www apache2]<span class="comment"># curl www.example.org:800</span></span><br><span class="line">www.example.org  200</span><br></pre></td></tr></table></figure>
<h2 id="配置基于简单的用户密码验证访问"><a href="#配置基于简单的用户密码验证访问" class="headerlink" title="配置基于简单的用户密码验证访问"></a>配置基于简单的用户密码验证访问</h2><p>&emsp;&emsp;注释掉上面的配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;Directory /usr/<span class="built_in">local</span>/apache2/htdocs/wang&gt;</span><br><span class="line">        AuthName <span class="string">"wang Auth"</span></span><br><span class="line">        AuthType basic</span><br><span class="line">        AuthUserFile /usr/<span class="built_in">local</span>/apache2/.htpasswd</span><br><span class="line">        Require user wang</span><br><span class="line">&lt;/Directory&gt;</span><br><span class="line"><span class="comment"># AuthName "wang Auth"   该字符串显示在网页访问时输入用户密码的对话框之上，实际测试并未显示</span></span><br><span class="line"><span class="comment"># AuthType basic         定义验证模块类型</span></span><br><span class="line"><span class="comment"># AuthUserFile /file     密码文件的存放地址</span></span><br><span class="line"><span class="comment"># Require user wang      设置哪些用户生效</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面这些注释也能实现用户密码访问，建议留存以便解决一些未知的bug，如果你是yum安装的httpd，你可以直接修改conf.d/userdir.conf文件，直接在最下面增加上述配置即可。</span></span><br><span class="line">&lt;IfModule mod_userdir.c&gt;</span><br><span class="line">    UserDir public_html</span><br><span class="line">&lt;/IfModule&gt;</span><br><span class="line"></span><br><span class="line">&lt;Directory /home/*/public_html&gt;</span><br><span class="line">    AllowOverride FileInfo AuthConfig Limit</span><br><span class="line">    Options MultiViews Indexes SymLinksIfOwnerMatch IncludesNoExec</span><br><span class="line">    &lt;Limit GET POST OPTIONS&gt;</span><br><span class="line">        Order allow,deny</span><br><span class="line">        Allow from all</span><br><span class="line">    &lt;/Limit&gt;</span><br><span class="line">    &lt;LimitExcept GET POST OPTIONS&gt;</span><br><span class="line">        Order deny,allow</span><br><span class="line">        Deny from all</span><br><span class="line">    &lt;/LimitExcept&gt;</span><br><span class="line">&lt;/Directory&gt;</span><br></pre></td></tr></table></figure>

<h3 id="验证-3"><a href="#验证-3" class="headerlink" title="验证"></a>验证</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./bin/httpd -k restart</span><br><span class="line"><span class="comment"># 创建用户：</span></span><br><span class="line">useradd wang</span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/apache2</span><br><span class="line">mkdir htdocs/wang</span><br><span class="line">cat &gt; htdocs/wang/index.html &lt;&lt; EOF</span><br><span class="line">wang auth</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成密码文件，修改密码再次执行此命令即可</span></span><br><span class="line">./bin/htpasswd -c -m /home/lamp/apache2/.htpasswd wang</span><br><span class="line"><span class="comment"># 输入密码a123456</span></span><br><span class="line"></span><br><span class="line">cat .htpasswd</span><br><span class="line"><span class="comment"># 显示 wang:$apr1$eL9wB7zB$F6bE1abbu1vGDVrW4Ji9V1</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th align="left">选项</th>
<th align="left">注释</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-c</td>
<td align="left">自动创建文件，仅应该在文件不存在时使用(初建时使用-c,再次创建不取消该选项则会覆盖之前内容)</td>
</tr>
<tr>
<td align="left">-m</td>
<td align="left">md5格式加密</td>
</tr>
<tr>
<td align="left">-s</td>
<td align="left">sha格式加密</td>
</tr>
<tr>
<td align="left">-D</td>
<td align="left">删除指定用户</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 访问</span></span><br><span class="line">curl www.example.com:800/wang</span><br><span class="line"><span class="comment"># 报错401</span></span><br><span class="line"><span class="comment"># 下载elinks</span></span><br><span class="line">wget http://rpmfind.net/linux/centos/8.1.1911/PowerTools/x86_64/os/Packages/elinks-0.12-0.58.pre6.el8.x86_64.rpm</span><br><span class="line">rpm -ivh elinks-0.12-0.58.pre6.el8.x86_64.rpm</span><br><span class="line"><span class="comment"># elinks访问</span></span><br><span class="line">elinks http://www.example.com:800/wang</span><br><span class="line"><span class="comment"># 输入用户名密码 &gt;&gt; 点击OK &gt;&gt; 点击here （①可以鼠标操作，②可以通过方向键移动光标，enter确认）</span></span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/13/lamp/lamp/0.jpg" alt><br><img src="/2020/05/13/lamp/lamp/1.jpg" alt><br><img src="/2020/05/13/lamp/lamp/2.jpg" alt></p>
<h3 id="扩展基于组用户密码访问"><a href="#扩展基于组用户密码访问" class="headerlink" title="扩展基于组用户密码访问"></a>扩展基于组用户密码访问</h3><p>&emsp;&emsp;上面的<strong>配置不变</strong>，增加两行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;Directory /usr/<span class="built_in">local</span>/apache2/htdocs/wang&gt;</span><br><span class="line">        AuthName <span class="string">"wang Auth"</span></span><br><span class="line">        AuthType basic</span><br><span class="line">        AuthUserFile /usr/<span class="built_in">local</span>/apache2/.htpasswd</span><br><span class="line">        Require user wang</span><br><span class="line">        AuthGroupFile /usr/<span class="built_in">local</span>/apache2/groupfile   <span class="comment"># 组文件</span></span><br><span class="line">        Require group wang   <span class="comment"># 允许的组</span></span><br><span class="line">&lt;/Directory&gt;</span><br><span class="line"><span class="comment"># 通过上面的配置文件可知，允许wang组里面的用户访问，允许用户wang访问</span></span><br></pre></td></tr></table></figure>

<h4 id="验证-4"><a href="#验证-4" class="headerlink" title="验证"></a>验证</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./bin/httpd -k restart</span><br><span class="line">cat &gt; groupfile &lt;&lt; EOF</span><br><span class="line">wang:<span class="built_in">test</span></span><br><span class="line">test0:test0</span><br><span class="line">EOF</span><br><span class="line"><span class="comment"># :前面是组名，后面是用户名；组名等于http.conf中的Require group wang规定的组名</span></span><br><span class="line"><span class="comment"># 增加用户test，test0</span></span><br><span class="line">./bin/htpasswd -m /home/lamp/apache2/.htpasswd <span class="built_in">test</span></span><br><span class="line">./bin/htpasswd -m /home/lamp/apache2/.htpasswd test0</span><br><span class="line"><span class="comment"># 由配置文件可知，允许test，和wang访问，不允许test0访问</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分别输入wang，test，test0用户密码验证即可</span></span><br><span class="line">elinks http://www.example.com:800/wang</span><br></pre></td></tr></table></figure>

<h1 id="一般遇到的问题"><a href="#一般遇到的问题" class="headerlink" title="一般遇到的问题"></a>一般遇到的问题</h1><ol>
<li>httpd.conf配置文件中，填写的路径不对</li>
<li>多使用./bin/httpd -t检查，可以避免很多的粗心错误</li>
<li>修改完配置文件一定记得重启，./bin/httpd -k restart</li>
<li>端口，资源目录，目录权限等，一定要再三验证</li>
<li>你遇到的其它问题欢迎留言~</li>
</ol>
<h1 id="编译MySQL"><a href="#编译MySQL" class="headerlink" title="编译MySQL"></a>编译MySQL</h1><p>&emsp;&emsp;安装依赖</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># MySQL源码地址：https://cdn.mysql.com//Downloads/MySQL-8.0/mysql-8.0.20.tar.gz</span></span><br><span class="line">yum install -y ncurses-devel libtirpc-devel cmake</span><br><span class="line"></span><br><span class="line"><span class="comment"># 缺少：libtirpc-devel</span></span><br><span class="line"><span class="comment"># 报错：Could not find rpc/rpc.h in /usr/include or /usr/include/tirpc</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 缺少：ncurses-devel</span></span><br><span class="line"><span class="comment"># 报错：Curses library not found. Please install appropriate package</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 缺少：rpcsvc</span></span><br><span class="line"><span class="comment"># 报错：Could not find rpcgen</span></span><br><span class="line"><span class="comment"># 编译安装</span></span><br><span class="line">wget https://github.com/thkukuk/rpcsvc-proto/releases/download/v1.4.1/rpcsvc-proto-1.4.1.tar.xz</span><br><span class="line">tar xf rpcsvc-proto-1.4.1.tar.xz</span><br><span class="line"><span class="built_in">cd</span> rpcsvc-proto-1.4.1/</span><br><span class="line">./configure &amp;&amp; make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir /home/lamp/mysql/data -p</span><br><span class="line"></span><br><span class="line">cmake . \</span><br><span class="line">-DCMAKE_INSTALL_PREFIX=/home/lamp/mysql \</span><br><span class="line">-DMYSQL_DATADIR=/home/lamp/mysql/data \</span><br><span class="line">-DMYSQL_UNIX_ADDR=/home/lamp/mysql/mysql.sock \</span><br><span class="line">-DWITH_INNODBBASE_STORAGE_ENGINE=1 \</span><br><span class="line">-DENABLE_LOCAL_INFILE=1 \</span><br><span class="line">-DEXTRA_CHARSETS=all \</span><br><span class="line">-DDEFAULT_CHARSET=utf8 \</span><br><span class="line">-DDEFAULT_COLLATION=utf8_general_ci \</span><br><span class="line">-DMYSQL_USER=mysql \</span><br><span class="line">-DWITH_DEBUG=0 \</span><br><span class="line">-DFORCE_INSOURCE_BUILD=1 \</span><br><span class="line">-DDOWNLOAD_BOOST=1 -DWITH_BOOST=/home/lamp/boost \</span><br><span class="line">-DWITH_EMBEDED_SERVER=0</span><br><span class="line"><span class="comment"># boost下载超时的话，记录下载地址：https://dl.bintray.com/boostorg/release/1.70.0/source/boost_1_70_0.tar.gz</span></span><br><span class="line"><span class="comment"># 使用迅雷下载，大约不到1min就下载好了</span></span><br><span class="line"><span class="comment"># 移动到/home/lamp/boost目录下面</span></span><br></pre></td></tr></table></figure>
<p>编译时间较长长长长长长长长长长长长长长长长😡</p>
<h2 id="一般遇到的问题-1"><a href="#一般遇到的问题-1" class="headerlink" title="一般遇到的问题"></a>一般遇到的问题</h2><ol>
<li>依赖问题</li>
<li>网速太慢</li>
<li>编译的时候内存不足</li>
<li>目录权限</li>
</ol>
<p>不等待直接编译PHP</p>
<h1 id="编译PHP"><a href="#编译PHP" class="headerlink" title="编译PHP"></a>编译PHP</h1><h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install libxml2-devel bzip2-devel net-snmp-devel curl-devel libpng-devel freetype-devel libjpeg-devel -y</span><br><span class="line"></span><br><span class="line">wget http://ftp.gnu.org/gnu/libiconv/libiconv-1.16.tar.gz</span><br><span class="line"><span class="comment"># wget http://ftp.gnu.org/gnu/libiconv/libiconv-1.14.tar.gz</span></span><br><span class="line">./configure --prefix=/usr/<span class="built_in">local</span> --with-apr=/home/lamp/apr</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line"></span><br><span class="line">wget https://sourceforge.net/projects/mcrypt/files/Libmcrypt/2.5.8/libmcrypt-2.5.8.tar.gz</span><br><span class="line">./configure &amp;&amp; make &amp;&amp; make install &amp;&amp; /sbin/ldconfig</span><br><span class="line"><span class="built_in">cd</span> libltdl/</span><br><span class="line">./configure --<span class="built_in">enable</span>-ltdl-install &amp;&amp; make &amp;&amp; make install</span><br><span class="line"></span><br><span class="line">wget https://jaist.dl.sourceforge.net/project/mhash/mhash/0.9.9.9/mhash-0.9.9.9.tar.gz</span><br><span class="line">./configure &amp;&amp; make &amp;&amp; make install</span><br><span class="line">ln -s /usr/<span class="built_in">local</span>/lib/* /usr/lib/</span><br><span class="line">ln -s /usr/<span class="built_in">local</span>/bin/libmcrypt-config /usr/bin/</span><br><span class="line"></span><br><span class="line">wget https://jaist.dl.sourceforge.net/project/mcrypt/MCrypt/2.6.8/mcrypt-2.6.8.tar.gz</span><br><span class="line"><span class="comment"># 解决报错：configure: error: *** libmcrypt was not found</span></span><br><span class="line">ln -s /usr/<span class="built_in">local</span>/bin/libmcrypt_config /usr/bin/libmcrypt_config</span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=/usr/<span class="built_in">local</span>/lib: LD_LIBRARY_PATH</span><br><span class="line">./configure &amp;&amp; make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<h2 id="安装PHP"><a href="#安装PHP" class="headerlink" title="安装PHP"></a>安装PHP</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://www.php.net/distributions/php-7.4.5.tar.gz</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>liunx</tag>
      </tags>
  </entry>
  <entry>
    <title>code</title>
    <url>/2020/05/13/code/</url>
    <content><![CDATA[<p>categories: 测试<br>    #!/usr/bin/python3<br>    def main():<br>        print(“hello world”)</p>
<pre><code>if __name__ == &quot;__mian__&quot;:
    main()</code></pre><h1 id="ceshi"><a href="#ceshi" class="headerlink" title="ceshi"></a>ceshi</h1><pre><code>#!/bin/bash
echo &quot;ceshi&quot;</code></pre><p> cehshi</p>
<pre><code>#!/usr/bin/python3
    def main():
        print(&quot;hello world&quot;)

    if __name__ == &quot;__mian__&quot;:
        main()</code></pre><p>hexo 文章插入图片的方法<br><br>设置站点配置_config.yml:将post_asset_folder: false改为post_asset_folder: true<br><br>安装插件:npm install <a href="https://github.com/CodeFalling/hexo-asset-image" target="_blank" rel="noopener">https://github.com/CodeFalling/hexo-asset-image</a> – save<br><br>运行hexo n “XXXXXX”,生成XXXXX.md博文时就会在/source/_posts目录下生成XXXXXX的文件夹，将你想在XXXXX博文中插入的照片放置到这个同名文件夹中即可，图片的命名随意<br><br>添加图片:在想添加的位置写入![](图片名字.图片格式),例如![](1.png)</p>
]]></content>
  </entry>
  <entry>
    <title>docker--容器创建后添加端口映射</title>
    <url>/2020/05/13/docker/</url>
    <content><![CDATA[<p>标注：[hash_of_the_container] 为容器id</p>
<pre><code>vim /var/lib/docker/containers/[hash_of_the_container]/hostconfig.json</code></pre><p>在 hostconfig.json 里有 “PortBindings”:{} 这个配置项，</p>
<p>改成 </p>
<pre><code>&quot;PortBindings&quot;:{&quot;9001/tcp&quot;:[{&quot;HostIp&quot;:&quot;&quot;,&quot;HostPort&quot;:&quot;900&quot;}]}
      前者为容器端口，后者为宿主机端口</code></pre><p>如果容器内端口从没有暴露，需要在修改config.v2.json</p>
<pre><code>vim /var/lib/docker/containers/[hash_of_the_container]/config.v2.json</code></pre><p>在 config.v2.json 里面添加一个配置项 </p>
<pre><code>&quot;ExposedPorts&quot;:{&quot;80/tcp&quot;:{}} ,</code></pre><p><font color="#FF0000">必须将这个配置项添加到 “Tty”: true, 前面</font></p>
<p>最后重启 docker的守护进程 systemctl restart  docker<br><br>启动容器id   docker start   ID<br></p>
<p>使用docker ps  查看容器端口是否映射<br><img src="/2020/05/13/docker/1.png" alt></p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>liunx</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>python-str</title>
    <url>/2020/04/23/python-str/</url>
    <content><![CDATA[<p>code here<br>从字符串中提取字符</p>
<pre><code>str = &quot;hello python&quot;
print(str[7])</code></pre><p>for循环遍历字符串中每一个字符</p>
<pre><code>for c in str:
    print(c)</code></pre><p>统计字符串长度</p>
<pre><code>str = &quot;hello python&quot;
print(len(str))</code></pre><p>统计一个字符在字符串中出现的次数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str = <span class="string">"hello python"</span></span><br><span class="line">print(str.count(<span class="string">"l"</span>))</span><br></pre></td></tr></table></figure>
<pre><code>puts &quot;Awesome!&quot; unless lame</code></pre><pre><code>

    代码

</code></pre>
]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>liunx</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>全球加速--阿里云</title>
    <url>/2020/01/16/jiasu/</url>
    <content><![CDATA[<h1 id="全球加速"><a href="#全球加速" class="headerlink" title="全球加速"></a>全球加速</h1><p>首先确定加速区域以及服务区域<br><br>例如：业务服务器在华北2（北京）,想让美国的玩家流畅访问,需要购买加速区域在北美,服务区域在中国大陆<br></p>
<p>创建全球加速后，会得到一个美国IP，把这个IP和华北2服务器的IP绑定同一个域名，根据解析路线区分解析。<br><br>如果是北京地区访问这个IP，返回的是华北2的服务器IP。相反如果是美国玩家访问，则会返回全球加速的IP。<br></p>
<pre><code>解析路线：比如，DnsCEO的智能DNS就会自动判断用户的上网路线是联通还是电信，然后智能返回联通或者电信的服务器IP。多线多地区智能DNS，能自动判断用户的上网路线是上海电信还是广东电信，然后智能返回对应的上海电信和广东电信的服务器IP。</code></pre><p>例如：<br>    <br>新加坡实例需要拥有弹性公网IP   (ECS控制台–&gt;更多–&gt;网络和安全组–&gt;公网IP转为弹性公网IP)<br></p>
<pre><code>还需要创建个弹性网卡
    网卡名称：自定义
    专有网络：需同ECS同一网络
    交换机：需同ECS同一网络
    安全组：需同ECS同一网络
然后绑定ECS</code></pre><p>创建一个全球加速实例，在全球加速主界面找到实例，然后添加IP(购买个ip就好)。然后点击创建的ip，绑定一个新加坡的实例</p>
<p>最后域名解析</p>
<p>需要购买一个域名版本管理套餐 绑定一个子域名<br>然后用子域名解析A记录</p>
<pre><code>test    A    世界_北美洲     xxx.xxx.xxx.xxx(全球加速ip)
test    A    默认         xxx.xxx.xxx.xxx(服务器ip)</code></pre>]]></content>
      <categories>
        <category>阿里云</category>
      </categories>
      <tags>
        <tag>阿里云</tag>
      </tags>
  </entry>
  <entry>
    <title>mongodb安装以及基础操作</title>
    <url>/2020/01/08/mongo/</url>
    <content><![CDATA[<h1 id="安装mongo数据库"><a href="#安装mongo数据库" class="headerlink" title="安装mongo数据库"></a>安装mongo数据库</h1><pre><code>cd  /etc/yum.repos.d/
vim   mongodb-org-3.2.repo
[mogodb-org]
name=MongoDB Repository
baseurl=http://mirrors.aliyun.com/mongodb/yum/redhat/6Server/mongodb-org/3.4/x86_64/
gpgcheck=0
enabled=1</code></pre><p>然后保存退出</p>
<pre><code>yum clean all    # 清除缓存
yum install  mongod-org  -y</code></pre><h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><pre><code># mongod.conf

# for documentation of all options, see:
#   http://docs.mongodb.org/manual/reference/configuration-options/

# where to write logging data.
systemLog:
  destination: file
  logAppend: true
  path: /var/log/mongodb/mongod.log     #  日志文件路径

# Where and how to store data.
storage:
  dbPath: /var/lib/mongo    # 数据保存路径
  journal:
    enabled: true        # 是否开启
#  engine:
#  mmapv1:
#  wiredTiger:

# how the process runs
processManagement:
  fork: true  # fork and run in background
  pidFilePath: /var/run/mongodb/mongod.pid  # location of pidfile

# network interfaces
net:
  port: 27017        # 监听端口
  bindIp: 192.168.1.163  # 允许连接的IP


#security:
#security:

#  authorization: enabled

#operationProfiling:

#replication:

#sharding:
## Enterprise-Only Options

#auditLog:

#snmp:</code></pre><h1 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h1><pre><code>mongo   IP   #  进入数据库

show  dbs    # 查看所有库

show tables    # 查看当前库的所有表

use   DBNAME    # 进入数据库

db.table.find()        # 查看表中的所有数据

db.table.find({name : xxx})    # 查看表中name为xxx的数据

db.table.find({name : xxx}).pretty()    # 查看表中name为xxx的数据   以json格式显示

db.table.count()    # 统计数据行数

db.tables.find().count()    # 统计行数   同上

db.table.count({name : xxx})    # 统计name为xxx的行数

db.table.update({},{$set:{name : xxx}})        # 把表中所有数据的name 改为 xxx

db.table.update({name : xxx},{$set:{ID : 666}})        # 把name 为 xxx 的ID 改为666  （只更改匹配到的第一条数据）

db.table.update({name : xxx},{$set:{ID : 666}},false,true)    # 把全部name 为 xxx的ID 改为666  （匹配到的所有数据）

db.payments.update({roleID : xxx, &quot;orderNo&quot; : &quot;xxx&quot;},{$set:{&quot;realMoney_usd&quot; : xxx}},true,false)     # 修改数据如果字段不存在 则新建

db.copyDatabase(&apos;old_name&apos;, &apos;new_name&apos;, &apos;localhost&apos;)    # 复制数据库

use  DBNAME     # 进入数据库
db.dropDatabase()    # 删除当前所在的库

db.table.drop()        # 删除表

db.table.remove({})    # 删除表中所有数据

db.table.remove({name : xxx})    # 删除表中被匹配到的第一条数据

db.table.remove({name : xxx},false,true)    # 删除表中被匹配到的所有数据

use DBNAME     # 进入数据库
db.create.table()    # 创建一个表      如果这个数据库之前不存在  创建表后会自动创建库</code></pre><h1 id="增删改查–扩展"><a href="#增删改查–扩展" class="headerlink" title="增删改查–扩展"></a>增删改查–扩展</h1><pre><code>db.roles.find({&quot;ID&quot;:{&quot;$lte&quot;: 200,&quot;$gte&quot;:155 },userType:41})    # 范围查询  查看ID 小于等于200  大于等于155 并且userType=41 的数据

db.roles.find({ &quot;name&quot; : {$regex:/大气的.*/i}})        # 模糊查询    匹配name 包含&quot;大气的&quot; 数据

db.towers.update({&quot;_id&quot; : ObjectId(&quot;5a6205e275a50f321e04b8ae&quot;)},{$set:{ &quot;levelCustomList.1.state&quot;:2}})        # 把匹配数据的levelCustomlist的第二个字段(state) 的值改为 2

db.oreseasons.update({&quot;_id&quot; : ObjectId(&quot;5ad227d8da0d2e0522930156&quot;)},{$unset:{&quot;groups.0&quot;:&apos;&apos;}},false, true)    # 把匹配数据的groups中第一个字段删除</code></pre><h1 id="数据库的备份以及恢复"><a href="#数据库的备份以及恢复" class="headerlink" title="数据库的备份以及恢复"></a>数据库的备份以及恢复</h1><pre><code>mongodump   -h  IP    -d  DBNAME    -o  dir    # 备份数据库

mongorestore   -h  IP   -d    DBNAME     dir/DBNAME/    # 恢复数据库</code></pre>]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>mongo</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>sshpass</title>
    <url>/2019/12/27/sshpass/</url>
    <content><![CDATA[<h3 id="使用前提：对于未连接过的主机。而又不输入yes进行确认。需要sshd服务的优化："><a href="#使用前提：对于未连接过的主机。而又不输入yes进行确认。需要sshd服务的优化：" class="headerlink" title="使用前提：对于未连接过的主机。而又不输入yes进行确认。需要sshd服务的优化："></a>使用前提：对于未连接过的主机。而又不输入yes进行确认。需要sshd服务的优化：</h3><pre><code># vim /etc/ssh/ssh_config   
StrictHostKeyChecking no
GSSAPIAuthentication no
UseDNS no

# service sshd restart</code></pre><h3 id="sshpass-命令安装："><a href="#sshpass-命令安装：" class="headerlink" title="sshpass 命令安装："></a>sshpass 命令安装：</h3><pre><code># yum -y install sshpass</code></pre><h3 id="sshpass的用法举例"><a href="#sshpass的用法举例" class="headerlink" title="sshpass的用法举例"></a>sshpass的用法举例</h3><pre><code>sshpass -p password ssh -o StrictHostKeyChecking=no lius@192.168.33.56 &quot;ls /tmp&quot;

-p: 指定密码
-o: ssh或scp的一个选项, StrictHostKeyChecking=no表示在第一次主机认证的时候, 自动接收远端主机密钥.</code></pre><h3 id="常用案例"><a href="#常用案例" class="headerlink" title="常用案例"></a>常用案例</h3><pre><code>#!/bin/bash
sshpass  -p password  ssh  -o  StrictHostKeyChecking=no  xxxx@IP  &lt;&lt; restartserver
cd   /subverison/data/
svn update

restartserver</code></pre>]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>sshpass</tag>
      </tags>
  </entry>
  <entry>
    <title>jenkins项目迁移</title>
    <url>/2019/12/24/remove/</url>
    <content><![CDATA[<pre><code>systemctl stop jenkins
cp -rp /var/lib/jenkins /home/jenkins
sed -i s&apos;@/var/lib/jenkins@/home/jenkins@&apos; /etc/sysconfig/jenkins #修改主目录
systemctl start jenkins
rm -rf /var/lib/jenkins</code></pre>]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>jenkins添加普通用户设置权限</title>
    <url>/2019/12/24/jenkins/</url>
    <content><![CDATA[<h3 id="jenkins创建普通用户并配置权限"><a href="#jenkins创建普通用户并配置权限" class="headerlink" title="jenkins创建普通用户并配置权限"></a>jenkins创建普通用户并配置权限</h3><p><br>1、首先在Manage Jenkins –&gt; 用户管理  创建用户<br><br>2、然后在Manage Jenkins –&gt; 全局设置 授权策略选择：<br><br>项目矩阵授权策略  添加用户或者用户组 选择权限<br><br><img src="/2019/12/24/jenkins/1.png" alt><br><br>3、找到需要授权的项目点击配置<br><br><img src="/2019/12/24/jenkins/2.png" alt><br><br>启用项目安全<br><br><img src="/2019/12/24/jenkins/3.png" alt><br><br>添加admin用户以及其他用户<br><br><img src="/2019/12/24/jenkins/4.png" alt><br><br>最后登录测试<br><br><br><br></p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>subversion+jenkinks部署</title>
    <url>/2019/12/03/test/</url>
    <content><![CDATA[<ul>
<li><a href="#1">1.subversion+jenkins安装部署</a><ul>
<li><a href="#2">1.1配置环境</a></li>
<li><a href="#3">1.2安装jenkins</a></li>
<li><a href="#4">1.3安装subversion</a></li>
</ul>
</li>
</ul>
<p>#</p><h4 id="2">1.1配置环境<br>    环境：centos6.9<br>    软件包：jdk-8u60-linux-x64.tar.gz<br>首先关闭selinux和防火墙<br><br><img src="/2019/12/03/test/1.png" alt><br><br>更改时间      &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;–可以写入计划任务中<br><br><img src="/2019/12/03/test/3.png" alt><br><br>创建目录   <p></p>
<pre><code>mkdir /application/</code></pre><p><br>解压jdk包到创建的目录中<br></p>
<pre><code>tar xf jdk-8u60-linux-x64.tar.gz   -C /application/</code></pre><p><br>做软连接<br></p>
<pre><code>ln -s  /application/jdk1.8.0_60/ /application/jdk</code></pre><p><br>设置环境变量<br></p>
<pre><code>sed -i.ori &apos;$a export  JAVA_HOME=/application/jdk\nexport PATH=$JAVA_HOME/bin:$JAVA_HOME/jre/bin:$PATH\nexport  CLASSPATH=.$CLASSPATH:$JAVA_HOME/lib:$JAVA_HOME/jre/lib:$JAVA_HOME/lib/tools.jar&apos;  /etc/profile</code></pre><p><br>source一下生效环境变量<br><br><img src="/2019/12/03/test/2.png" alt><br><br><img src="/2019/12/03/test/4.png" alt><br></p>
<h4 id="3">1.2安装jenkins

<p>下载yum源并且导入秘钥</p>
<br>

<pre><code>wget -O /etc/yum.repos.d/jenkins.repo http://pkg.jenkins-ci.org/redhat/jenkins.repo&lt;br/&gt;

rpm --import https://jenkins-ci.org/redhat/jenkins-ci.org.key</code></pre><p><br><img src="/2019/12/03/test/5.png" alt><br></p>
<pre><code>yum install jenkins -y </code></pre><p><br><img src="/2019/12/03/test/6.png" alt><br></p>
<pre><code>如果安装失败就到官网下载jenkins的rpm包
http://pkg.jenkins-ci.org/redhat-stable/</code></pre><p>编辑配置文件更改端口启动jenkins</p>
<pre><code>vim /etc/sysconfig/jenkins</code></pre><p>找到修改端口号：<br><br>JENKINS_PORT=”8080”  # 此端口不冲突可以不修改<br></p>
<pre><code>service  jenkins  start</code></pre><p><img src="/2019/12/03/test/7.png" alt><br><br>这里会报错 因为Jenkins默认找的jdk环境变量在/usr/bin下  我们需要更改下路径<br></p>
<pre><code>vim  /etc/init.d/jenkins</code></pre><p><br>找到candidates=”   这个配置项<br><br><img src="/2019/12/03/test/8.png" alt><br><br>可以使用这种方式找到路径<br><br><img src="/2019/12/03/test/9.png" alt><br><br>然后在次启动Jenkins    成功<br><br><img src="/2019/12/03/test/10.png" alt><br><br>在浏览器中访问<br><br>首次进入会要求输入初始密码如下图，<br><br><img src="/2019/12/03/test/11.png" alt><br><br>初始密码在：/var/lib/jenkins/secrets/initialAdminPassword<br><img src="/2019/12/03/test/12.png" alt><br><br><img src="/2019/12/03/test/13.png" alt><br><br><img src="/2019/12/03/test/14.png" alt><br><br><img src="/2019/12/03/test/15.png" alt><br><br><img src="/2019/12/03/test/16.png" alt><br><br><img src="/2019/12/03/test/17.png" alt><br><br><img src="/2019/12/03/test/18.png" alt><br><br><img src="/2019/12/03/test/19.png" alt><br><br><img src="/2019/12/03/test/20.png" alt></p>
<h4 id="4">1.3安装subversion

<p>配置好yum源 直接yum安装subversion </p>
<pre><code>yum -y install subversion </code></pre><p><br><img src="/2019/12/03/test/21.png" alt><br><br>查看版本号</p>
<pre><code>svnserve --version</code></pre><p>递归创建目录</p>
<pre><code>mkdir  /data/svn/program   -p</code></pre><p><br><img src="/2019/12/03/test/22.png" alt><br><br>创建svn版本库</p>
<pre><code>svnadmin create /data/svn/program/</code></pre><p>配置账号：</p>
<pre><code>vim /data/svn/program/conf/passwd

    [manager]
    xinlong = xinlong</code></pre><p><br><img src="/2019/12/03/test/23.png" alt><br><br>配置权限：</p>
<pre><code>vim /data/svn/program/conf/authz

    [groups]
    manager = xinlong

    [program:/]
    @manager = rw</code></pre><p><br><img src="/2019/12/03/test/24.png" alt><br><br>配置服务：</p>
<pre><code>vim /data/svn/program/conf/svnserve.conf

    anon-access = none ## 匿名用户可读(关闭)
    auth-access = write ## 授权用户可写
    password-db = /data/svn/program/conf/passwd ## 指定账号配置文件   绝对路径
    authz-db = /data/svn/program/conf/authz ## 指定权限配置文件  绝对路径
    realm = /data/svn/program ## 指定版本库的认证域，即在登录时提示的认证域名称。缺省值：一个UUID(Universal Unique IDentifier，全局唯一标示)。</code></pre><p><br><img src="/2019/12/03/test/25.png" alt><br><br>启动subversion</p>
<pre><code>svnserve -d</code></pre><p>开通HTTP协议 安装httpd及其svn模块</p>
<pre><code>yum -y install httpd mod_dav_svn</code></pre><p><br><img src="/2019/12/03/test/26.png" alt><br><br>确认模块 dav/dav_svn 已加载<br><br>(Centos6  路径是/etc/httpd/conf/httpd.conf )<br></p>
<pre><code>grep -E &quot;dav_module&quot; /etc/httpd/conf.modules.d/00-dav.conf</code></pre><p><br><img src="/2019/12/03/test/27.png" alt><br><br>( Centos6  路径是 /etc/httpd/conf.d/subversion.conf )</p>
<pre><code>grep -E &quot;dav_svn_module&quot; /etc/httpd/conf.modules.d/10-subversion.conf</code></pre><p><br><img src="/2019/12/03/test/28.png" alt><br><br>SVN HTTP 配置</p>
<pre><code>vim /etc/httpd/conf/httpd.conf

    &lt;Location /program&gt;
    DAV svn
    SVNPath /data/svn/program
    AuthType Basic
    AuthName &quot;SVN program repository&quot;
    AuthUserFile /data/svn/program/conf/svn-auth.htpasswd
    AuthzSVNAccessFile /data/svn/program/conf/authz
    # Authorization: Authenticated users only
    # SVNListParentPath on
    Satisfy all
    Require valid-user
    &lt;/Location&gt;</code></pre><p><br><img src="/2019/12/03/test/29.png" alt><br><br>创建 SVN HTTP 用户</p>
<pre><code>-m 表示以 md5 加密密码

touch  /data/svn/program/conf/svn-auth.htpasswd</code></pre><p><br><img src="/2019/12/03/test/30.png" alt><br></p>
<pre><code>htpasswd -m  /data/svn/program/conf/svn-auth.htpasswd    xinlong</code></pre><p><br><img src="/2019/12/03/test/31.png" alt><br><br>启动httpd服务<br><br><img src="/2019/12/03/test/32.png" alt><br><br>客户端验证(<a href="http://xxx" target="_blank" rel="noopener">http://xxx</a>)</p>
<p>Windows 下使用 Chrome 浏览器访问: <a href="http://ip/program/，输入用户名" target="_blank" rel="noopener">http://ip/program/，输入用户名</a> chalres 及其密码，成功。<br><br><img src="/2019/12/03/test/33.png" alt><br><br><br>TortoiseSVN检测<br><br>右击  点击SVN checkout<br><br><img src="/2019/12/03/test/34.png" alt><br><br><img src="/2019/12/03/test/35.png" alt><br><br><img src="/2019/12/03/test/36.png" alt><br><br><img src="/2019/12/03/test/37.png" alt><br><br><img src="/2019/12/03/test/38.png" alt><br><br>然后右击 点击SVN commit</p>
<p><img src="/2019/12/03/test/39.png" alt><br><br><img src="/2019/12/03/test/40.png" alt><br><br><img src="/2019/12/03/test/41.png" alt><br><br><img src="/2019/12/03/test/42.png" alt><br><br>访问网站也可以看到</p>
<p><img src="/2019/12/03/test/43.png" alt><br><br><img src="/2019/12/03/test/44.png" alt><br></p>
<h3 id="进入Jenkins的主界面点击新建或创建一个新任务"><a href="#进入Jenkins的主界面点击新建或创建一个新任务" class="headerlink" title="进入Jenkins的主界面点击新建或创建一个新任务"></a>进入Jenkins的主界面点击新建或创建一个新任务<br></h3><p><br>输入项目的名字选择自由风格点击OK<br><br><img src="/2019/12/03/test/45.png" alt><br><br><img src="/2019/12/03/test/46.png" alt><br><br>选择源码管理中的Subversion(SVN) 填写第五步搭建SVN的地址(里面需要有代码)<br><br><img src="/2019/12/03/test/47.png" alt><br><br><img src="/2019/12/03/test/48.png" alt><br><br><img src="/2019/12/03/test/49.png" alt><br><br><img src="/2019/12/03/test/50.png" alt><br><br><img src="/2019/12/03/test/51.png" alt><br><br><img src="/2019/12/03/test/52.png" alt><br><br><img src="/2019/12/03/test/53.png" alt><br><br><img src="/2019/12/03/test/54.png" alt></p>
<pre><code>    #!/bin/bash
date=`date +&quot;%H:%M&quot;`
file=`ls -l  /data/program/  |grep db  |awk -F&quot; &quot; &apos;{print $(NF-1)}&apos;`
if [ &quot;$date&quot; == &quot;$file&quot; ];then
echo &quot;no&quot;
else
echo &quot;checkout&quot;
svn  checkout  http://192.168.1.240/program/  /data/install/   --username  xinlong
echo &quot;OK&quot; &gt;/data/ok.txt
echo &quot;OK&quot;
fi</code></pre><p><br><img src="/2019/12/03/test/55.png" alt><br><br><img src="/2019/12/03/test/56.png" alt><br><br><img src="/2019/12/03/test/57.png" alt><br><br><img src="/2019/12/03/test/58.png" alt><br><br><img src="/2019/12/03/test/59.png" alt><br><br><img src="/2019/12/03/test/60.png" alt><br><br><img src="/2019/12/03/test/61.png" alt><br><br><img src="/2019/12/03/test/62.png" alt><br><br><img src="/2019/12/03/test/63.png" alt><br><br><img src="/2019/12/03/test/64.png" alt><br><br><img src="/2019/12/03/test/65.png" alt><br><br><img src="/2019/12/03/test/66.png" alt><br><br><img src="/2019/12/03/test/67.png" alt><br><br><img src="/2019/12/03/test/68.png" alt><br><br><img src="/2019/12/03/test/69.png" alt><br></p>
<h3 id="下面步骤可以更改http-svn-为https"><a href="#下面步骤可以更改http-svn-为https" class="headerlink" title="下面步骤可以更改http svn 为https"></a>下面步骤可以更改http svn 为https</h3><p><br>开通 HTTPS 协议<br></p>
<h3 id="3-1-安装-ssl-模块"><a href="#3-1-安装-ssl-模块" class="headerlink" title="3.1 安装 ssl 模块"></a>3.1 安装 ssl 模块</h3><pre><code>yum -y install mod_ssl openssl</code></pre><h3 id="3-2-生成证书"><a href="#3-2-生成证书" class="headerlink" title="3.2 生成证书"></a>3.2 生成证书</h3><pre><code>mkdir /etc/httpd/ssl
cp nginx.key /etc/httpd/ssl/httpd.key
cp nginx.crt /etc/httpd/ssl/httpd.crt</code></pre><h3 id="3-3-配置证书"><a href="#3-3-配置证书" class="headerlink" title="3.3 配置证书"></a>3.3 配置证书</h3><pre><code>vim /etc/httpd/conf.d/ssl.conf
SSLCertificateFile    /etc/httpd/ssl/httpd.crt
SSLCertificateKeyFile /etc/httpd/ssl/httpd.key</code></pre><p>如果要停用 https 改用 http，只需注释下面的 SSLRequireSSL 一行。</p>
<pre><code>vim /etc/httpd/conf/httpd.conf

&lt;Location /program&gt;
    ## ......

    Require valid-user
    SSLRequireSSL
&lt;/Location&gt;</code></pre><h3 id="3-4-重启服务"><a href="#3-4-重启服务" class="headerlink" title="3.4 重启服务"></a>3.4 重启服务</h3><pre><code>systemctl restart httpd</code></pre><h3 id="3-5-防火墙放行"><a href="#3-5-防火墙放行" class="headerlink" title="3.5 防火墙放行"></a>3.5 防火墙放行</h3><pre><code>vim /etc/sysconfig/iptables
-A INPUT -m state --state NEW -m tcp -p tcp --dport 443 -j ACCEPT</code></pre><p>重启生效</p>
<pre><code>sudo systemctl restart iptables</code></pre><h3 id="3-6-客户端验证-https-xxx"><a href="#3-6-客户端验证-https-xxx" class="headerlink" title="3.6 客户端验证(https://xxx)"></a>3.6 客户端验证(<a href="https://xxx" target="_blank" rel="noopener">https://xxx</a>)</h3><p><br>Windows 下使用 Chrome 浏览器访问: <a href="https://ip/program/，输入用户名" target="_blank" rel="noopener">https://ip/program/，输入用户名</a> charles 及其密码，成功。此时只能使用 https 访问，http 已被禁用。<br><br><br><br><br><br><br></p>
</h4></h4></h4>]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>subversion</tag>
        <tag>jenkins</tag>
      </tags>
  </entry>
</search>
