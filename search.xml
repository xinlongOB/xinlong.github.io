<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>TortoiseSVN使用</title>
    <url>/2020/06/08/TortoiseSVN/</url>
    <content><![CDATA[<h2 id="部署subversion服务器"><a href="#部署subversion服务器" class="headerlink" title="部署subversion服务器"></a>部署subversion服务器</h2><p><a href="https://xinlong.youare.ink/2019/12/03/test/#4" target="_blank" rel="noopener">subversion安装部署</a></p>
<h2 id="TortoiseSVN-安装"><a href="#TortoiseSVN-安装" class="headerlink" title="TortoiseSVN 安装"></a>TortoiseSVN 安装</h2><p>下载地址：<a href="https://tortoisesvn.net/downloads.html" target="_blank" rel="noopener">https://tortoisesvn.net/downloads.html</a>, 页面里有语言包补丁的下载链接。</p>
<h2 id="TortoiseSVN基础操作"><a href="#TortoiseSVN基础操作" class="headerlink" title="TortoiseSVN基础操作"></a>TortoiseSVN基础操作</h2><p>检出代码<br><br><img src="/2020/06/08/TortoiseSVN/5.png" alt><br><br><img src="/2020/06/08/TortoiseSVN/6.png" alt></p>
<p>更新代码<br><br><img src="/2020/06/08/TortoiseSVN/7.png" alt><br></p>
<p>提交代码<br><br><img src="/2020/06/08/TortoiseSVN/8.png" alt><br><br><img src="/2020/06/08/TortoiseSVN/9.png" alt></p>
<p>切新分支<br><br><img src="/2020/06/08/TortoiseSVN/10.png" alt><br><br><img src="/2020/06/08/TortoiseSVN/14.png" alt><br><br>切出后查看内容<br><br><img src="/2020/06/08/TortoiseSVN/15.png" alt><br><br>主线内容<br><br><img src="/2020/06/08/TortoiseSVN/16.png" alt></p>
<p>查看提交记录<br><br><img src="/2020/06/08/TortoiseSVN/18.png" alt><br><br><img src="/2020/06/08/TortoiseSVN/19.png" alt><br><br><img src="/2020/06/08/TortoiseSVN/20.png" alt><br><br><img src="/2020/06/08/TortoiseSVN/21.png" alt><br><br><img src="/2020/06/08/TortoiseSVN/22.png" alt><br></p>
<h2 id="报错解决："><a href="#报错解决：" class="headerlink" title="报错解决："></a>报错解决：</h2><p>提交报错：could not begin a transaction<br><br><img src="/2020/06/08/TortoiseSVN/1.png" alt><br><br>解决办法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span>  /data/svn/program</span><br><span class="line">sudo chown -R apache:apache  ./</span><br></pre></td></tr></table></figure>
<p>修改之前：<br><br><img src="/2020/06/08/TortoiseSVN/2.png" alt><br><br>修改之后：<br><br><img src="/2020/06/08/TortoiseSVN/3.png" alt><br><br>再次提交：<br><br><img src="/2020/06/08/TortoiseSVN/4.png" alt><br></p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>liunx</tag>
        <tag>subversion</tag>
      </tags>
  </entry>
  <entry>
    <title>redis基础配置-运维篇</title>
    <url>/2020/06/06/redis/</url>
    <content><![CDATA[<h2 id="Redis-必知"><a href="#Redis-必知" class="headerlink" title="Redis 必知"></a>Redis 必知</h2><p><br>redis基本的数据结构<br><br>最最最重要的并且是最基础的知识–记不住千万别说了解redis,本人有被羞辱的案例</p>
<pre><code>string：字符串
hash：散列
list：列表
set：集合
sorted set：有序集合</code></pre><h2 id="Redis-简介"><a href="#Redis-简介" class="headerlink" title="Redis 简介"></a>Redis 简介</h2><p> Redis 是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库。<br><br> Redis 与其他 key - value 缓存产品有以下三个特点：<br></p>
<pre><code>Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。
Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。
Redis支持数据的备份，即master-slave模式的数据备份。 </code></pre><h2 id="Redis-优势"><a href="#Redis-优势" class="headerlink" title="Redis 优势"></a>Redis 优势</h2><p>性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。<br><br>丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。<br><br>原子 – Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。<br><br>丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性<br></p>
<h2 id="Linux-下安装redis"><a href="#Linux-下安装redis" class="headerlink" title="Linux 下安装redis"></a>Linux 下安装redis</h2><p><br>下载地址：<a href="http://redis.io/download，下载最新稳定版本。" target="_blank" rel="noopener">http://redis.io/download，下载最新稳定版本。</a><br></p>
<pre><code>$ wget http://download.redis.io/releases/redis-2.8.17.tar.gz
$ tar xzf redis-2.8.17.tar.gz
$ cd redis-2.8.17
$ make</code></pre><p> make完后 redis-2.8.17目录下会出现编译后的redis服务程序redis-server,还有用于测试的客户端程序redis-cli,两个程序位于安装目录 src 目录下：</p>
<p>下面启动redis服务</p>
<pre><code>$ cd src
$ ./redis-server</code></pre><p>注意这种方式启动redis 使用的是默认配置。也可以通过启动参数告诉redis使用指定配置文件使用下面命令启动。 </p>
<pre><code>$ cd src
$ ./redis-server ../redis.conf</code></pre><p> redis.conf 是一个默认的配置文件。我们可以根据需要使用自己的配置文件。<br><br>启动redis服务进程后，就可以使用测试客户端程序redis-cli和redis服务交互了。 比如：<br></p>
<pre><code>$ redis-cli -h  192.168.1.163
192.168.1.163:6379&gt; AUTH mima
OK
192.168.1.163:6379&gt; keys *</code></pre><h2 id="Redis-配置文件"><a href="#Redis-配置文件" class="headerlink" title="Redis 配置文件"></a>Redis 配置文件</h2><p>主要用到的配置项</p>
<pre><code># 绑定的IP     redis-cli 的时候需要 加-h 选项 指定ip
bind 192.168.1.163  

# redis监听的端口号
port 6379        

# 此参数确定了TCP连接中已完成队列(完成三次握手之后)的长度， 当然此值必须不大于Linux系统定义的/proc/sys/net/core/somaxconn值，默认是511，而Linux的默认参数值是128。当系统并发量大并且客户端速度缓慢的时候，可以将这二个参数一起参考设定。该内核参数默认值一般是128，对于负载很大的服务程序来说大大的不够。一般会将它修改为2048或者更大。在/etc/sysctl.conf中添加:net.core.somaxconn = 2048，然后在终端中执行sysctl -p
tcp-backlog 511

# 此参数为设置客户端空闲超过timeout，服务端会断开连接，为0则服务端不会主动断开连接，不能小于0
timeout 300

# tcp keepalive参数。如果设置不为0，就使用配置tcp的SO_KEEPALIVE值，使用keepalive有两个好处:检测挂掉的对端。降低中间设备出问题而导致网络看似连接却已经与对端端口的问题。在Linux内核中，设置了keepalive，redis会定时给对端发送ack。检测到对端关闭需要两倍的设置值
tcp-keepalive 300

# 是否在后台执行，yes：后台运行；no：不是后台运行
daemonize yes

# redis进程文件路径
pidfile /var/run/redis.pid

# 日志等级
loglevel notice

# 日志路径
logfile /data/log/redis/redis-server.log

# 设置db库数量，默认16个库
databases 16

# 在900 秒内有一个键内容发生更改触发快照机制
save 900 1

# 在300 秒内有10个键内容发生更改触发快照机制
save 300 10

# 在10000 秒内有60个键内容发生更改触发快照机制
save 60 10000

# 久化到 RDB 文件时，是否压缩，&quot;yes&quot; 为压缩，“no” 则反之
rdbcompression yes

# 是否开启RC64校验，默认是开启
rdbchecksum yes

# 快照文件名
dbfilename dump.rdb

# 快照文件路径
dir /data/lib/redis

# 如果slave-serve-stale-data设置为yes(默认设置)，从库会继续响应客户端的请求。2) 如果slave-serve-stale-data设置为no，INFO,replicaOF, AUTH, PING, SHUTDOWN, REPLCONF, ROLE, CONFIG,SUBSCRIBE, UNSUBSCRIBE,PSUBSCRIBE, PUNSUBSCRIBE, PUBLISH, PUBSUB,COMMAND, POST, HOST: and LATENCY命令之外的任何请求都会返回一个错误”SYNC with master in progress”。
slave-serve-stale-data yes

# 配置Redis的Slave实例是否接受写操作，即Slave是否为只读Redis。默认值为yes
slave-read-only yes

# 主从数据复制是否使用无硬盘复制功能。默认值为no。
repl-diskless-sync no

# 当启用无硬盘备份，服务器等待一段时间后才会通过套接字向从站传送RDB文件，这个等待时间是可配置的。  这一点很重要，因为一旦传送开始，就不可能再为一个新到达的从站服务。从站则要排队等待下一次RDB传送。因此服务器等待一段  时间以期更多的从站到达。延迟时间以秒为单位，默认为5秒。要关掉这一功能，只需将它设置为0秒，传送会立即启动。默认值为5
repl-diskless-sync-delay 5

# 同步之后是否禁用从站上的TCP_NODELAY 如果你选择yes，redis会使用较少量的TCP包和带宽向从站发送数据。但这会导致在从站增加一点数据的延时。  Linux内核默认配置情况下最多40毫秒的延时。如果选择no，从站的数据延时不会那么多，但备份需要的带宽相对较多。默认情况下我们将潜在因素优化，但在高负载情况下或者在主从站都跳的情况下，把它切换为yes是个好主意。默认值为no。
repl-disable-tcp-nodelay no

# 当 master 不可用，Sentinel 会根据 slave 的优先级选举一个 master 。最低的优先级的 slave ，当选 master 。而配置成 0，永远不会被选举
slave-priority 100

# 是否开启 AOF 日志 记录 默认 redis使用的是 rdb 方式持久化，这种方式在许多应用中已经足够用了。但是 redis 如果中途宕机，会导致可能有几分钟的数据丢失
appendonly no

# 指定本地数据库文件名，默认值为 appendonly.aof
appendfilename &quot;appendonly.aof&quot;

# aof 持久化策略的配置 no 表示不执行 fsync 由操作系统保证数据同步到磁盘 ,always 表示每次写入都执行 fsync ，以保证数据同步到磁盘 ,everysec 表示每秒执行一次 fsync ，可能会导致丢失这 1s 数据。
appendfsync everysec

# （推荐为yes） 在 aof rewrite 期间 是否对 aof 新记录的 append 暂缓使用文件同步策略 主要考虑磁盘 IO 开支和请求阻塞时间。默认为 no, 表示不暂缓新的 aof 记录仍然会被立即同步Linux 的默认fsync策略是30 秒，如果为 yes 可能丢失 30 秒数据 ，但由于yes性能较好,而且会避免出现阻塞, 因此比较推荐
no-appendfsync-on-rewrite yes

# 当 Aof log增长超过指定百分比例时，重写 logfile设置为0表示不自动重写 Aof 日志，重写是为了使 aof 体积保持最小，而确保保存最完整的数据
auto-aof-rewrite-percentage 100

# # 触发 aof rewrite 的最小文件大小
auto-aof-rewrite-min-size 64mb

# aof文件可能在尾部是不完整的，当redis启动的时候，aof文件的数据被载入内存。重启可能发生在redis所在的主机操作系统宕机后，尤其在ext4文件系统没有加上data=ordered选项（redis宕机或者异常终止不会造成尾部不完整现象。）出现这种现象，可以选择让redis退出，或者导入尽可能多的数据。如果选择的是yes，当截断的aof文件被导入的时候，会自动发布一个log给客户端然后load。如果是no，用户必须手动redis-check-aof修复AOF文件才可以
aof-load-truncated yes

# 一个lua脚本执行的最大时间，单位为ms。默认值为5000
lua-time-limit 5000

# 只记录大于等于下边设置的值的操作。0的话，就是关闭监视。默认延迟监控功能是关闭的，如果你需要打开，也可以通过CONFIG SET命令动态设置
latency-monitor-threshold 0

# 数据量小于等于hash-max-ziplist-entries的用ziplist，大于hash-max-ziplist-entries用hash
hash-max-ziplist-entries 512

# value大小小于等于hash-max-ziplist-value的用ziplist，大于hash-max-ziplist-value用hash
hash-max-ziplist-value 64

#-5:最大大小：64 KB&lt;--不建议用于正常工作负载
#-4:最大大小：32 KB&lt;--不推荐
#-3:最大大小：16 KB&lt;--可能不推荐
#-2:最大大小：8kb&lt;--良好
#-1:最大大小：4kb&lt;--良好
list-max-ziplist-size -2

# 数据量小于等于set-max-intset-entries用iniset，大于set-max-intset-entries用set
set-max-intset-entries 512

# 数据量小于等于zset-max-ziplist-entries用ziplist，大于zset-max-ziplist-entries用zset
zset-max-ziplist-entries 128

# value大小小于等于zset-max-ziplist-value用ziplist，大于zset-max-ziplist-value用zset
zset-max-ziplist-value 64

# rename-command：命令重命名，对于一些危险命令例如  FLUSHDB（清空数据库）　FLUSHALL（清空所有记录） CONFIG（客户端连接后可配置服务器）  EVAL (Eval 命令使用 Lua 解释器执行脚本)
rename-command FLUSHALL &quot;&quot;
rename-command FLUSHDB &quot;&quot;
rename-command CONFIG &quot;&quot;
rename-command EVAL &quot;&quot;

# redis 认证密码
requirepass GwJMMSdSHezfeMRMP34fQ0F0F</code></pre><h2 id="Redis-语法"><a href="#Redis-语法" class="headerlink" title="Redis 语法"></a>Redis 语法</h2><p>连接redis</p>
<pre><code>redis-cli -h host -p port -a password</code></pre><p>查看所有的键值对–一般大公司是禁止使用keys *</p>
<pre><code>192.168.1.163:6379&gt; keys *</code></pre><p>正则表达式匹配键值对</p>
<pre><code>192.168.1.163:6379&gt; keys *info*water*
1) &quot;info:&quot;
2) &quot;info:hero&quot;
3) &quot;info:serverInfo&quot;</code></pre><p>查看hash值</p>
<pre><code>192.168.1.163:6379&gt; HGETALL &quot;xxxxxx&quot;
1) &quot;1001&quot;
2) &quot;\&quot;{\\\&quot;roleInfoList\\\&quot;: xxxxx}\&quot;&quot;</code></pre><p>查看有序集合</p>
<pre><code>192.168.1.163:6379&gt; ZREVRANGE &quot;xxxxxxxx&quot; 0 10      # 0表示第一个      
1) &quot;id&quot;
192.168.1.163:6379&gt; ZREVRANGE &quot;xxxxxxxx&quot; 0 10  WITHSCORES   #  加上WITHSCORES可以打印积分
1) &quot;id&quot;
2) &quot;integral&quot;</code></pre><p>删除有序集合成员</p>
<pre><code>ZREM  key  value</code></pre><p>删除键值</p>
<pre><code>del  key</code></pre><p>修改集合</p>
<pre><code>hset keys   更改后的内容</code></pre><p>备份</p>
<pre><code>redis 192.168.1.163:6379&gt; SAVE 
OK</code></pre><h2 id="Redis迁移"><a href="#Redis迁移" class="headerlink" title="Redis迁移"></a>Redis迁移</h2><p>先备份</p>
<pre><code>[root@izm5ea99qngm2vazfs49svz ~]# redis-cli 
127.0.0.1:6379&gt;  AUTH mima      #  认证
OK
127.0.0.1:6379&gt;  SAVE         # 保存数据
OK
127.0.0.1:6379&gt;  CONFIG GET dir       # 查看保存数据位置
1) &quot;dir&quot;
2) &quot;/var/lib/redis&quot;</code></pre><p>需要先把远程服务器的redis停止  然后备份一下当前的快照 不然直接scp过去 会有问题</p>
<pre><code>cd  /var/lib/redis
mv   dump.rdb  dump.rdb.bak</code></pre><p>把快照文件发送到远程服务器</p>
<pre><code>cd  /var/lib/redis  
scp    dump.rdb   user@IP:/var/lib/redis</code></pre><p>启动redis</p>
<pre><code>sudo  redis-server   /etc/redis/redis.conf</code></pre><p>进去redis查看是否迁移成功</p>
<pre><code>[root@test ~]# redis-cli 
127.0.0.1:6379&gt;  AUTH mima  
OK
127.0.0.1:6379&gt;  keys *
1) &quot;info:&quot;
2) &quot;info:hero&quot;
3) &quot;info:serverInfo&quot;</code></pre><p>命令行执行redis语句</p>
<pre><code>redis-cli  -h  127.0.0.1  -p 6379  -a &quot;mima&quot;  del  

echo  &apos;set aaa aaaa&apos; |redis-cli -h   127.0.0.1  -a mima</code></pre><p>附一个redis批量操作的脚本</p>
<pre><code>server=$1     # 传入的第一个参数定义为server
host=$2     # 传入的第二个参数定义为host
echo   &quot;AUTH mima  
ZREVRANGE  chart:newbox@$server:6  0 -1 &quot; &gt; $1.txt        # echo 密码和 语句到$1.txt文件
cat  $1.txt |   redis-cli  -h  $host    &gt;  $1_linshi.txt    命令行执行redis语句   语句内容就是$1.txt文件中的内容   执行结果重定向到  $1_linshi.txt 


cat $1_linshi.txt   |sed  1d  &gt;  $1_redis.txt     # 删除 $1_linshi.txt  文件的第一行


echo   &quot;AUTH mima&quot;  &gt; insert.txt      # echo 密码到insert.txt文件
for role in  `cat  $1_redis.txt`
do

  echo &quot;ZADD  chart:newbox@$server:6  0  $role &quot;  &gt;&gt; insert.txt

done            # for循环 $1_linshi.txt 文件   添加0 到每个键值对中
cat  insert.txt |   redis-cli  -h  $host     执行redis语句</code></pre>]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>liunx</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>kubernetes服务原理</title>
    <url>/2020/06/06/kubernetesyuanli/</url>
    <content><![CDATA[<h2 id="容器编排系统的具体任务"><a href="#容器编排系统的具体任务" class="headerlink" title="容器编排系统的具体任务"></a>容器编排系统的具体任务</h2><pre><code>服务注册和服务发现
负载均衡
配置和存储管理
健康状态监测
自动扩容、缩容、重启
0宕机部署</code></pre><h2 id="容器编排系统工具"><a href="#容器编排系统工具" class="headerlink" title="容器编排系统工具"></a>容器编排系统工具</h2><pre><code>kubernetes
docker swarm
apache mesos and marathon</code></pre><h2 id="此篇文档主要介绍kubernetes"><a href="#此篇文档主要介绍kubernetes" class="headerlink" title="此篇文档主要介绍kubernetes"></a>此篇文档主要介绍kubernetes</h2><p><br>kubernetes是一个开源的平台、自动部署伸缩、自动运维容器化应用平台，支持跨主机的集群多节点。<br></p>
<p>kubernetes集群节点由master和node以及插件组成<br><br>多个master是为了冗余<br><br>而node节点就是工作节点</p>
<h2 id="master组成部分"><a href="#master组成部分" class="headerlink" title="master组成部分"></a>master组成部分</h2><p>  API server api入口 是一个数据  负责接受用户的请求 语法没问题 放到etcd<br>  scheduler    调度器  查看那台服务器适合执行node 会一直watch apiserver上是否有新建资源<br>  <br>  controller    控制器（一直循环 也成控制循环器）  负责让调度器调用镜像启动容器，确保容器正常运行，自动重启 重启失败直接干掉  controller 会一直watch apiserver上的资源变动 如果有变动  会立即执行用户的请求 <br><br>  还有个额外的etcd  会存储各种k v 规范数据   规范是apisever定义的</p>
<h2 id="node组成部分"><a href="#node组成部分" class="headerlink" title="node组成部分"></a>node组成部分</h2><p>  kubelet 一直watch apiserver  如果需要创建容器 会去调用docker docker去调用region（镜像仓库）<br>   <br>  docker 容器  <br><br>  pod   容器外壳，一个pod中可以存在多个容器<br>   <br>  proxy  <br> </p>
<p>kubernetes 运行的核心基本单元是pod(原子单元)而不是容器</p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>docker容器是利用内核的六种名称空间技术 来实现程序运行环境的隔离<br><br>pid  网络  文件系统  ipc  user uts（域名和主机名）<br></p>
<p>docker的四种网络模型  </p>
<pre><code>封闭网络   closed
桥接网络   bridge
联盟网络 joined（两个宿主机共享network 和 ipc uts） 
共享宿主机  host</code></pre><h2 id="kubernetes常用的资源类型"><a href="#kubernetes常用的资源类型" class="headerlink" title="kubernetes常用的资源类型"></a>kubernetes常用的资源类型</h2><p><br>pod  service（服务）  namespace（名称空间） volume（存储卷）<br></p>
<h2 id="kubernetes的各种IP"><a href="#kubernetes的各种IP" class="headerlink" title="kubernetes的各种IP"></a>kubernetes的各种IP</h2><p>service（服务）  客户端访问的不是pod_ip 而是访问的service_ip 这样pod宕机后被移除，新添加的pod的ip会是新分配的<br><br>pod_ip  每一个pod都有一个虚拟ip<br><br>service_ip  通过标签选择来管理pod_ip<br><br>DNS  主要管理service_ip 如果 service被意外删除 或者其他情况无法使用  调度器会立即创建新的service_ip  dns动态获取A记录<br><br>node_ip  是节点网卡的ip</p>
<p>访问流程</p>
<pre><code>客户端访问  需要先访问service_ip  然后service_ip 访问pod组件 而pod组件是pod的管理器创建的
例如：客户端访问nginx    会先访问service_ip 然后service_ip转到nginx的pod       nginx_pod 是由pod控制器的管理创建的   
    nginx在访问tomcat的service_ip    tomcat的service_ip 在转到tomcat tomcat_pod也有一个控制器</code></pre><p>kubernetes有三种网络：</p>
<pre><code>节点网络
pod网络  每个pod都是想通的
service网络</code></pre><p>部署</p>
<p>  测试环境</p>
<pre><code>可以使用单点master节点，单etcd实例，node节点按需而定，nfs或者glusterfs等存储系统</code></pre><p>  生产环境</p>
<pre><code>高可用etcd，建立3、5或者7个节点
高可用master
    kube-apiserver 无状态，可多实例
              借助keepalived进行vip流动实现多实例冗余
              或在多实例前端通过haproxy或者nginx反代，并借助于keepalived对代理服务器进行冗余
    kubu-scheduler及kube-controller-manager各自只能有一个活动实例，但可以有多个备用
              各自自带leader选举的功能，并且默认处于启动状态
  多node主机，数量越多，冗余能力越强
  ceph，glusterfs，iscsi， fc san及各种云存储等</code></pre><p>  常用的部署环境</p>
<pre><code>iaas公有云环境：aws，gce，azure等
iaas私有云或者公有云环境，OpenStack和vsphere等
物理服务器或者独立的虚拟机等</code></pre><p>  常用的部署工具</p>
<pre><code>kubeadm(官方工具)
kops(aws专用工具)
kubespray
kontena Pharos</code></pre><p>  其他二次封装的常用发行版</p>
<pre><code>Rancher
Tectonic
Openshift(redhat公司k8s发行版)</code></pre><h2 id="安装文档"><a href="#安装文档" class="headerlink" title="安装文档"></a>安装文档</h2><p><a href="https://xinlong.youare.ink/2020/05/22/kubeadm/" target="_blank" rel="noopener">使用kubeadm安装kubernetes</a></p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>liunx</tag>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>jenkins报错--秘钥认证失败</title>
    <url>/2020/06/01/jenkinsbaocuo/</url>
    <content><![CDATA[<p>测试服更换机器后，新服务器把旧服务器ip顶替，但是秘钥不同。构建的时候报错</p>
<p>报错日志：</p>
<pre><code>Pseudo-terminal will not be allocated because stdin is not a terminal.
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!
Someone could be eavesdropping on you right now (man-in-the-middle attack)!
It is also possible that a host key has just been changed.
The fingerprint for the RSA key sent by the remote host is
SHA256:y0IuKOX1vqISQPtpFZ3zbC+DtBqRMQfd1dXj8foo3Fs.
Please contact your system administrator.
Add correct host key in /var/lib/jenkins/.ssh/known_hosts to get rid of this message.
Offending ECDSA key in /var/lib/jenkins/.ssh/known_hosts:7
Password authentication is disabled to avoid man-in-the-middle attacks.
Keyboard-interactive authentication is disabled to avoid man-in-the-middle attacks.
Permission denied (publickey,gssapi-keyex,gssapi-with-mic,password).
Build step &apos;Execute shell&apos; marked build as failure
Finished: FAILURE</code></pre><p>解决办法：</p>
<pre><code>vim  /var/lib/jenkins/.ssh/known_hosts</code></pre><p>找到对应的IP数据删除整行的秘钥</p>
<p>重新执行构建就ok了</p>
]]></content>
      <tags>
        <tag>liunx</tag>
        <tag>jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>nodejs之事件监听</title>
    <url>/2020/05/30/nodejs5/</url>
    <content><![CDATA[<h2 id="事件概述"><a href="#事件概述" class="headerlink" title="事件概述"></a>事件概述</h2><p>大多数 Node.js 核心 API 构建于惯用的异步事件驱动架构，其中某些类型的对象（又称触发器，Emitter）会触发命名事件来调用函数（又称监听器，Listener）。比如：fs.readStream 打开文件时会发出一个事件。可以通过 require(“events”); 获得 event 模块。通常，事件名采用“小驼峰式”（即第一个单词全小写，后面的单词首字母大写，其它字母小写）命名方式。</p>
<p>所有能触发事件的对象都是EventEmitter类的实例，这些对象有一个eventEmitter.on()函数，用于将一个或多个函数绑定到命名事件上。当EventEmitter对象触发一个事件时，所有绑定在该事件上的函数都会被同步地调用</p>
<p>EventEmitter类获取</p>
<pre><code>// 引入 events模块
var events = require(&quot;events&quot;)
// 创建 eventEmitter对象
var eventEmitter = new events.EventEmitter();</code></pre><h2 id="添加监听器"><a href="#添加监听器" class="headerlink" title="添加监听器"></a>添加监听器</h2><p>emitter.on(eventName,listener)<br><br>使用emitter.on(eventName,listener)方法为指定事件注册一个监听器，添加listener函数到名为eventname的事件的监听器数组的末尾，不会检查listener是否已被添加。多次调用并传入相同的eventname 与 listener会导致listener会被添加多次<br></p>
<p>  参数说明：</p>
<pre><code>eventName：事件名称，string类型。
listener：回调函数</code></pre><p>例子：</p>
<pre><code>// 引入events模块
var events = require(&quot;events&quot;);
// 创建emitter 对象
var emitter = new events.EventEmitter();
// 为 connection 事件注册一个监听器
emitter.on(&quot;connection&quot;,function(){
    console.log(&quot;已连接&quot;);
});

// 一秒后调用监视器
setTimeout(function(){
    emitter.emit(&quot;connection&quot;);
},1000)</code></pre><p>运行结果：</p>
<pre><code>$ node listener.js
已连接    // 一秒后打印已连接</code></pre><p>默认情况下，事件监听器会按照添加的顺序依次调用。emitter.prependListener() 方法可用于将事件监听器添加到监听器数组的开头。比如：</p>
<pre><code>// 引入events模块
var events = require(&quot;events&quot;);
// 创建emitter 对象
var emitter = new events.EventEmitter();
// 为 connection 事件注册一个监听器
emitter.on(&quot;connection&quot;,function(){
    console.log(&quot;我是a&quot;);
});

emitter.prependListener(&quot;connection&quot;,function(){
    console.log(&quot;我是b&quot;);
});


// 一秒后调用监视器
setTimeout(function(){
    emitter.emit(&quot;connection&quot;);
},1000)</code></pre><p>运行结果：</p>
<pre><code>$ node listener.js
我是b
我是a</code></pre><p>注：emitter.addListener(eventName, listener) 是 emitter.on(eventName, listener) 的别名。</p>
<h2 id="调用监听器"><a href="#调用监听器" class="headerlink" title="调用监听器"></a>调用监听器</h2><p><br>使用emitter.emit(eventName[, …args])按照监听器注册的顺序，同步地调用每个注册到名为eventName的事件监听器，并传入提供的参数。如果事件有注册监听返回True，否则返回false<br></p>
<p>  参数说明：</p>
<pre><code>eventName：事件名称
args：传递的参数，多个，类型为任意</code></pre><p>例如：</p>
<pre><code>// 引入event模块
var events = require(&quot;events&quot;);
// 创建emitter 对象
var emitter = new events.EventEmitter();
// 定义一个回调函数
var callback1 = function(arg1,arg2){
    console.log(&quot;print&quot;,arg1,arg2);
};

var callback2 = function(arg3,arg4){
    console.log(&quot;echo &quot;,arg3,arg4);
};

// 为 connection 事件注册监听器
emitter.on(&quot;connection&quot;,callback1)
emitter.on(&quot;connection&quot;,callback2)

// 调用监听器
emitter.emit(&quot;connection&quot;,&quot;愿你&quot;,&quot;安好&quot;)</code></pre><p>运行结果：</p>
<pre><code>$ node emit.js
print 愿你 安好
echo 愿你 安好</code></pre><h2 id="只执行一次的监听器"><a href="#只执行一次的监听器" class="headerlink" title="只执行一次的监听器"></a>只执行一次的监听器</h2><p><br>当时用eventEmitter.on(eventName,listener)注册监听器时，监听器会在每次触发命名事件时被调用。比如：<br></p>
<pre><code>// 引入 events模块
var  events = require(&quot;events&quot;);
// 创建emitter对象
var emitter = new events.EventEmitter();
// 为 connectio 事件注册一个监听器
var n = 0;
emitter.on(&quot;connection&quot;,function(){
    ++n;
    console.log(&quot;调用第&quot; + n + &quot;次&quot;);
})

// 调用监听器
emitter.emit(&quot;connection&quot;)
emitter.emit(&quot;connection&quot;)
emitter.emit(&quot;connection&quot;)
emitter.emit(&quot;connection&quot;)</code></pre><p>运行结果：</p>
<pre><code>$ node while.js
调用第1次
调用第2次
调用第3次
调用第4次</code></pre><p>使用 eventEmitter.once(eventName, listener) 可以注册最多可调用一次的监听器。当事件被触发时，监听器会被注销，然后再调用。比如：</p>
<pre><code>// 引入 events模块
var  events = require(&quot;events&quot;);
// 创建emitter对象
var emitter = new events.EventEmitter();
// 为 connectio 事件注册一个监听器
var n = 0;
emitter.once(&quot;connection&quot;,function(){    // 把emitter.on  换为 emitter.once
    ++n;
    console.log(&quot;调用第&quot; + n + &quot;次&quot;);
})

// 调用监听器
emitter.emit(&quot;connection&quot;)
emitter.emit(&quot;connection&quot;)
emitter.emit(&quot;connection&quot;)
emitter.emit(&quot;connection&quot;)</code></pre><p>运行结果：</p>
<pre><code>$ node while.js
调用第1次</code></pre><p>默认情况下，事件监听器会按照添加的顺序依次调用。emitter.prependOnceListener() 方法可用于将事件监听器添加到监听器数组的开头。用法与我们前面所学的 emitter.prependListener() 方法一致，区别在于这个方法注册的监听器最多只能调用一次</p>
<h2 id="移除监听器"><a href="#移除监听器" class="headerlink" title="移除监听器"></a>移除监听器</h2><p><br>使用emitter.removeListener(eventName.listener)移除监听器<br><br>参数说明：</p>
<pre><code>eventName：事件名称
listener：监听器也就是回调函数名称</code></pre><p>例如：</p>
<pre><code>// 引入 events 模块
var events = require(&quot;events&quot;);
// 创建 emitter 对象
var emitter = new events.EventEmitter();
// 定义一个回调函数
var callback = function () {
  console.log(&quot;syl&quot;);
};
// 为 connection 事件注册一个监听器
emitter.on(&quot;connection&quot;, callback);
// 为 connection 事件移除监听器
emitter.removeListener(&quot;connection&quot;, callback);
// 调用监听器
emitter.emit(&quot;connection&quot;);</code></pre><p>运行结果</p>
<pre><code>Administrator@WF-20180726HPZY MINGW64 /e/coding/nodejs
$ node emit.js

Administrator@WF-20180726HPZY MINGW64 /e/coding/nodejs</code></pre><p>注：removeListener() 最多只会从监听器数组中移除一个监听器。我们可以多次调用 removeListener() 的方式来一个个的移除我们需要移除掉的监听器。</p>
<p>一旦事件被触发，所有绑定到该事件的监听器都会按顺序依次调用。也就是说在事件触发之后、且最后一个监听器执行完成之前，removeListener() 或 removeAllListeners() 不会从 emit() 中移除它们。</p>
<p>例如：</p>
<pre><code>// 引入 events 模块
var events = require(&quot;events&quot;);
// 创建 emitter 对象
var emitter = new events.EventEmitter();
// 定义回调函数
var callback1 = function () {
  console.log(&quot;我是1&quot;);
  emitter.removeListener(&quot;connection&quot;, callback2);
};
var callback2 = function () {
  console.log(&quot;我是2&quot;);
};
// 为 connection 事件注册监听器
emitter.on(&quot;connection&quot;, callback1);
emitter.on(&quot;connection&quot;, callback2);
// 第一次调用监听器，callback1 移除了监听器 callback2，但它依然会被调用。触发时内部的监听器数组为 [callback1, callback2]
emitter.emit(&quot;connection&quot;);
// 第二次调用监听器，此时 callback2 已经被移除了。内部的监听器数组为 [callback1]
emitter.emit(&quot;connection&quot;);</code></pre><p>运行结果：</p>
<pre><code>$ node emit.js
我是1
我是2
我是1</code></pre>]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>liunx</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>nodejs之基础函数</title>
    <url>/2020/05/30/nodejs4/</url>
    <content><![CDATA[<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>在JavaScript中，一个函数可以作为另一个函数的参数。我们可以先定义一个函数，然后传递，也可以在传递参数的地方直接定义函数。</p>
<p>Node.js中函数的使用与Javascript类似，举例来说，你可以这样做： </p>
<pre><code>function say(word) {
  console.log(word);
}

function execute(someFunction, value) {
  someFunction(value);
}

execute(say, &quot;Hello&quot;);</code></pre><p>执行结果</p>
<pre><code>Administrator@WF-20180726HPZY MINGW64 /e/coding/nodejs
$ node test.js
word</code></pre><p> 以上代码中，我们把 say 函数作为execute函数的第一个变量进行了传递。这里传递的不是 say 的返回值，而是 say 本身！<br><br>这样一来， say 就变成了execute 中的本地变量 someFunction ，execute可以通过调用 someFunction() （带括号的形式）来使用 say 函数。<br><br>当然，因为 say 有一个变量， execute 在调用 someFunction 时可以传递这样一个变量。 </p>
<h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p><br>我们可以把一个函数作为变量传递，但是我们不一样要绕这个”先定义，在传递”的圈子，我们可以直接在另一个函数的括号中定义和传递这个参数：<br></p>
<pre><code>function execute(someFunction,value){
    someFunction(value);
}
execute(function(word){console.log(word)},&quot;hello&quot;)</code></pre><p>运行结果：</p>
<pre><code>$ node test.js
hello</code></pre><p> 我们在 execute 接受第一个参数的地方直接定义了我们准备传递给 execute 的函数。用这种方式，我们甚至不用给这个函数起名字，这也是为什么它被叫做匿名函数 。 </p>
<h2 id="导出函数"><a href="#导出函数" class="headerlink" title="导出函数"></a>导出函数</h2><pre><code>function say(word){
      console.log(&quot;word&quot;);
  }

  exports.say = say;</code></pre><p>接收函数</p>
<pre><code>var test = require(&quot;./test.js&quot;)

test.say();</code></pre><p>执行结果</p>
<pre><code>$ node a.js
word</code></pre>]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>liunx</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>nodejs模块</title>
    <url>/2020/05/29/nodejs3/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><br>包用于管理多个模块及依赖关系，可以对多个模块进行封装，包的根目录必须包含package.jsonwenjian，package.json文件是commonjs规范用于描述包的文件，符合commonjs规范的package.json文件一般包含以下字段：<br><br>  1、name：包名。包名是唯一的，只能包含小写字母、数字和下划线<br>  2、version：包版本号<br>  3、description：包说明<br>  4、keywords：关键字数组，用于搜索<br>  5、homepage：项目主页<br>  6、bugs：提交bug的地址<br>  7、license：许可证<br>  8、maintainers：维护者数组<br>  9、contribution：贡献者数组<br>  10、repositories：项目仓库托管地址数组<br>  11、dependencies：包依赖</p>
<p>下面是一个package.json示例：</p>
<pre><code>{
  &quot;name&quot;: &quot;shiyanlou&quot;,
  &quot;description&quot;: &quot;Shiyanlou test package.&quot;,
  &quot;version&quot;: &quot;0.1.0&quot;,
  &quot;keywords&quot;: [&quot;shiyanlou&quot;, &quot;nodejs&quot;],
  &quot;maintainers&quot;: [
    {
      &quot;name&quot;: &quot;test&quot;,
      &quot;email&quot;: &quot;test@shiyanlou.com&quot;
    }
  ],
  &quot;contributors&quot;: [
    {
      &quot;name&quot;: &quot;test&quot;,
      &quot;web&quot;: &quot;http://www.shiyanlou.com/&quot;
    }
  ],
  &quot;bugs&quot;: {
    &quot;mail&quot;: &quot;test@shiyanlou.com&quot;,
    &quot;web&quot;: &quot;http://www.shiyanlou.com/&quot;
  },
  &quot;licenses&quot;: [
    {
      &quot;type&quot;: &quot;Apache License v2&quot;,
      &quot;url&quot;: &quot;http://www.apache.org/licenses/apache2.html&quot;
    }
  ],
  &quot;repositories&quot;: [
    {
      &quot;type&quot;: &quot;git&quot;,
      &quot;url&quot;: &quot;http://github.com/test/test.git&quot;
    }
  ],
  &quot;dependencies&quot;: {
    &quot;webkit&quot;: &quot;1.2&quot;,
    &quot;ssl&quot;: {
      &quot;gnutls&quot;: [&quot;1.0&quot;, &quot;2.0&quot;],
      &quot;openssl&quot;: &quot;0.9.8&quot;
    }
  }
}</code></pre><p>注：package.json 文件可以自己手动编辑，还可以通过 npm init 命令进行生成。你可以自己尝试在终端中输入 npm init 命令来生成一个包含 package.json 文件的包。直接输入 npm init –yes 跳过回答问题步骤，直接生成默认值的 package.json 文件。此外，我们在 github 上传自己项目的时候，通常是不会把 node_modules 这个文件夹传上去的（太大了），只需要有 package.json 就能通过 npm install 命令安装所有依赖</p>
<pre><code>npm init --yes</code></pre><p>执行结果</p>
<pre><code>Wrote to E:\程序代码\nodejs\package.json:

{
  &quot;name&quot;: &quot;nodejs&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;scripts&quot;: {
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;
  },
  &quot;keywords&quot;: [],
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;ISC&quot;
}</code></pre><p>注：执行init的文件夹名称必须要符合要求不可以包含中文以及特殊字符</p>
<h2 id="包操作"><a href="#包操作" class="headerlink" title="包操作"></a>包操作</h2><p>通过命令npm  install  xxx来安装包。比如：<br><br>安装包<br></p>
<pre><code>npm install  express</code></pre><p>更新包</p>
<pre><code>npm update  express</code></pre><p>删除包</p>
<pre><code>npm  uninstall express</code></pre><p>搜索包</p>
<pre><code>npm search express</code></pre><p>注：安装包的时候指定版本使用@  例如： npm install <a href="mailto:pm2@2.8.0">pm2@2.8.0</a></p>
<p>在JavaScripts中，我们通常把 JavaScript 代码分为几个 js 文件，然后在浏览器中将这些 js 文件合并运行，但是在 Node.js 中，是通过以模块为单位来划分所有功能的。每一个模块为一个 js 文件，每一个模块中定义的全局变量和函数的作用范围也被限定在这个模块之内，只有使用 exports 对象才能传递到外部使用。Node.js 官方提供了很多模块，这些模块分别实现了一种功能，如操作文件及文件系统的模块 fs，构建 http 服务的模块 http，处理文件路径的模块 path 等。当然我们也可以自己编写模块。</p>
<p>模块的使用<br><br>在nodejs创建模块很简单，比如我们创建一个myMoudule.js的文件<br></p>
<pre><code>function foo(){
  console.log(&quot;hello world&quot;)
}</code></pre><p>这样就创建好了一个模块，但是别的模块如何来访问它呢？我们使用 module.exports 来导出它。也就是说把 myModule.js 的代码改写成下面这样：</p>
<pre><code>function foo(){
  console.log(&quot;hello world&quot;)
}
module.exports.foo = foo;</code></pre><p>最后我们在创建一个index.js的文件，使用require()函数来访问上面的模块。输入一下代码：</p>
<pre><code>var hello = require(&quot;./myModule.js&quot;);
hello.foo();</code></pre><p>运行结果：</p>
<pre><code>$ node myModule.js 


$ node index.js
hello world</code></pre><p>注：require() 加载模块，以 ‘/‘ 为前缀的模块是文件的绝对路径。’./‘ 为前缀的模块是相对于调用 require() 的文件的，上面的例子中 index.js 和 myModule.js 是在同一个目录下（project 目录）。当没有以 ‘/‘、’./‘ 或 ‘../‘ 开头来表示文件时，这个模块必须是一个核心模块或加载自 node_modules 目录。如果给定的路径不存在，则 require() 会抛出一个 code 属性为 ‘MODULE_NOT_FOUND’ 的 Error。</p>
<h2 id="核心模块"><a href="#核心模块" class="headerlink" title="核心模块"></a>核心模块</h2><p><br>核心模块定义在nodejs源代码的lib/ 目录下。require()总是会优先加载核心模块。例如：require(‘http’)始终返回内置的HTTP模块，即使有同名文件<br></p>
<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p><br>当循环调用require()时，一个模块可能在未完成执行时被返还。比如：<br></p>
<p>a.js 的代码为：</p>
<pre><code>console.log(&quot;a 开始&quot;);
exports.done = false;
var b = require(&quot;./b.js&quot;);
console.log(&quot;在 a 中，b.done = %j&quot;, b.done);
exports.done = true;
console.log(&quot;a 结束&quot;);</code></pre><p>b.js 的代码为：</p>
<pre><code>console.log(&quot;b 开始&quot;);
exports.done = false;
var a = require(&quot;./a.js&quot;);
console.log(&quot;在 b 中，a.done = %j&quot;, a.done);
exports.done = true;
console.log(&quot;b 结束&quot;);</code></pre><p>main.js 的代码为：</p>
<pre><code>console.log(&quot;main 开始&quot;);
var a = require(&quot;./a.js&quot;);
var b = require(&quot;./b.js&quot;);
console.log(&quot;在 main 中，a.done=%j，b.done=%j&quot;, a.done, b.done);</code></pre><p>运行效果为：</p>
<pre><code>silly dog@LAPTOP-OEVDT7RG MINGW64 /e/程序代码/nodejs
$ node main.js
main 开始
a 开始
b 开始
在 b 中，a.done = false
b 结束
在a 中,b.done = true
a 结束
在 main 中，a.done=true，b.done=true

silly dog@LAPTOP-OEVDT7RG MINGW64 /e/程序代码/nodejs</code></pre><p>也就是说当 main.js 加载 a.js 时，a.js 又加载 b.js。此时，b.js 会尝试去加载 a.js。为了防止无限的循环，会返回一个 a.js 的 exports 对象的未完成的副本给 b.js 模块。然后 b.js 完成加载，并将 exports 对象提供给 a.js 模块。</p>
<p>module.exports 和 exports 的区别<br><br>我们发现每次导出接口成员的时候都通过module.exports.xxx = xxx 的方式很麻烦，点儿的太多了。所以，nodejs为了简化你的操作，专门提供了一个变量：exports 等于 module.exports。也就是说在模块中还有这么一句代码<br></p>
<pre><code>var exports = module.exports;</code></pre><p>我们前面案例中的代码也就可以简写了：</p>
<pre><code>module.exports.foo = foo;
exports.foo = foo; // 这两行代码效果是一样的</code></pre><p>但是需要注意的是：就像任何变量，如果一个新的值被赋值给 exports，它就不再绑定到 module.exports。我们具体来看个例子：</p>
<p>a.js 的代码:</p>
<pre><code>console.log(module.exports === exports);</code></pre><p>运行结果</p>
<pre><code>silly dog@LAPTOP-OEVDT7RG MINGW64 /e/程序代码/nodejs
$ node 1.js
true

silly dog@LAPTOP-OEVDT7RG MINGW64 /e/程序代码/nodejs</code></pre><p>两者一致，说明我们可以用任意一个来导出内部成员</p>
<p>b.js 的代码：</p>
<pre><code>exports = {
  a: 3,
};
console.log(exports);
console.log(module.exports);
console.log(exports === module.exports);</code></pre><p>运行结果</p>
<pre><code>silly dog@LAPTOP-OEVDT7RG MINGW64 /e/程序代码/nodejs
$ node 1.js
{ a: 3 }
{}
false

silly dog@LAPTOP-OEVDT7RG MINGW64 /e/程序代码/nodejs</code></pre><p>也就是说给 exports 赋值会断开和 module.exports 之间的引用，同样的给 module.exports 重新赋值也会断开它们之间的引用。但是最终导出的是 module.exports，在上面的例子中我们另外一个文件来用 require() 加载 b.js 只会得到 {} 而不是 {a:3}。</p>
<p>总结：require() 得到的是 module.exports 导出的值，导出多个成员可以用 module.exports 和 exports，导出单个成员只能用 module.exports。如果你实在不好区分，那就全部都使用 module.exports 也是没问题的。</p>
]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>liunx</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js 创建第一个应用</title>
    <url>/2020/05/28/nodejs2/</url>
    <content><![CDATA[<p>  1、引入 required 模块：使用 required 指令来载入 Node.js 模块。<br>  2、创建服务器：服务器可以监听客户端的请求，类似于 Apache、Nginx 等 HTTP 服务器。<br>  3、接受请求与响应请求。</p>
<p>新建一个名为 server.js 的文件</p>
<pre><code>var http = require(&quot;http&quot;); // 加载 http 模块，并将实例化的 HTTP 赋值给变量 http

http
  .createServer(function (request, response) {
    // 发送 HTTP 头部
    // HTTP 状态值: 200 : OK
    // 内容类型: text/plain
    response.writeHead(200, { &quot;Content-Type&quot;: &quot;text/plain&quot; });

    response.end(&quot;Hello World\n&quot;); // 发送响应数据 &quot;Hello World&quot;
  })
  .listen(8080);

// 终端打印如下信息
console.log(&quot;Server running at http://127.0.0.1:8080/&quot;);</code></pre><p>以上代码我们完成了一个可以工作的 HTTP 服务器。本地计算机使用 node server.js 命令后，直接在浏览器中访问 <a href="http://127.0.0.1:8888/，你会看到一个写着" target="_blank" rel="noopener">http://127.0.0.1:8888/，你会看到一个写着</a> “Hello World”的网页</p>
<p>由于我的环境部署在centos系统上，可以直接使用elinks访问，访问结果</p>
<pre><code>[sgsm@iZ2ze53g8gh7cdxahhcv95Z ~]$ elinks  http://127.0.0.1:8080
                                                                                                                  http://127.0.0.1:8080/ 
Hello World     </code></pre>]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>liunx</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>初学nodejs</title>
    <url>/2020/05/28/nodejs1/</url>
    <content><![CDATA[<h2 id="Node-js-概述"><a href="#Node-js-概述" class="headerlink" title="Node.js 概述"></a>Node.js 概述</h2><p>Node.js 是一个能够在服务器端运行 JavaScript 的开放源代码、跨平台 JavaScript 运行环境。Node.js 由 Node.js 基金会持有和维护，并与 Linux 基金会有合作关系。Node.js 采用 Google 开发的 V8 运行代码，使用事件驱动、非阻塞和异步输入输出模型等技术来提高性能，可优化应用程序的传输量和规模。这些技术通常用于数据密集的即时应用程序。</p>
<p>Node.js 大部分基本模块都用 JavaScript 语言编写。在 Node.js 出现之前，JavaScript 通常作为客户端程序设计语言使用，以 JavaScript 写出的程序常在用户的浏览器上运行。Node.js 的出现使 JavaScript 也能用于服务端编程。Node.js 含有一系列内置模块，使得程序可以脱离 Apache HTTP Server 或 IIS，作为独立服务器运行。</p>
<p>注：定义来自维基百科。</p>
<h2 id="Node-js-特点"><a href="#Node-js-特点" class="headerlink" title="Node.js 特点"></a>Node.js 特点</h2><p>  1、它是一个 JavaScript 运行环境。<br>  <br>2、依赖于 Chrome V8 引擎进行代码解释。<br><br>  3、事件驱动：在 Node.js 中，客户端请求建立连接，提交数据等行为，会触发相应的事件。Node.js 在一个时刻，只能执行一个事件回调函数，但是在执行一个事件回调函数的中途，可以转而处理其他事件，然后返回继续执行原事件的回调函数。<br>  <br>4、非阻塞 I/O：Node.js 中采用了非阻塞型 I/O 机制，在执行了访问数据库的代码之后，将立即转而执行其后面的代码，把数据库返回结果的处理代码放在回调函数中，从而提高了程序的执行效率。<br><br>  5、轻量可伸缩，适用于实时数据交互应用。<br>  <br>6、单线程：好处是减少内存开销，不用像多线程编程那样处处在意状态同步的问题。缺点是错误会引起整个应用的退出。<br></p>
<h2 id="Node-js-适用场景"><a href="#Node-js-适用场景" class="headerlink" title="Node.js 适用场景"></a>Node.js 适用场景</h2><p>我们从 Node.js 的特点中可以知道 Node.js 擅长处理 I/O，不善于计算（单线程的缺点），因此 Node.js 适用于：当应用程序需要处理大量并发的 I/O，而在向客户端发出响应之前，应用程序内部并不需要进行非常复杂的处理的时候，Node.js 也非常适合与 Web socket 配合，开发长连接的实时交互应用程序。比如：聊天室，博客系统，考试系统等。</p>
<h2 id="NPM介绍"><a href="#NPM介绍" class="headerlink" title="NPM介绍"></a>NPM介绍</h2><p>npm是随同nodejs一起安装的包管理工具</p>
<p>在中断中查看系统nodejs的版本：</p>
<pre><code>node -v</code></pre><p>查看系统中npm版本</p>
<pre><code>npm  -v</code></pre><h2 id="启动node终端"><a href="#启动node终端" class="headerlink" title="启动node终端"></a>启动node终端</h2><p><br>类似于python的终端，启动node终端直接输入node</p>
<pre><code>node</code></pre><p>基础的计算</p>
<pre><code>&gt; 1 + 1
2
&gt; 2 * 2
4
&gt; 6 / 2
3
&gt; 2+(8*3)-10
16
&gt; </code></pre><p>多行表达式</p>
<pre><code>&gt; for(var i=0; i &lt; 8 ; i++){
... console.log(i);
... }
0
1
2
3
4
5
6
7
undefined
&gt; </code></pre><p>三个点的符号是系统自动生成的，回车换行后即可。Node.js 会自动检测是否为连续的表达式。</p>
<p>下划线变量 – 可以使用下划线（_）获取上一个表达式的运算结果：</p>
<pre><code>&gt; var a = 10 ; var b = 20 ; a + b;
30
&gt; var num = _;
undefined
&gt; console.log(num)
30
undefined
&gt; </code></pre><p>REPL 常用命令</p>
<pre><code>Ctrl + C - 退出当前终端。
Ctrl + C - 连续按两次退出 Node REPL。
Ctrl + D - 退出 Node REPL。
向上/向下键 - 查看输入的历史命令</code></pre><p>运行 JavaScript 文件</p>
<p>新建两个 JavaScript 文件名为为 test.j写下如下代码：</p>
<p>test.js 中的代码：</p>
<pre><code>console.log(&quot;hello world&quot;);</code></pre><p>运行结果</p>
<pre><code>[sgsm@localhost nodejs]$ node  test.js 
hello world</code></pre><h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><p>按照 ECMAScript 的定义，满足以下条件的变量是全局变量：</p>
<pre><code>在最外层定义的变量。
全局对象的属性。
隐式定义的变量（未定义直接赋值的变量）。</code></pre><p>注：当你定义一个全局变量的时候，这个变量同时也会成为全局对象的属性，反之亦然。在 Node.js 中你不可能在最外层定义变量，因为所有用户代码都是属于当前模块的，而模块本身不是最外层上下文。定义变量一定要使用 var 关键字，因为全局变量会污染命名空间。</p>
<p>下面介绍一些常用的全局变量和全局函数：</p>
<p>  __filename 表示当前正在执行的脚本的文件名。它将输出文件所在位置的绝对路径，且和命令行参数所指定的文件名不一定相同。如果在模块中，返回的值是模块文件的路径。比如创建一个叫 fnTest.js 的文件，输入以下代码：</p>
<pre><code>console.log(__filename);</code></pre><p>  运行结果</p>
<pre><code>[sgsm@bogon nodejs]$ node fnTest.js
/home/sgsm/nodejs/fnTest.js</code></pre><p>  __dirname 表示当前执行脚本所在的目录。比如创建一个 dnTest.js 的文件，输入以下代码：</p>
<pre><code>console.log(__dirname);</code></pre><p>  运行结果</p>
<pre><code>[sgsm@bogon nodejs]$ node dnTest.js 
/home/sgsm/nodejs</code></pre><p>  setTimeout(cb, ms) 全局函数在指定的毫秒（ms）数后执行指定函数（cb），只执行一次函数。比如创建一个 st.js 的文件，输入以下代码：</p>
<pre><code>function foo() {
  console.log(&quot;Hello, syl!&quot;);
}
// 三秒后执行以上函数
setTimeout(foo, 3000);</code></pre><p>  运行结果</p>
<pre><code>[sgsm@bogon nodejs]$ node  st.js 
Hello, syl!
[sgsm@bogon nodejs]$</code></pre><p>  clearTimeout(t) 用于停止一个之前通过 setTimeout() 创建的定时器。参数 t 是通过 setTimeout() 函数创建的定时器。比如清除上面案例的定时器：</p>
<pre><code>function foo() {
  console.log(&quot;Hello, syl!&quot;);
}
// 三秒后执行以上函数
var t = setTimeout(foo, 3000);
// 清除定时器
clearTimeout(t);</code></pre><p>  运行结果</p>
<pre><code>[sgsm@bogon nodejs]$ node  st.js 
[sgsm@bogon nodejs]$ </code></pre><p>  setInterval(cb, ms) 与 setTimeout(cb, ms) 类似，不同的是这个方法会不停的执行函数。直到 clearInterval() 被调用或窗口被关闭，也可以按 Ctrl + C 停止。比如创建一个 sI.js 的文件，输入以下代码：</p>
<pre><code>function foo() {
  console.log(&quot;Hello, syl!&quot;);
}
// 三秒后执行以上函数
var t = setInterval(foo, 3000);
// 清除定时器
clearInterval(t);</code></pre><p>  运行结果</p>
<pre><code>[sgsm@bogon nodejs]$ node  st.js 
[sgsm@bogon nodejs]$ </code></pre><p>  如果不加clearInterval的运行结果</p>
<pre><code>[sgsm@iZ2ze53g8gh7cdxahhcv95Z nodejs]$ node st.js 
Hello, syl!
Hello, syl!
Hello, syl!</code></pre><p>  console.log() 是个全局函数用于进行标准输出流的输出，即在控制台中显示一行字符串，和 JavaScript 中的使用一样</p>
]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>liunx</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>centos7设置python3环境</title>
    <url>/2020/05/26/python3huanjing/</url>
    <content><![CDATA[<h2 id="配置yum源-使用阿里云的镜像"><a href="#配置yum源-使用阿里云的镜像" class="headerlink" title="配置yum源-使用阿里云的镜像"></a>配置yum源-使用阿里云的镜像</h2><pre><code>sudo  wget http://mirrors.aliyun.com/repo/Centos-7.repo
sudo  wget http://mirrors.aliyun.com/repo/epel-7.repo
yum clean  all</code></pre><p>安装依赖工具包</p>
<pre><code>sudo  yum -y install zlib-devel bzip2-devel openssl-devel openssl-static ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel libffi-devel lzma gcc</code></pre><h2 id="下载python3-7安装包"><a href="#下载python3-7安装包" class="headerlink" title="下载python3.7安装包"></a>下载python3.7安装包</h2><pre><code>cd /opt/
sudo   wget https://www.python.org/ftp/python/3.7.0/Python-3.7.0.tar.xz</code></pre><p>解压–&gt;配置–&gt;编译–&gt;安装</p>
<pre><code>sudo tar xf  Python-3.7.0.tar.xz    -C /usr/local/
cd  /usr/local/Python-3.7.0/
sudo  ./configure --prefix=/usr/local/sbin/python-3.7
sudo   make &amp;&amp; sudo  make install</code></pre><p>  安装成功会打印</p>
<pre><code>Collecting setuptools
Collecting pip
Installing collected packages: setuptools, pip
Successfully installed pip-10.0.1 setuptools-39.0.1</code></pre><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><pre><code>[sgsm@bogon Python-3.7.0]$ /usr/local/sbin/python-3.7/bin/python3
Python 3.7.0 (default, Jun  3 2020, 23:49:44) 
[GCC 4.8.5 20150623 (Red Hat 4.8.5-39)] on linux
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt; exit()</code></pre><h2 id="创建软连接"><a href="#创建软连接" class="headerlink" title="创建软连接"></a>创建软连接</h2><p><br>查看目前的链接文件<br></p>
<pre><code>[sgsm@bogon Python-3.7.0]$ ll /usr/bin/ |grep python
lrwxrwxrwx.   1 root root           7 4月  13 2017 python -&gt; python2
lrwxrwxrwx.   1 root root           9 4月  13 2017 python2 -&gt; python2.7
-rwxr-xr-x.   1 root root        7136 11月  6 2016 python2.7
-rwxr-xr-x.   1 root root        1835 11月  6 2016 python2.7-config
lrwxrwxrwx.   1 root root          16 4月  13 2017 python2-config -&gt; python2.7-config
lrwxrwxrwx.   1 root root          14 4月  13 2017 python-config -&gt; python2-config</code></pre><p>删除原来的连接文件</p>
<pre><code>sudo rm -rf /usr/bin/python</code></pre><p>创建新的连接文件</p>
<pre><code>sudo  ln -s /usr/local/sbin/python-3.7/bin/python3   /usr/bin/python</code></pre><p>查看现在的版本</p>
<pre><code>[sgsm@bogon Python-3.7.0]$ python -V
Python 3.7.0</code></pre><h2 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h2><p><br>修改完python默认版本之后，会存不能执行yum命令，需要做一些修改，如下<br></p>
<pre><code> 将/usr/bin/yum的顶部的：

!/usr/bin/python  改成  !/usr/bin/python2.7 

将/usr/libexec/urlgrabber-ext-down的顶部的：

/usr/bin/python  改为   /usr/bin/python2.7

将/usr/bin/yum-config-manager的顶部的

#!/usr/bin/python 改为 #!/usr/bin/python2.7 </code></pre><p>最后将pip指向到python3.7</p>
<pre><code>[sgsm@bogon Python-3.7.0]$ sudo ln -s /usr/local/sbin/python-3.7/bin/pip3 /usr/bin/pip 
[sgsm@bogon Python-3.7.0]$ 
[sgsm@bogon Python-3.7.0]$ pip -v
pip 10.0.1 from /usr/local/sbin/python-3.7/lib/python3.7/site-packages/pip (python 3.7)</code></pre>]]></content>
      <categories>
        <category>运维</category>
        <category>开发</category>
      </categories>
      <tags>
        <tag>liunx</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>centos下清除记录的svn用户名和密码</title>
    <url>/2020/05/26/svn-remove-passwd/</url>
    <content><![CDATA[<h2 id="centos下清除记录的svn用户名和密码"><a href="#centos下清除记录的svn用户名和密码" class="headerlink" title="centos下清除记录的svn用户名和密码"></a>centos下清除记录的svn用户名和密码</h2><p><br>由于公司人员的变动，离职人员的svn账号也会被删除，使用之前账号检出的代码执行svn update的时候会显示报错<br></p>
<pre><code>svn: E210005: Unable to connect to a repository at URL &apos;svn://xxx&apos;
svn: E210005: No repository found in &apos;svn://xxx&apos;</code></pre><p>是因为检出代码的是提示是否保存明文密码然后用户选择的yes</p>
<p><br>解决办法<br><br>linux下删除~/.subversion/auth即可清除之前的用户名和密码：</p>
<pre><code>rm -rf ~/.subversion/auth</code></pre><p>以后再操作svn会提示你输入root密码以及svn用户名和密码，这样就可以输入正常的账号密码了</p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>liunx</tag>
        <tag>subversion</tag>
      </tags>
  </entry>
  <entry>
    <title>python-1</title>
    <url>/2020/05/26/python-1/</url>
    <content><![CDATA[<h2 id="双引号和单引号的作用"><a href="#双引号和单引号的作用" class="headerlink" title="双引号和单引号的作用"></a>双引号和单引号的作用</h2><pre><code>str = &quot;我是谁&quot;
print(str)
str1 = &apos;我是&quot;谁&quot;&apos;
print(str1)</code></pre>]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>liunx</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>kube-flannel</title>
    <url>/2020/05/24/kube-flannel/</url>
    <content><![CDATA[<pre><code>---
apiVersion: policy/v1beta1
kind: PodSecurityPolicy
metadata:
  name: psp.flannel.unprivileged
  annotations:
    seccomp.security.alpha.kubernetes.io/allowedProfileNames: docker/default
    seccomp.security.alpha.kubernetes.io/defaultProfileName: docker/default
    apparmor.security.beta.kubernetes.io/allowedProfileNames: runtime/default
    apparmor.security.beta.kubernetes.io/defaultProfileName: runtime/default
spec:
  privileged: false
  volumes:
    - configMap
    - secret
    - emptyDir
    - hostPath
  allowedHostPaths:
    - pathPrefix: &quot;/etc/cni/net.d&quot;
    - pathPrefix: &quot;/etc/kube-flannel&quot;
    - pathPrefix: &quot;/run/flannel&quot;
  readOnlyRootFilesystem: false
  # Users and groups
  runAsUser:
    rule: RunAsAny
  supplementalGroups:
    rule: RunAsAny
  fsGroup:
    rule: RunAsAny
  # Privilege Escalation
  allowPrivilegeEscalation: false
  defaultAllowPrivilegeEscalation: false
  # Capabilities
  allowedCapabilities: [&apos;NET_ADMIN&apos;]
  defaultAddCapabilities: []
  requiredDropCapabilities: []
  # Host namespaces
  hostPID: false
  hostIPC: false
  hostNetwork: true
  hostPorts:
  - min: 0
    max: 65535
  # SELinux
  seLinux:
    # SELinux is unused in CaaSP
    rule: &apos;RunAsAny&apos;
---
kind: ClusterRole
apiVersion: rbac.authorization.k8s.io/v1beta1
metadata:
  name: flannel
rules:
  - apiGroups: [&apos;extensions&apos;]
    resources: [&apos;podsecuritypolicies&apos;]
    verbs: [&apos;use&apos;]
    resourceNames: [&apos;psp.flannel.unprivileged&apos;]
  - apiGroups:
      - &quot;&quot;
    resources:
      - pods
    verbs:
      - get
  - apiGroups:
      - &quot;&quot;
    resources:
      - nodes
    verbs:
      - list
      - watch
  - apiGroups:
      - &quot;&quot;
    resources:
      - nodes/status
    verbs:
      - patch
---
kind: ClusterRoleBinding
apiVersion: rbac.authorization.k8s.io/v1beta1
metadata:
  name: flannel
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: flannel
subjects:
- kind: ServiceAccount
  name: flannel
  namespace: kube-system
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: flannel
  namespace: kube-system
---
kind: ConfigMap
apiVersion: v1
metadata:
  name: kube-flannel-cfg
  namespace: kube-system
  labels:
    tier: node
    app: flannel
data:
  cni-conf.json: |
    {
      &quot;name&quot;: &quot;cbr0&quot;,
      &quot;cniVersion&quot;: &quot;0.3.1&quot;,
      &quot;plugins&quot;: [
        {
          &quot;type&quot;: &quot;flannel&quot;,
          &quot;delegate&quot;: {
            &quot;hairpinMode&quot;: true,
            &quot;isDefaultGateway&quot;: true
          }
        },
        {
          &quot;type&quot;: &quot;portmap&quot;,
          &quot;capabilities&quot;: {
            &quot;portMappings&quot;: true
          }
        }
      ]
    }
  net-conf.json: |
    {
      &quot;Network&quot;: &quot;10.244.0.0/16&quot;,
      &quot;Backend&quot;: {
        &quot;Type&quot;: &quot;vxlan&quot;
      }
    }
---
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: kube-flannel-ds-amd64
  namespace: kube-system
  labels:
    tier: node
    app: flannel
spec:
  selector:
    matchLabels:
      app: flannel
  template:
    metadata:
      labels:
        tier: node
        app: flannel
    spec:
      affinity:
        nodeAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
            nodeSelectorTerms:
              - matchExpressions:
                  - key: kubernetes.io/os
                    operator: In
                    values:
                      - linux
                  - key: kubernetes.io/arch
                    operator: In
                    values:
                      - amd64
      hostNetwork: true
      tolerations:
      - operator: Exists
        effect: NoSchedule
      serviceAccountName: flannel
      initContainers:
      - name: install-cni
        image: quay.io/coreos/flannel:v0.12.0-amd64
        command:
        - cp
        args:
        - -f
        - /etc/kube-flannel/cni-conf.json
        - /etc/cni/net.d/10-flannel.conflist
        volumeMounts:
        - name: cni
          mountPath: /etc/cni/net.d
        - name: flannel-cfg
          mountPath: /etc/kube-flannel/
      containers:
      - name: kube-flannel
        image: quay.io/coreos/flannel:v0.12.0-amd64
        command:
        - /opt/bin/flanneld
        args:
        - --ip-masq
        - --kube-subnet-mgr
        resources:
          requests:
            cpu: &quot;100m&quot;
            memory: &quot;50Mi&quot;
          limits:
            cpu: &quot;100m&quot;
            memory: &quot;50Mi&quot;
        securityContext:
          privileged: false
          capabilities:
            add: [&quot;NET_ADMIN&quot;]
        env:
        - name: POD_NAME
          valueFrom:
            fieldRef:
              fieldPath: metadata.name
        - name: POD_NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
        volumeMounts:
        - name: run
          mountPath: /run/flannel
        - name: flannel-cfg
          mountPath: /etc/kube-flannel/
      volumes:
        - name: run
          hostPath:
            path: /run/flannel
        - name: cni
          hostPath:
            path: /etc/cni/net.d
        - name: flannel-cfg
          configMap:
            name: kube-flannel-cfg
---
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: kube-flannel-ds-arm64
  namespace: kube-system
  labels:
    tier: node
    app: flannel
spec:
  selector:
    matchLabels:
      app: flannel
  template:
    metadata:
      labels:
        tier: node
        app: flannel
    spec:
      affinity:
        nodeAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
            nodeSelectorTerms:
              - matchExpressions:
                  - key: kubernetes.io/os
                    operator: In
                    values:
                      - linux
                  - key: kubernetes.io/arch
                    operator: In
                    values:
                      - arm64
      hostNetwork: true
      tolerations:
      - operator: Exists
        effect: NoSchedule
      serviceAccountName: flannel
      initContainers:
      - name: install-cni
        image: quay.io/coreos/flannel:v0.12.0-arm64
        command:
        - cp
        args:
        - -f
        - /etc/kube-flannel/cni-conf.json
        - /etc/cni/net.d/10-flannel.conflist
        volumeMounts:
        - name: cni
          mountPath: /etc/cni/net.d
        - name: flannel-cfg
          mountPath: /etc/kube-flannel/
      containers:
      - name: kube-flannel
        image: quay.io/coreos/flannel:v0.12.0-arm64
        command:
        - /opt/bin/flanneld
        args:
        - --ip-masq
        - --kube-subnet-mgr
        resources:
          requests:
            cpu: &quot;100m&quot;
            memory: &quot;50Mi&quot;
          limits:
            cpu: &quot;100m&quot;
            memory: &quot;50Mi&quot;
        securityContext:
          privileged: false
          capabilities:
            add: [&quot;NET_ADMIN&quot;]
        env:
        - name: POD_NAME
          valueFrom:
            fieldRef:
              fieldPath: metadata.name
        - name: POD_NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
        volumeMounts:
        - name: run
          mountPath: /run/flannel
        - name: flannel-cfg
          mountPath: /etc/kube-flannel/
      volumes:
        - name: run
          hostPath:
            path: /run/flannel
        - name: cni
          hostPath:
            path: /etc/cni/net.d
        - name: flannel-cfg
          configMap:
            name: kube-flannel-cfg
---
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: kube-flannel-ds-arm
  namespace: kube-system
  labels:
    tier: node
    app: flannel
spec:
  selector:
    matchLabels:
      app: flannel
  template:
    metadata:
      labels:
        tier: node
        app: flannel
    spec:
      affinity:
        nodeAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
            nodeSelectorTerms:
              - matchExpressions:
                  - key: kubernetes.io/os
                    operator: In
                    values:
                      - linux
                  - key: kubernetes.io/arch
                    operator: In
                    values:
                      - arm
      hostNetwork: true
      tolerations:
      - operator: Exists
        effect: NoSchedule
      serviceAccountName: flannel
      initContainers:
      - name: install-cni
        image: quay.io/coreos/flannel:v0.12.0-arm
        command:
        - cp
        args:
        - -f
        - /etc/kube-flannel/cni-conf.json
        - /etc/cni/net.d/10-flannel.conflist
        volumeMounts:
        - name: cni
          mountPath: /etc/cni/net.d
        - name: flannel-cfg
          mountPath: /etc/kube-flannel/
      containers:
      - name: kube-flannel
        image: quay.io/coreos/flannel:v0.12.0-arm
        command:
        - /opt/bin/flanneld
        args:
        - --ip-masq
        - --kube-subnet-mgr
        resources:
          requests:
            cpu: &quot;100m&quot;
            memory: &quot;50Mi&quot;
          limits:
            cpu: &quot;100m&quot;
            memory: &quot;50Mi&quot;
        securityContext:
          privileged: false
          capabilities:
            add: [&quot;NET_ADMIN&quot;]
        env:
        - name: POD_NAME
          valueFrom:
            fieldRef:
              fieldPath: metadata.name
        - name: POD_NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
        volumeMounts:
        - name: run
          mountPath: /run/flannel
        - name: flannel-cfg
          mountPath: /etc/kube-flannel/
      volumes:
        - name: run
          hostPath:
            path: /run/flannel
        - name: cni
          hostPath:
            path: /etc/cni/net.d
        - name: flannel-cfg
          configMap:
            name: kube-flannel-cfg
---
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: kube-flannel-ds-ppc64le
  namespace: kube-system
  labels:
    tier: node
    app: flannel
spec:
  selector:
    matchLabels:
      app: flannel
  template:
    metadata:
      labels:
        tier: node
        app: flannel
    spec:
      affinity:
        nodeAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
            nodeSelectorTerms:
              - matchExpressions:
                  - key: kubernetes.io/os
                    operator: In
                    values:
                      - linux
                  - key: kubernetes.io/arch
                    operator: In
                    values:
                      - ppc64le
      hostNetwork: true
      tolerations:
      - operator: Exists
        effect: NoSchedule
      serviceAccountName: flannel
      initContainers:
      - name: install-cni
        image: quay.io/coreos/flannel:v0.12.0-ppc64le
        command:
        - cp
        args:
        - -f
        - /etc/kube-flannel/cni-conf.json
        - /etc/cni/net.d/10-flannel.conflist
        volumeMounts:
        - name: cni
          mountPath: /etc/cni/net.d
        - name: flannel-cfg
          mountPath: /etc/kube-flannel/
      containers:
      - name: kube-flannel
        image: quay.io/coreos/flannel:v0.12.0-ppc64le
        command:
        - /opt/bin/flanneld
        args:
        - --ip-masq
        - --kube-subnet-mgr
        resources:
          requests:
            cpu: &quot;100m&quot;
            memory: &quot;50Mi&quot;
          limits:
            cpu: &quot;100m&quot;
            memory: &quot;50Mi&quot;
        securityContext:
          privileged: false
          capabilities:
            add: [&quot;NET_ADMIN&quot;]
        env:
        - name: POD_NAME
          valueFrom:
            fieldRef:
              fieldPath: metadata.name
        - name: POD_NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
        volumeMounts:
        - name: run
          mountPath: /run/flannel
        - name: flannel-cfg
          mountPath: /etc/kube-flannel/
      volumes:
        - name: run
          hostPath:
            path: /run/flannel
        - name: cni
          hostPath:
            path: /etc/cni/net.d
        - name: flannel-cfg
          configMap:
            name: kube-flannel-cfg
---
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: kube-flannel-ds-s390x
  namespace: kube-system
  labels:
    tier: node
    app: flannel
spec:
  selector:
    matchLabels:
      app: flannel
  template:
    metadata:
      labels:
        tier: node
        app: flannel
    spec:
      affinity:
        nodeAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
            nodeSelectorTerms:
              - matchExpressions:
                  - key: kubernetes.io/os
                    operator: In
                    values:
                      - linux
                  - key: kubernetes.io/arch
                    operator: In
                    values:
                      - s390x
      hostNetwork: true
      tolerations:
      - operator: Exists
        effect: NoSchedule
      serviceAccountName: flannel
      initContainers:
      - name: install-cni
        image: quay.io/coreos/flannel:v0.12.0-s390x
        command:
        - cp
        args:
        - -f
        - /etc/kube-flannel/cni-conf.json
        - /etc/cni/net.d/10-flannel.conflist
        volumeMounts:
        - name: cni
          mountPath: /etc/cni/net.d
        - name: flannel-cfg
          mountPath: /etc/kube-flannel/
      containers:
      - name: kube-flannel
        image: quay.io/coreos/flannel:v0.12.0-s390x
        command:
        - /opt/bin/flanneld
        args:
        - --ip-masq
        - --kube-subnet-mgr
        resources:
          requests:
            cpu: &quot;100m&quot;
            memory: &quot;50Mi&quot;
          limits:
            cpu: &quot;100m&quot;
            memory: &quot;50Mi&quot;
        securityContext:
          privileged: false
          capabilities:
            add: [&quot;NET_ADMIN&quot;]
        env:
        - name: POD_NAME
          valueFrom:
            fieldRef:
              fieldPath: metadata.name
        - name: POD_NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
        volumeMounts:
        - name: run
          mountPath: /run/flannel
        - name: flannel-cfg
          mountPath: /etc/kube-flannel/
      volumes:
        - name: run
          hostPath:
            path: /run/flannel
        - name: cni
          hostPath:
            path: /etc/cni/net.d
        - name: flannel-cfg
          configMap:
            name: kube-flannel-cfg</code></pre>]]></content>
  </entry>
  <entry>
    <title>kubernetes-1.18.2常见报错--持续更新</title>
    <url>/2020/05/24/error/</url>
    <content><![CDATA[<h2 id="初始化时端口已经启动"><a href="#初始化时端口已经启动" class="headerlink" title="初始化时端口已经启动"></a>初始化时端口已经启动</h2><pre><code>[root@k8s-master01 ~]# kubeadm init --config config.yaml

[init] Using Kubernetes version: v1.10.0
[init] Using Authorization modes: [Node RBAC]
[preflight] Running pre-flight checks.
[preflight] Some fatal errors occurred:
        [ERROR Port-6443]: Port 6443 is in use
        [ERROR Port-10250]: Port 10250 is in use
        [ERROR Port-10251]: Port 10251 is in use
        [ERROR Port-10252]: Port 10252 is in use
        [ERROR FileAvailable--etc-kubernetes-manifests-kube-apiserver.yaml]: /etc/kubernetes/manifests/kube-apiserver.yaml already exists
        [ERROR FileAvailable--etc-kubernetes-manifests-kube-controller-manager.yaml]: /etc/kubernetes/manifests/kube-controller-manager.yaml already exists
        [ERROR FileAvailable--etc-kubernetes-manifests-kube-scheduler.yaml]: /etc/kubernetes/manifests/kube-scheduler.yaml already exists
[preflight] If you know what you are doing, you can make a check non-fatal with `--ignore-preflight-errors=...`



解决方案：发现杀死进程都没有用，最终重启一下kubeadm就可以了，如下：

[root@k8s-master01 ~]# kubeadm reset</code></pre><h2 id="无法拉取镜像"><a href="#无法拉取镜像" class="headerlink" title="无法拉取镜像"></a>无法拉取镜像</h2><p>使用kubeadm配置文件，通过在配置文件中指定docker仓库地址，便于内网快速部署。</p>
<p>生成配置文件</p>
<pre><code>kubeadm config print init-defaults ClusterConfiguration &gt;kubeadm.conf</code></pre><p>修改kubeadm.conf</p>
<pre><code>vi kubeadm.conf
修改 imageRepository: k8s.gcr.io
改为 registry.aliyuncs.com/google_containers
imageRepository: registry.aliyuncs.com/google_containers
修改kubernetes版本kubernetesVersion: v1.13.0
改为kubernetesVersion: v1.18.2
kubernetesVersion: v1.18.2</code></pre><p>  再次查看kubeadm config所需的镜像</p>
<pre><code>[root@master01 ~]# kubeadm config images list --config kubeadm.conf
W0524 14:25:08.505708   14715 configset.go:202] WARNING: kubeadm cannot validate component configs for API groups [kubelet.config.k8s.io kubeproxy.config.k8s.io]
registry.aliyuncs.com/google_containers/kube-apiserver:v1.18.2
registry.aliyuncs.com/google_containers/kube-controller-manager:v1.18.2
registry.aliyuncs.com/google_containers/kube-scheduler:v1.18.2
registry.aliyuncs.com/google_containers/kube-proxy:v1.18.2
registry.aliyuncs.com/google_containers/pause:3.2
registry.aliyuncs.com/google_containers/etcd:3.4.3-0
registry.aliyuncs.com/google_containers/coredns:1.6.7</code></pre><p>拉取镜像并初始化</p>
<pre><code>kubeadm config images pull --config kubeadm.conf

kubeadm init --kubernetes-version=1.18.2 --apiserver-advertise-address=192.168.1.100  --image-repository registry.aliyuncs.com/google_containers  --service-cidr=10.10.0.0/16 --pod-network-cidr=10.122.0.0/16  </code></pre><h2 id="初始化报错"><a href="#初始化报错" class="headerlink" title="初始化报错"></a>初始化报错</h2><pre><code>W0523 10:11:56.806416  112153 configset.go:202] WARNING: kubeadm cannot validate component configs for API groups [kubelet.config.k8s.io kubeproxy.config.k8s.io]
[init] Using Kubernetes version: v1.18.3
[preflight] Running pre-flight checks
error execution phase preflight: [preflight] Some fatal errors occurred:
        [ERROR DirAvailable--var-lib-etcd]: /var/lib/etcd is not empty
[preflight] If you know what you are doing, you can make a check non-fatal with `--ignore-preflight-errors=...`</code></pre><p>删除文件</p>
<pre><code>rm -rf /var/lib/etcd</code></pre><p>就可以继续初始化了</p>
<h2 id="无法下载flannel网络插件"><a href="#无法下载flannel网络插件" class="headerlink" title="无法下载flannel网络插件"></a>无法下载flannel网络插件</h2><pre><code>[root@master01 ~]# wget https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml
--2020-05-24 14:32:30--  https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml
正在解析主机 raw.githubusercontent.com (raw.githubusercontent.com)... 0.0.0.0, ::
正在连接 raw.githubusercontent.com (raw.githubusercontent.com)|0.0.0.0|:443... 失败：拒绝连接。
正在连接 raw.githubusercontent.com (raw.githubusercontent.com)|::|:443... 失败：拒绝连接。

[root@master01 ~]# kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml
The connection to the server raw.githubusercontent.com was refused - did you specify the right host or port?</code></pre><p>  如果无法访问网站需要手动创建文件    kube-flannel.yaml<br>  <br>由于内容太长保存在下面网站中：<br><br>    <a href="https://xinlong.youare.ink/2020/05/24/kube-flannel/" target="_blank" rel="noopener">https://xinlong.youare.ink/2020/05/24/kube-flannel/</a><br>  <br>然后执行<br></p>
<pre><code>kubectl apply -f kube-flannel.yaml</code></pre><p>  稍等几秒后使用如下命令确认其输出结果中Pod的状态为“Running”，</p>
<pre><code>kubectl get pods -n kube-system -l app=flannel</code></pre><p>  类似如下所示：</p>
<pre><code>NAME READY STATUS RESTARTS AGE

kube-flannel-ds-amd64-wscnz 1/1 Running 0 14m</code></pre><p>  验正master节点已经就绪</p>
<pre><code>kubectl get nodes</code></pre><p>  上述命令应该会得到类似如下输出：</p>
<pre><code>NAME STATUS ROLES AGE VERSION

master01.ilinux.io Ready master 4m9s v1.12.1</code></pre><h2 id="添加node节点报错"><a href="#添加node节点报错" class="headerlink" title="添加node节点报错"></a>添加node节点报错</h2><p>node节点报错<br>    [root@node01 yum.repos.d]# kubectl get node<br>    The connection to the server localhost:8080 was refused - did you specify the right host or port?    </p>
<pre><code>kubeadm join 192.168.1.100:6443 --token 946w2y.xhj1wukp35zu6ppb     --discovery-token-ca-cert-hash sha256:93253b79ac5f2a3f32ee7d76e4d7d75cb2bbcd9190132a931c7ea5d5985521a1         </code></pre><p>在node上执行kubeadm join后 在master服务器查询状态为 NotReady 在node上查询报错为上述日志<br><br>解决办法：<br></p>
<p>在node服务器上执行scp  把master上的admin.conf文件拉取到/etc/kubernetes/admin.conf             </p>
<pre><code>scp root@192.168.1.100:/etc/kubernetes/admin.conf /etc/kubernetes/admin.conf             </code></pre><p>设置环境变量</p>
<pre><code>export KUBECONFIG=/etc/kubernetes/admin.conf </code></pre><p>再次执行 kubectl get node </p>
<pre><code>[root@node01 yum.repos.d]# kubectl get node 
NAME       STATUS   ROLES    AGE     VERSION
master01   Ready    master   7h58m   v1.18.3
master02   Ready    &lt;none&gt;   14m     v1.18.3</code></pre><p>master执行 kubectl get node </p>
<pre><code>[root@master01 ~]# kubectl get nodes
NAME       STATUS   ROLES    AGE     VERSION
master01   Ready    master   7h58m   v1.18.3
master02   Ready    &lt;none&gt;   14m     v1.18.3</code></pre>]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>liunx</tag>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>使用kubeadm安装kubernetes</title>
    <url>/2020/05/22/kubeadm/</url>
    <content><![CDATA[<p>Kubernetes技术已经成为了原生云技术的事实标准，它是目前基础软件领域最为热门的分布式调度和管理平台。于是，Kubernetes也几乎成了时下开发工程师和运维工程师必备的技能之一。</p>
<h2 id="一、主机环境预设"><a href="#一、主机环境预设" class="headerlink" title="一、主机环境预设"></a>一、主机环境预设</h2><p>1、测试环境说明</p>
<p>  测试使用的Kubernetes集群可由一个master主机及一个以上（建议至少两个）node主机组成，这些主机可以是物理服务器，也可以运行于vmware、virtualbox或kvm等虚拟化平台上的虚拟机，甚至是公有云上的VPS主机。</p>
<p>  本测试环境将由master01、node01和node02三个独立的主机组成，它们分别拥有4核心的CPU及4G的内存资源，操作系统环境均为CentOS 7.5 1804，域名为ilinux.io。此外，需要预设的系统环境如下：</p>
<p>   （1）借助于NTP服务设定各节点时间精确同步；</p>
<p>  （2）通过DNS完成各节点的主机名称解析，测试环境主机数量较少时也可以使用hosts文件进行；</p>
<p>  （3）关闭各节点的iptables或firewalld服务，并确保它们被禁止随系统引导过程启动；</p>
<p>  （4）各节点禁用SELinux；</p>
<p>  （5）各节点禁用所有的Swap设备；</p>
<p>  （6）若要使用ipvs模型的proxy，各节点还需要载入ipvs相关的各模块；</p>
<p>2、设定时钟同步</p>
<p>  若节点可直接访问互联网，直接启动chronyd系统服务，并设定其随系统引导而启动。</p>
<pre><code>systemctl start chronyd.service

systemctl enable chronyd.service</code></pre><p>  不过，建议用户配置使用本地的的时间服务器，在节点数量众多时尤其如此。存在可用的本地时间服务器时，修改节点的/etc/crhony.conf配置文件，并将时间服务器指向相应的主机即可，配置格式如下：</p>
<pre><code>server CHRONY-SERVER-NAME-OR-IP iburst</code></pre><p>  或者使用ntpdate</p>
<pre><code>yum -y install wget vim net-tools ntpdate
ntpdate time.pool.aliyun.com</code></pre><p>3、主机名称解析</p>
<p>  出于简化配置步骤的目的，本测试环境使用hosts文件进行各节点名称解析，文件内容如下所示：</p>
<pre><code>[root@master01 ~]# cat /etc/hosts
127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
::1         localhost localhost.localdomain localhost6 localhost6.localdomain6
192.168.1.100 master01

192.168.1.101 node1

192.168.1.102 node2</code></pre><p>4、关闭iptables或firewalld服务</p>
<p>  在CentOS7上，iptables或firewalld服务通常只会安装并启动一种，在不确认具体启动状态的前提下，这里通过同时关闭并禁用二者即可简单达到设定目标。</p>
<pre><code>systemctl stop firewalld.service

systemctl stop iptables.service

systemctl disable firewalld.service

systemctl disable iptables.service</code></pre><p>5、关闭并禁用SELinux</p>
<p>  若当前启用了SELinux，则需要编辑/etc/sysconfig/selinux文件,禁用SELinux，并临时设置其当前状态为permissive：</p>
<pre><code>sed -i ‘s@^\(SELINUX=\).*@\1disabled@‘  /etc/sysconfig/selinux

setenforce 0</code></pre><p>6、禁用Swap设备</p>
<p>  部署集群时，kubeadm默认会预先检查当前主机是否禁用了Swap设备，并在未禁用时强制终止部署过程。因此，在主机内存资源充裕的条件下，需要禁用所有的Swap设备，否则，就需要在后文的kubeadm init及kubeadm join命令执行时额外使用相关的选项忽略检查错误。</p>
<p>  关闭Swap设备，需要分两步完成。首先是关闭当前已启用的所有Swap设备：</p>
<pre><code>swapoff -a</code></pre><p>  而后编辑/etc/fstab配置文件，注释用于挂载Swap设备的所有行。</p>
<p>7、启用ipvs内核模块</p>
<p>  创建内核模块载入相关的脚本文件/etc/sysconfig/modules/ipvs.modules，设定自动载入的内核模块。文件内容如下：</p>
<pre><code>#!/bin/bash

ipvs_modules_dir=&quot;/usr/lib/modules/$(uname -r)/kernel/net/netfilter/ipvs&quot;

for i in $(ls $ipvs_modules_dir | sed -r ‘s@(.*).ko.xz@\1@‘); do

/sbin/modinfo -F filename $i &amp;&gt; /dev/null

if [ $? -eq 0 ]; then

/sbin/modprobe $i

fi

done</code></pre><p>  修改文件权限，并手动为当前系统加载内核模块：</p>
<pre><code>chmod +x /etc/sysconfig/modules/ipvs.modules

bash /etc/sysconfig/modules/ipvs.modules</code></pre><p>8、master对node节点ssh互信</p>
<pre><code>ssh-keygen
ssh-copy-id node01
ssh-copy-id node02</code></pre><h2 id="二、安装程序包（在各主机上完成如下设定）"><a href="#二、安装程序包（在各主机上完成如下设定）" class="headerlink" title="二、安装程序包（在各主机上完成如下设定）"></a>二、安装程序包（在各主机上完成如下设定）</h2><p>1、生成yum仓库配置</p>
<p>  首先获取docker-ce的配置仓库配置文件：</p>
<pre><code> yum install wget  -y
wget https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo -O /etc/yum.repos.d/docker.repo</code></pre><p>  而后手动生成kubernetes的yum仓库配置文件/etc/yum.repos.d/kubernetes.repo，内容如下：</p>
<pre><code>[kubernetes]
name=Kubernetes
baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/
gpgcheck=1
gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg
enabled=1</code></pre><p>2、安装相关的程序包</p>
<p>  Kubernetes会对经过充分验正的Docker程序版本进行认证，目前认证完成的最高版本是17.03，但docker-ce的最新版本已经高出了几个版本号。管理员可忽略此认证而直接使用最新版本的docker-ce程序，不过，建议根据后面的说明，将安装命令替换为安装17.03版。</p>
<pre><code>yum install docker-ce

yum install kubelet kubeadm kubectl</code></pre><p>  如果要安装目前经过Kubernetes认证的docker-17版本，可以将上面第一条安装命令替换为如下命令：</p>
<pre><code>yum install -y --setopt=obsoletes=0 docker-ce-17.03.2.ce docker-ce-selinux-17.03.2.ce</code></pre><h2 id="三、配置并启动docker服务（在各节点执行）"><a href="#三、配置并启动docker服务（在各节点执行）" class="headerlink" title="三、配置并启动docker服务（在各节点执行）"></a>三、配置并启动docker服务（在各节点执行）</h2><p>安装组件的几种方法：</p>
<p>1、从阿里云镜像仓库拉取镜像</p>
<pre><code>docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/kube-apiserver:v1.13.0      </code></pre><p>  修改镜像tag</p>
<pre><code>docker tag  registry.cn-hangzhou.aliyuncs.com/google_containers/kube-apiserver:v1.13.0  k8s.gcr.io/kube-apiserver:v1.13.0
docker images</code></pre><p>  使用docker pull镜像后  就不用修改代理配置了<br> <br> 批量修改脚本： <br> </p>
<pre><code>#!/bin/bash
KUBE_VERSION=v1.13.0
KUBE_PAUSE_VERSION=3.1
ETCD_VERSION=3.1.12
DNS_VERSION=1.14.8
GCR_URL=k8s.gcr.io
ALIYUN_URL=registry.cn-shenzhen.aliyuncs.com/cookcodeblog
images=(kube-proxy:${KUBE_VERSION}
kube-scheduler:${KUBE_VERSION}
kube-controller-manager:${KUBE_VERSION}
kube-apiserver:${KUBE_VERSION}
pause:${KUBE_PAUSE_VERSION}
etcd:${ETCD_VERSION}
k8s-dns-sidecar:${DNS_VERSION}
k8s-dns-kube-dns:${DNS_VERSION}
k8s-dns-dnsmasq-nanny:${DNS_VERSION})


for imageName in ${images[@]} ; do
  docker pull $ALIYUN_URL/$imageName
  docker tag  $ALIYUN_URL/$imageName $GCR_URL/$imageName
  docker rmi $ALIYUN_URL/$imageName
done

docker images</code></pre><p>2、若要通过默认的k8s.gcr.io镜像仓库获取Kubernetes系统组件的相关镜像，需要配置docker Unit  #File（/usr/lib/systemd/system/docker.service文件）中的Environment变量，为其定义合用的HTTPS_PROXY，格式如下：</p>
<pre><code>Environment=&quot;HTTPS_PROXY=PROTOCOL://HOST:PORT&quot;

Environment=&quot;NO_PROXY=172.20.0.0/16,127.0.0.0/8&quot;</code></pre><p>  如果没有国外的服务器最好还是先使用docker pull下镜像 然后修改</p>
<p>3、生成配置文件</p>
<pre><code>kubeadm config print init-defaults ClusterConfiguration &gt;kubeadm.conf  </code></pre><p>  修改kubeadm.conf</p>
<pre><code>  vi kubeadm.conf
# 修改 imageRepository: k8s.gcr.io
# 改为 registry.aliyuncs.com/google_containers
imageRepository: registry.aliyuncs.com/google_containers
# 修改kubernetes版本kubernetesVersion: v1.13.0
# 改为kubernetesVersion: v1.18.2
kubernetesVersion: v1.18.2</code></pre><p>  查看所以下载的镜像</p>
<pre><code>kubeadm config images list --config kubeadm.conf

  W0524 14:25:08.505708   14715 configset.go:202] WARNING: kubeadm cannot validate component configs for API groups [kubelet.config.k8s.io kubeproxy.config.k8s.io]
  registry.aliyuncs.com/google_containers/kube-apiserver:v1.18.2
  registry.aliyuncs.com/google_containers/kube-controller-manager:v1.18.2
  registry.aliyuncs.com/google_containers/kube-scheduler:v1.18.2
  registry.aliyuncs.com/google_containers/kube-proxy:v1.18.2
  registry.aliyuncs.com/google_containers/pause:3.2
  registry.aliyuncs.com/google_containers/etcd:3.4.3-0
  registry.aliyuncs.com/google_containers/coredns:1.6.7</code></pre><p>  拉取镜像</p>
<pre><code>kubeadm config images pull --config kubeadm.conf</code></pre><p>4、初始化的时候指定镜像库 – 个人推荐这种方式比较简单<br><br>例如：<br></p>
<pre><code>kubeadm init --kubernetes-version=1.18.2 --apiserver-advertise-address=192.168.1.100  --image-repository registry.aliyuncs.com/google_containers  --service-cidr=10.10.0.0/16 --pod-network-cidr=10.122.0.0/16  </code></pre><p>  另外，docker自1.13版起会自动设置iptables的FORWARD默认策略为DROP，这可能会影响Kubernetes集群依赖的报文转发功能，因此，需要在docker服务启动后，重新将FORWARD链的默认策略设备为ACCEPT，方式是修改/usr/lib/systemd/system/docker.service文件，在“ExecStart=/usr/bin/dockerd”一行之后新增一行如下内容：</p>
<pre><code>ExecStartPost=/usr/sbin/iptables -P FORWARD ACCEPT</code></pre><p>  重载完成后即可启动docker服务：</p>
<pre><code>systemctl daemon-reload

systemctl start docker.service</code></pre><p>  而后设定docker和kubelet随系统引导自动启动：</p>
<pre><code>systemctl enable docker kubelet</code></pre><h2 id="四、初始化主节点（在master01上完成如下操作）"><a href="#四、初始化主节点（在master01上完成如下操作）" class="headerlink" title="四、初始化主节点（在master01上完成如下操作）"></a>四、初始化主节点（在master01上完成如下操作）</h2><p>1、初始化init</p>
<pre><code>kubeadm init --kubernetes-version=1.18.2 --apiserver-advertise-address=192.168.1.100  --image-repository registry.aliyuncs.com/google_containers  --service-cidr=10.10.0.0/16 --pod-network-cidr=10.122.0.0/16  </code></pre><p>  master初始化日志</p>
<pre><code>[mark-control-plane] Marking the node master01 as control-plane by adding the taints [node-role.kubernetes.io/master:NoSchedule]
[bootstrap-token] Using token: 946w2y.xhj1wukp35zu6ppb
[bootstrap-token] Configuring bootstrap tokens, cluster-info ConfigMap, RBAC Roles
[bootstrap-token] configured RBAC rules to allow Node Bootstrap tokens to get nodes
[bootstrap-token] configured RBAC rules to allow Node Bootstrap tokens to post CSRs in order for nodes to get long term certificate credentials
[bootstrap-token] configured RBAC rules to allow the csrapprover controller automatically approve CSRs from a Node Bootstrap Token
[bootstrap-token] configured RBAC rules to allow certificate rotation for all node client certificates in the cluster
[bootstrap-token] Creating the &quot;cluster-info&quot; ConfigMap in the &quot;kube-public&quot; namespace
[kubelet-finalize] Updating &quot;/etc/kubernetes/kubelet.conf&quot; to point to a rotatable kubelet client certificate and key
[addons] Applied essential addon: CoreDNS
[addons] Applied essential addon: kube-proxy

Your Kubernetes control-plane has initialized successfully!

To start using your cluster, you need to run the following as a regular user:

  mkdir -p $HOME/.kube
  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
  sudo chown $(id -u):$(id -g) $HOME/.kube/config

You should now deploy a pod network to the cluster.
Run &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at:
  https://kubernetes.io/docs/concepts/cluster-administration/addons/

Then you can join any number of worker nodes by running the following on each as root:

kubeadm join 192.168.1.100:6443 --token 946w2y.xhj1wukp35zu6ppb \
    --discovery-token-ca-cert-hash sha256:93253b79ac5f2a3f32ee7d76e4d7d75cb2bbcd9190132a931c7ea5d5985521a1 </code></pre><p>  上面master初始化的日志需要保留   token值创建node节点的时候需要用到</p>
<p>2、初始化kubectl</p>
<p>  kubectl是kube-apiserver的命令行客户端程序，实现了除系统部署之外的几乎全部的管理操作，是kubernetes管理员使用最多的命令之一。kubectl需经由API server认证及授权后方能执行相应的管理操作，kubeadm部署的集群为其生成了一个具有管理员权限的认证配置文件/etc/kubernetes/admin.conf，它可由kubectl通过默认的“$HOME/.kube/config”的路径进行加载。当然，用户也可在kubectl命令上使用–kubeconfig选项指定一个别的位置。</p>
<p>  下面复制认证为Kubernetes系统管理员的配置文件至目标用户（例如当前用户root）的家目录下：</p>
<pre><code>mkdir -p $HOME/.kube
cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
chown $(id -u):$(id -g) $HOME/.kube/config</code></pre><p>  而后，即可通过kubectl进行客户端命令测试，并借此了解集群组件的当前状态：</p>
<pre><code>kubectl get componentstatus</code></pre><p>一个正常的输出应该类似如下输出结果所示：</p>
<pre><code>NAME STATUS MESSAGE ERROR

controller-manager Healthy ok

scheduler Healthy ok

etcd-0 Healthy {&quot;health&quot;: &quot;true&quot;}</code></pre><p>3、添加flannel网络附件  </p>
<p>  Kubernetes系统上Pod网络的实现依赖于第三方插件进行，这类插件有近数十种之多，较为著名的有flannel、calico、canal和kube-router等，简单易用的实现是为CoreOS提供的flannel项目。下面的命令用于在线部署flannel至Kubernetes系统之上：</p>
<pre><code>kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</code></pre><p>  如果无法访问网站需要手动创建文件    kube-flannel.yaml<br>  <br>由于内容太长保存在下面网站中：<br><br>    <a href="https://xinlong.youare.ink/2020/05/24/kube-flannel/" target="_blank" rel="noopener">https://xinlong.youare.ink/2020/05/24/kube-flannel/</a><br>  <br>然后执行<br></p>
<pre><code>kubectl apply -f kube-flannel.yaml</code></pre><p>  稍等几秒后使用如下命令确认其输出结果中Pod的状态为“Running”，</p>
<pre><code>kubectl get pods -n kube-system -l app=flannel</code></pre><p>  类似如下所示：</p>
<pre><code>NAME READY STATUS RESTARTS AGE

kube-flannel-ds-amd64-wscnz 1/1 Running 0 14m</code></pre><p>4、验正master节点已经就绪</p>
<pre><code>kubectl get nodes</code></pre><p>  上述命令应该会得到类似如下输出：</p>
<pre><code>NAME STATUS ROLES AGE VERSION

master01.ilinux.io Ready master 4m9s v1.12.1</code></pre><h2 id="五、添加节点到集群中（在node01和node02上分别完成如下操作）"><a href="#五、添加节点到集群中（在node01和node02上分别完成如下操作）" class="headerlink" title="五、添加节点到集群中（在node01和node02上分别完成如下操作）"></a>五、添加节点到集群中（在node01和node02上分别完成如下操作）</h2><p>1、忽略Swap相关的预检错误</p>
<p>  若未禁用Swap设备，编辑kubelet的配置文件/etc/sysconfig/kubelet，设置其忽略Swap启用的状态错误，内容如下：</p>
<pre><code>KUBELET_EXTRA_ARGS=&quot;--fail-swap-on=false&quot;</code></pre><p>  提示：若节点禁用了所有的Swap设备，并无须执行此步骤。</p>
<p>2、添加节点</p>
<p> 将节点加入第二步中创建的master的集群中，要使用主节点初始化过程中记录的kubeadm join命令，并且在未禁用Swap设备的情况下，额外附加“–ignore-preflight-errors=Swap”选项；下面的命令来自于前面初始master时运行的kubeadm init命令的输出结果。</p>
<p>   kubeadm join 192.168.1.100:6443 –token 946w2y.xhj1wukp35zu6ppb     –discovery-token-ca-cert-hash sha256:93253b79ac5f2a3f32ee7d76e4d7d75cb2bbcd9190132a931c7ea5d5985521a1     –ignore-preflight-errors=Swap</p>
<p>在node服务器上执行scp  把master上的admin.conf文件拉取到/etc/kubernetes/admin.conf             </p>
<pre><code>scp root@192.168.1.100:/etc/kubernetes/admin.conf /etc/kubernetes/admin.conf             </code></pre><p>设置环境变量</p>
<pre><code>export KUBECONFIG=/etc/kubernetes/admin.conf </code></pre><p>  在每个节点添加完成后，即可通过kubectl验正添加结果。下面的命令及其输出是在node01和node02均添加完成后运行的，其输出结果表明两个Node已经准备就绪。</p>
<pre><code>kubectl get nodes</code></pre><p>  输出：</p>
<pre><code>NAME STATUS ROLES AGE VERSION

master01.magedu.com Ready master 31m v1.12.1

node01.magedu.com Ready &lt;none&gt; 3m8s v1.12.1

node02.magedu.com Ready &lt;none&gt; 2m25s v1.12.1</code></pre><p>  到此为止，一个master，并附带有两个node的kubernetes集群基础设施已经部署完成，用户随后即可测试其核心功能。例如，下面的命令可将myapp以Pod的形式编排运行于集群之上，并通过在集群外部进行访问：</p>
<pre><code>kubectl create deployment myapp --image=ikubernetes/myapp:v1

kubectl create service nodeport myapp --tcp=80:80</code></pre><p>  而后，使用如下命令了解Service对象myapp使用的NodePort，以便于在集群外部进行访问：</p>
<pre><code>kubectl get svc -l app=myapp</code></pre><p>  输出：</p>
<pre><code>NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE

myapp NodePort 10.102.254.75 &lt;none&gt; 80:31257/TCP 2m32s</code></pre><p>myapp是一个web应用，因此，用户可以于集群外部通过“<a href="http://NodeIP:31257”这个URL访问myapp上的应用，例如于集群外通过浏览器访问“http://172.20.0.61:31257”。">http://NodeIP:31257”这个URL访问myapp上的应用，例如于集群外通过浏览器访问“http://172.20.0.61:31257”。</a></p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>liunx</tag>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>史上最全breeze安装k8s文档</title>
    <url>/2020/05/21/breeze/</url>
    <content><![CDATA[<p>在我们的实验环境中准备了四台服务器，配置与角色如下（如果需要增加 Minion/Worker 节点请自行准备即可）：<br><img src="/2020/05/21/breeze/1.png" alt></p>
<h2 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h2><h2 id="一、准备部署主机（deploy-192-168-9-10）"><a href="#一、准备部署主机（deploy-192-168-9-10）" class="headerlink" title="一、准备部署主机（deploy / 192.168.9.10）"></a>一、准备部署主机（deploy / 192.168.9.10）</h2><p>（1）以标准 Minimal 方式安装 CentOS 7.6 (1810) x64 之后(7.4 和 7.5 也支持)，登录 shell 环境，执行以下命令关闭防火墙：<br>setenforce 0</p>
<pre><code>systemctl stop firewalld.service

systemctl stop iptables.service

systemctl disable firewalld.service

systemctl disable iptables.service</code></pre><p>（2）安装 docker-compose 命令</p>
<pre><code>curl -L https://github.com/docker/compose/releases/download/1.21.2/docker-compose-$(uname -s)-$(uname -m) -o /usr/local/bin/docker-compose

chmod +x /usr/local/bin/docker-compose</code></pre><p>（3）安装 docker</p>
<pre><code>yum install docker
systemctl enable docker &amp;&amp; systemctl start docker</code></pre><p>（4）建立部署主机到其它所有服务器的 ssh 免密登录途径<br>    a) 生成秘钥，执行：</p>
<pre><code>    ssh-keygen

b) 针对目标服务器做 ssh 免密登录，依次执行：

    ssh-copy-id 192.168.1.100
    ssh-copy-id 192.168.1.101
    ssh-copy-id 192.168.1.102
    ssh-copy-id 192.168.1.103
    ssh-copy-id 192.168.1.104</code></pre><h2 id="二、获取针对-K8S-某个具体版本的-Breeze-资源文件并启动部署工具，例如此次实验针对刚刚发布的-K8S-v1-13-1"><a href="#二、获取针对-K8S-某个具体版本的-Breeze-资源文件并启动部署工具，例如此次实验针对刚刚发布的-K8S-v1-13-1" class="headerlink" title="二、获取针对 K8S 某个具体版本的 Breeze 资源文件并启动部署工具，例如此次实验针对刚刚发布的 K8S v1.13.1"></a>二、获取针对 K8S 某个具体版本的 Breeze 资源文件并启动部署工具，例如此次实验针对刚刚发布的 K8S v1.13.1</h2><pre><code>curl -L https://raw.githubusercontent.com/wise2c-devops/breeze/v1.13.1/docker-compose.yml -o docker-compose.yml</code></pre><p>  如果无法访问此网站，复制一下内容到文件中命名为   docker-compose.yml</p>
<pre><code>vim   docker-compose.yml

  version: &apos;2&apos;
  services:
    deploy:
      container_name: deploy-main
      image: registry.cn-shenzhen.aliyuncs.com/breeze-project/pagoda:v1.2.0
      restart: always
      entrypoint: sh
      command:
      - -c
      - &quot;/root/pagoda -logtostderr -v 4 -w /workspace&quot;
      ports:
      - 88:80
      - 8088:8080
      volumes:
      - $HOME/.ssh:/root/.ssh
      - $PWD/deploy:/deploy
      volumes_from:
      - playbook
    ui:
      container_name: deploy-ui
      image: registry.cn-shenzhen.aliyuncs.com/breeze-project/deploy-ui:v1.8
      restart: always
      network_mode: &quot;service:deploy&quot;
    playbook:
      container_name: deploy-playbook
      image: registry.cn-shenzhen.aliyuncs.com/breeze-project/playbook:v1.18.2
      volumes:
      - playbook:/workspace
    yum-repo:
      container_name: deploy-yumrepo
      image: registry.cn-shenzhen.aliyuncs.com/breeze-project/yum-repo:v1.18.2
      ports:
      - 2009:2009 
      restart: always
  volumes:
    playbook:
      external: false</code></pre><h2 id="三、访问部署工具的浏览器页面-部署机-IP-及端口-88-，开始部署工作"><a href="#三、访问部署工具的浏览器页面-部署机-IP-及端口-88-，开始部署工作" class="headerlink" title="三、访问部署工具的浏览器页面(部署机 IP 及端口 88)，开始部署工作"></a>三、访问部署工具的浏览器页面(部署机 IP 及端口 88)，开始部署工作</h2><p>  <a href="http://192.168.1.199:88" target="_blank" rel="noopener">http://192.168.1.199:88</a></p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>liunx</tag>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>ssl证书申请</title>
    <url>/2020/05/21/ssl/</url>
    <content><![CDATA[<h2 id="SSL证书申请"><a href="#SSL证书申请" class="headerlink" title="SSL证书申请"></a>SSL证书申请</h2><p><br>1、 购买证书 （免费版一年）<br><br>2、证书申请   –&gt; 绑定域名    子域名随便起   例如     qwer.effc.ltd    qwer任意<br><br>3、在此域名解析看到有一条TXT记录值，然后返回证书申请点击认证  然后提交<br></p>
<p>认证通过后直接下载证书   （nginx证书   会有.key    .pem  两个秘钥文件）</p>
]]></content>
      <categories>
        <category>阿里云</category>
      </categories>
      <tags>
        <tag>liunx</tag>
        <tag>阿里云</tag>
      </tags>
  </entry>
  <entry>
    <title>pm2安装报错</title>
    <url>/2020/05/20/pm2/</url>
    <content><![CDATA[<h2 id="使用npm安装pm2报错"><a href="#使用npm安装pm2报错" class="headerlink" title="使用npm安装pm2报错"></a>使用npm安装pm2报错</h2><pre><code>sudo  npm  -g  install   pm2  </code></pre><p>报错日志</p>
<pre><code>gyp WARN EACCES user &quot;root&quot; does not have permission to access the dev dir &quot;/root/.node-gyp/4.9.1&quot;
gyp WARN EACCES attempting to reinstall using temporary dev dir &quot;/usr/lib/node_modules/pm2/node_modules/@pm2/agent/node_modules/utf-8-validate/.node-gyp&quot;
make: Entering directory `/usr/lib/node_modules/pm2/node_modules/@pm2/agent/node_modules/utf-8-validate/build&apos;
  CC(target) Release/obj.target/validation/src/validation.o
make: cc: Command not found
make: *** [Release/obj.target/validation/src/validation.o] Error 127
make: Leaving directory `/usr/lib/node_modules/pm2/node_modules/@pm2/agent/node_modules/utf-8-validate/build&apos;
gyp ERR! build error 
gyp ERR! stack Error: `make` failed with exit code: 2
gyp ERR! stack     at ChildProcess.onExit (/usr/lib/node_modules/npm/node_modules/node-gyp/lib/build.js:276:23)
gyp ERR! stack     at emitTwo (events.js:87:13)
gyp ERR! stack     at ChildProcess.emit (events.js:172:7)
gyp ERR! stack     at Process.ChildProcess._handle.onexit (internal/child_process.js:211:12)
gyp ERR! System Linux 3.10.0-957.el7.x86_64
gyp ERR! command &quot;/usr/bin/node&quot; &quot;/usr/lib/node_modules/npm/node_modules/node-gyp/bin/node-gyp.js&quot; &quot;rebuild&quot;
gyp ERR! cwd /usr/lib/node_modules/pm2/node_modules/@pm2/agent/node_modules/utf-8-validate
gyp ERR! node -v v4.9.1
gyp ERR! node-gyp -v v3.4.0
gyp ERR! not ok </code></pre><p>这个意思是因为node版本太低很多依赖库无法使用</p>
<p>更换镜像重试下</p>
<pre><code>sudo  npm install -g pm2 --registry=https://registry.npm.taobao.org  </code></pre><p>使用cnpm安装试下</p>
<pre><code>sudo  npm install -g cnpm --registry=https://registry.npm.taobao.org  
sudo  cnpm install -g  pm2</code></pre><p>还是报错，只有升级node的版本了</p>
<h2 id="node有一个模块叫-n-，是专门用来管理node-js的版本的"><a href="#node有一个模块叫-n-，是专门用来管理node-js的版本的" class="headerlink" title="node有一个模块叫 n ，是专门用来管理node.js的版本的"></a>node有一个模块叫 n ，是专门用来管理node.js的版本的</h2><p><br>第一步：首先安装n模块:<br></p>
<pre><code>sudo  npm install -g n</code></pre><p>第二步：升级node.js到最新稳定版</p>
<pre><code>n stable</code></pre><p>第二步：n后面也可以跟随版本号比如</p>
<pre><code>n v0.10.26
n 0.10.26</code></pre><p>安装管理命令</p>
<pre><code>sudo npm install -g n  

[sgsm@f069vn-thamdinh yum.repos.d]$ sudo n stable

  installing : node-v12.16.3
      mkdir : /usr/local/n/versions/node/12.16.3
      fetch : https://nodejs.org/dist/v12.16.3/node-v12.16.3-linux-x64.tar.xz
  installed : v12.16.3 to /usr/local/bin/node
      active : v4.9.1 at /bin/node</code></pre><p>升级node之后就可以安装pm2了</p>
<pre><code>[sgsm@f069vn-thamdinh yum.repos.d]$ pm2 list             

                        -------------

__/\\\\\\\\\\\\\____/\\\\____________/\\\\____/\\\\\\\\\_____
_\/\\\/////////\\\_\/\\\\\\________/\\\\\\__/\\\///////\\\___
  _\/\\\_______\/\\\_\/\\\//\\\____/\\\//\\\_\///______\//\\\__
  _\/\\\\\\\\\\\\\/__\/\\\\///\\\/\\\/_\/\\\___________/\\\/___
    _\/\\\/////////____\/\\\__\///\\\/___\/\\\________/\\\//_____
    _\/\\\_____________\/\\\____\///_____\/\\\_____/\\\//________
      _\/\\\_____________\/\\\_____________\/\\\___/\\\/___________
      _\/\\\_____________\/\\\_____________\/\\\__/\\\\\\\\\\\\\\\_
        _\///______________\///______________\///__\///////////////__


                          Runtime Edition

        PM2 is a Production Process Manager for Node.js applications
                    with a built-in Load Balancer.

                Start and Daemonize any application:
                $ pm2 start app.js

                Load Balance 4 instances of api.js:
                $ pm2 start api.js -i 4

                Monitor in production:
                $ pm2 monitor

                Make pm2 auto-boot at server restart:
                $ pm2 startup

                To go further checkout:
                http://pm2.io/


                        -------------

[PM2] Spawning PM2 daemon with pm2_home=/home/sgsm/.pm2
[PM2] PM2 Successfully daemonized
┌─────┬───────────┬─────────────┬─────────┬─────────┬──────────┬────────┬──────┬───────────┬──────────┬──────────┬──────────┬──────────┐
│ id  │ name      │ namespace   │ version │ mode    │ pid      │ uptime │ ↺    │ status    │ cpu      │ mem      │ user     │ watching │
└─────┴───────────┴─────────────┴─────────┴─────────┴──────────┴────────┴──────┴───────────┴──────────┴──────────┴──────────┴──────────┘</code></pre><p>其实到这里就出现了很大的问题了，首先应该需要确定下代码是否支持node的高版本，所以更改node版本后其他进程就会有问题<br><br>(还好是测试服，如果正式服我估计现在已经没办法写这个文档了)<br></p>
<p>最后只能还原node版本</p>
<pre><code>sudo n   v4.4.4</code></pre><h2 id="然后把进程启动，关于安装pm2只能使用下面的办法了"><a href="#然后把进程启动，关于安装pm2只能使用下面的办法了" class="headerlink" title="然后把进程启动，关于安装pm2只能使用下面的办法了"></a>然后把进程启动，关于安装pm2只能使用下面的办法了</h2><p><br>找一个同版本node并且已经安装pm2的机器<br></p>
<pre><code>[sgsm@f069vn-thamdinh ~]$ rpm -ql  nodejs  |head  -30
/usr/bin/node
/usr/bin/npm
/usr/lib/node_modules
/usr/lib/node_modules/npm
/usr/lib/node_modules/npm/.mailmap
/usr/lib/node_modules/npm/.npmignore
/usr/lib/node_modules/npm/.travis.yml
/usr/lib/node_modules/npm/AUTHORS
/usr/lib/node_modules/npm/CHANGELOG.md
/usr/lib/node_modules/npm/CONTRIBUTING.md
/usr/lib/node_modules/npm/LICENSE
/usr/lib/node_modules/npm/Makefile</code></pre><p>查看到nodejs模板文件的安装位置然后进入目录</p>
<pre><code>cd /usr/lib/node_modules/</code></pre><p>ls会查看到有一个pm2的目录</p>
<pre><code>[sgsm@localhost node_modules]$ ll
总用量 4
drwxr-xr-x 9 root   root  4096 12月 12 2018 npm
drwxr-xr-x 5 nobody users  320 5月   6 2019 pm2
drwxr-xr-x 8 nobody root   267 12月 12 2018 pomelo</code></pre><p>直接使用tar打包</p>
<pre><code>tar czf  pm2.tar.gz  pm2/</code></pre><p>最后传到需要安装pm2的机器</p>
<p>然后去相同的目录解压</p>
<pre><code>sudo  tar  xf  pm2.tar.gz </code></pre><p>设置环境变量</p>
<pre><code>sudo vim /etc/profile
    export PM2_HOME=/usr/lib/node_modules/pm2
    export PATH=$PM2_HOME/bin:$PATH</code></pre><p>生效环境变量</p>
<pre><code>source  /etc/profile</code></pre><p>由于pm2这个命令在pm2/bin/下面 所以设置个软连接 方便使用</p>
<pre><code>sudo ln -s /usr/lib/node_modules/pm2/bin/pm2 /usr/bin/pm2</code></pre><p>执行试下是否报错 </p>
<pre><code>pm2 list </code></pre><p>我这里是遇到了权限的问题给下用户权限就可以了</p>
<pre><code>sudo chown  sgsm.sgsm   pm2 -R</code></pre><p>至此pm2 成功安装</p>
<p>最后最后最后最后最后最后  经过神秘大佬的指点</p>
<pre><code>sudo  npm -g install  pm2@版本号</code></pre><p>可以安装指定的低版本pm2</p>
<p>写完这篇文档就GG</p>
<p>等下 还有几个npm的常用命令分享</p>
<pre><code>npm -v #显示版本，检查npm 是否正确安装。

npm install express #安装express模块

npm install -g express #全局安装express模块

npm list #列出已安装模块

npm show express #显示模块详情

npm update #升级当前目录下的项目的所有模块

npm update express #升级当前目录下的项目的指定模块

npm update -g express #升级全局安装的express模块

npm uninstall express #删除指定的模块</code></pre>]]></content>
      <categories>
        <category>运维</category>
        <category>开发</category>
      </categories>
      <tags>
        <tag>liunx</tag>
        <tag>pm2</tag>
      </tags>
  </entry>
  <entry>
    <title>一个奇怪的报错</title>
    <url>/2020/05/19/strange/</url>
    <content><![CDATA[<p>前因：因为程序需要node的启动进行需要改到80端口，改过之后却报错</p>
<pre><code>Error: listen EACCES 0.0.0.0:80</code></pre><p>过程：这个报错是端口冲突，然后就排查服务器是否某个进程把80端口占用</p>
<pre><code>sudo netstat -ntpla  |grep  80</code></pre><p>结果什么都没有</p>
<pre><code>sudo  lsof -i:80</code></pre><p>也没有查到这个端口，百度各种搜资料也是无望马上要爆炸的时候一位神秘的大佬给了一个网站</p>
<p><img src="/2020/05/19/strange/1.png" alt><br>看到后就崩溃了</p>
<pre><code>翻译：如果 需要在80端口上运行服务，则需要使用反向代理（如nginx），它将使用首选端口上的系统账户运行，并将请求代理到运行在未观端口（&gt;1024）</code></pre><p>结语：官方文档看到不够多</p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>liunx</tag>
      </tags>
  </entry>
  <entry>
    <title>mvn环境配置</title>
    <url>/2020/05/18/mvn/</url>
    <content><![CDATA[<h2 id="配置jdk环境变量"><a href="#配置jdk环境变量" class="headerlink" title="配置jdk环境变量"></a>配置jdk环境变量</h2><p>创建目录</p>
<pre><code>mkdir /application/ </code></pre><p>解压jdk包到创建的目录中</p>
<pre><code>tar xf jdk-8u60-linux-x64.tar.gz   -C /application/</code></pre><p>做软连接</p>
<pre><code>ln -s  /application/jdk1.8.0_60/ /application/jdk</code></pre><p>设置环境变量</p>
<pre><code>sed -i.ori &apos;$a export  JAVA_HOME=/application/jdk\nexport PATH=$JAVA_HOME/bin:$JAVA_HOME/jre/bin:$PATH\nexport  CLASSPATH=.$CLASSPATH:$JAVA_HOME/lib:$JAVA_HOME/jre/lib:$JAVA_HOME/lib/tools.jar&apos;  /etc/profile</code></pre><p>source一下生效环境变量</p>
<h2 id="配置mvn环境变量"><a href="#配置mvn环境变量" class="headerlink" title="配置mvn环境变量"></a>配置mvn环境变量</h2><pre><code>cd /application/ </code></pre><p>下载mvn包</p>
<pre><code>wget http://mirrors.hust.edu.cn/apache/maven/maven-3/3.5.4/binaries/apache-maven-3.5.4-bin.tar.gz</code></pre><p>解压</p>
<pre><code>tar -zxvf apache-maven-3.5.4-bin.tar.gz</code></pre><p>vim /etc/profile</p>
<pre><code>export MAVEN_HOME=/application/apache-maven-3.0.5
export PATH=$PATH:$MAVEN_HOME/bin</code></pre><p>source一下生效环境变量</p>
<p>最后可以使用mvn -v 查看</p>
<pre><code>[sgsm@localhost weblog]$ mvn  -v
Apache Maven 3.5.4 (1edded0938998edf8bf061f1ceb3cfdeccf443fe; 2018-06-18T02:33:14+08:00)
Maven home: /home/sgsm/test3/apache-maven-3.5.4
Java version: 1.8.0_60, vendor: Oracle Corporation, runtime: /application/jdk1.8.0_60/jre
Default locale: zh_CN, platform encoding: UTF-8
OS name: &quot;linux&quot;, version: &quot;3.10.0-514.21.2.el7.x86_64&quot;, arch: &quot;amd64&quot;, family: &quot;unix&quot;</code></pre><p>接下来就可以使用mvn打jar包了</p>
<pre><code>mvn clean package </code></pre>]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>liunx</tag>
        <tag>mvn</tag>
      </tags>
  </entry>
  <entry>
    <title>Git无法添加主题文件夹</title>
    <url>/2020/05/17/gitremove/</url>
    <content><![CDATA[<p>由于主题都是在git上下载的所以默认会有一个.git的文件，这样导致提交的时候无法提交主题文件<br><br>解决办法<br></p>
<p>删除主题文件夹下.git</p>
<pre><code>git rm --cached themes/hexo-theme-ayer
git add .
git commit -m &quot;xxx&quot;
git push origin master</code></pre>]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>liunx</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>大于2T的硬盘需要parted磁盘分区</title>
    <url>/2020/05/16/parted/</url>
    <content><![CDATA[<h2 id="首先安装parted"><a href="#首先安装parted" class="headerlink" title="首先安装parted"></a>首先安装parted</h2><pre><code>yum install parted   -y</code></pre><p>查看硬盘情况使用fdisk -l 查看分区情况，对于大于2TB的硬盘用parted分区<br><br>格式化 /dev/sdb<br></p>
<pre><code>parted /dev/sdb</code></pre><p>使用print打印分区信息</p>
<pre><code>(parted) print</code></pre><p>将分区设置成gpt格式</p>
<pre><code>mklabel gpt    </code></pre><p>将所有空间创建一个分区</p>
<pre><code>mkpart primary 0 100%</code></pre><p>退出</p>
<pre><code>quit</code></pre><h2 id="将硬盘分为两个主分区"><a href="#将硬盘分为两个主分区" class="headerlink" title="将硬盘分为两个主分区"></a>将硬盘分为两个主分区</h2><pre><code>[root@localhost ~]# parted /dev/sdb   
GNU Parted 1.8.1 Using /dev/sdb Welcome to GNU Parted! Type ‘help’ to view a list of commands.
(parted) mklabel gpt           # 将MBR磁盘格式化为GPT
(parted) print                       #打印当前分区
(parted) mkpart primary 0 4.5TB                # 分一个4.5T的主分区
(parted) mkpart primary 4.5TB 12TB      # 分一个7.5T的主分区
(parted) print                         #打印当前分区
(parted) quit 退出</code></pre>]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>liunx</tag>
        <tag>parted</tag>
      </tags>
  </entry>
  <entry>
    <title>centos安装samba文件共享--隐藏目录</title>
    <url>/2020/05/14/samba/</url>
    <content><![CDATA[<h2 id="配置环境–关闭防火墙和selinux"><a href="#配置环境–关闭防火墙和selinux" class="headerlink" title="配置环境–关闭防火墙和selinux"></a>配置环境–关闭防火墙和selinux</h2><p><br>centos6<br></p>
<pre><code>service  iptables  stop
service  ip6tables  stop</code></pre><p>centos7</p>
<pre><code>systemctl stop  firewalld</code></pre><p>永久关闭</p>
<pre><code>chkconfig  iptables  off   
chkconfig  ip6tables  off   </code></pre><p>临时关闭selinux</p>
<pre><code>setenforce 0</code></pre><p>永久关闭selinux</p>
<pre><code>vim  /etc/selinux/config
    SELINUX=disabled</code></pre><p>重启生效</p>
<h2 id="安装samba服务"><a href="#安装samba服务" class="headerlink" title="安装samba服务"></a>安装samba服务</h2><pre><code>yum  install samba  samba-client  samba-common  samba-doc  -y </code></pre><h2 id="配置samba服务"><a href="#配置samba服务" class="headerlink" title="配置samba服务"></a>配置samba服务</h2><pre><code>cp  /etc/samba/smb.conf  /etc/samba/smb.conf_bak
vim /etc/samba/smb.conf
[global]     #定义全局策略
    workgroup = MYGROUP   #定义工作组
    server string = Samba Server Version %v #服务器提示字符，默认显示samba版本
    log file = /var/log/samba/log.%m    #定义日志文件
    max log size = 50      #定义日志文件单个文件最大容量为50KB
    security = user        #security选项将会影响客户端访问方式       #可以设置user、share、server、domain。User代表用户名和密码验证；share代表匿名访问；server代表基于验证身份的访问，账户信息在另一台SMB服务器上；domain:同样基于验证身份验证，账户信息在活动目录中    
    passdb backend = tdbsam    #账户与密码存储方式，smbpasswd使用老的明文格式存储账户及密码；tdbsam代表基于TDB的密文格式存储；ldapsam代表使用LDAP存储账户资料。
    load printers = yes        #客户端在10分钟内没有打开任何Samba资源，服务器将自动关闭回话。
    cups options = raw       #打印属性

    config file = /etc/samba/%U.smb.conf   #指定扩展文件


[dome]       #共享名称为dome
    comment = Common share
    path = /common        #指定共享目录
    valid users = tom jerry    #有效账户列表
    create mask = 0750        #客户端上传文件的默认权限
    directorymask = 0775       #客户端创建目录的默认权限 
    browseable = yes       #客户端是否对所有人可见    
    writable= no          #是否允许写入
    write list = tom       #写权限账户列表
    admin users = tom       #该共享的管理员，具有完全权限
    invalid users = root bin    #禁止root与bin访问common共享
      guest ok = no       #是否允许匿名访问


[server]
    path = /share/samba/server
    directory  mask = 0755
    create mask = 0644
    valid users = yanfa
    browseable = no

[meishu]
    path = /share/samba/meishu
    directory  mask =0755
    create mask =0644
    valid users = meishu
    browseable = no

[yunyingmeishu]
    path = /share/samba/yunyingmeishu
    directory  mask =0755
    create mask =0644
    valid users = yunying
    browseable = no</code></pre><h2 id="创建扩展文件"><a href="#创建扩展文件" class="headerlink" title="创建扩展文件"></a>创建扩展文件</h2><pre><code>cd /etc/samba/

vim   yanfa.smb.conf  
    [share]
    security = user
    path = /share/samba/yanfa
    valid users = @yanfa
    read list = @yanfa
    write list = @yanfa
    writable = yes
    create mask = 0644
    directory mask = 0755 


vim   meishu.smb.conf   
    [meishu]
    security = user
    path = /share/samba/meishu
    valid users = @meishu
    read list = @meishu
    write list = @meishu
    writable = yes
    create mask = 0644
    directory mask = 0755


vim   yunying.smb.conf 
    [yunying]
    security = user
    path = /share/samba/yunyingmeishu
    valid users = @yunying
    read list = @yunying
    write list = @yunying
    writable = yes
    create mask = 0644
    directory mask = 0755</code></pre><h2 id="创建共享文件夹"><a href="#创建共享文件夹" class="headerlink" title="创建共享文件夹"></a>创建共享文件夹</h2><p>  mkdir /share/samba/{yanfa,meishu,yunyingmeishu}    -p</p>
<h2 id="创建登录用户"><a href="#创建登录用户" class="headerlink" title="创建登录用户"></a>创建登录用户</h2><pre><code>useradd  yanfa
useradd  meishu
useradd  yunying</code></pre><h2 id="创建samba用户–需要交互式输入密码，此密码和系统用户密码无关"><a href="#创建samba用户–需要交互式输入密码，此密码和系统用户密码无关" class="headerlink" title="创建samba用户–需要交互式输入密码，此密码和系统用户密码无关"></a>创建samba用户–需要交互式输入密码，此密码和系统用户密码无关</h2><pre><code>pdbedit -a  yanfa
pdbedit -a  meishu
pdbedit -a  yunying</code></pre><p>pdbedit常用参数</p>
<pre><code>pdbedit -L  ：查看samba用户
pdbedit -Lv：列出Samba用户列表详细信息
pdbedit -a  -u  user：添加samba用户
pdbedit -r  -u  user：修改samba用户信息
pdbedit -x  -u  user： 删除samba用户</code></pre><h2 id="共享文件夹更改权限"><a href="#共享文件夹更改权限" class="headerlink" title="共享文件夹更改权限"></a>共享文件夹更改权限</h2><pre><code>cd  /share/samba/
chown  meishu.meishu  meishu/ -R
chown   yunying.yunying  yunyingmeishu/ -R
chown  yanfa.yanfa  yanfa/ -R</code></pre><h2 id="启动服务就可以访问了"><a href="#启动服务就可以访问了" class="headerlink" title="启动服务就可以访问了"></a>启动服务就可以访问了</h2><pre><code>/etc/init.d/smb  start
/etc/init.d/nmb  start</code></pre><h2 id="好礼大放送–wind客户端清理已保存的samba用户和密码"><a href="#好礼大放送–wind客户端清理已保存的samba用户和密码" class="headerlink" title="好礼大放送–wind客户端清理已保存的samba用户和密码"></a>好礼大放送–wind客户端清理已保存的samba用户和密码</h2><pre><code>net  use      # 查看已保存的用户和密码

net use  *  /del   /y     # 清除所有账号密码</code></pre>]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>liunx</tag>
        <tag>samba</tag>
      </tags>
  </entry>
  <entry>
    <title>Mongo常见报错</title>
    <url>/2020/05/14/MongoError/</url>
    <content><![CDATA[<p>mongod宕机常见报错</p>
<pre><code>/data/lib/mongo//WiredTiger.turtle: handle-open: open: Permission denied</code></pre><p>  解决办法直接给权限</p>
<pre><code>sudo chown  mongod.mongod   ./*  -R</code></pre><p>还有一种是非正常关闭mongo再次启动会失败  使用</p>
<pre><code>sudo  journalctl -xe</code></pre><p>查看到报错</p>
<pre><code>Error starting mongod. /var/run/mongodb/mongod.pid exists.</code></pre><p>是因为非正常关闭mongo的时候pid文件还存在，删除后启动就正常了</p>
<p>锁文件报错</p>
<pre><code>2020-06-20T19:55:41.371+0800 W -        [initandlisten] Detected unclean shutdown - /data/lib/mongo/mongod.lock is not empty.</code></pre><p>解决办法</p>
<pre><code>sudo  rm   /data/lib/mongo/mongod.lock</code></pre><p>最大连接数报错</p>
<pre><code>[1592654142:807610][13609:0x7fb0fc34bdc0], file:collection-1898--8679891645894746372.wt, WT_SESSION.open_cursor: /data/lib/mongo//collection-1898--8679891645894746372.wt: handle-open: open: Too many open files
2020-06-20T19:55:42.807+0800 I -        [initandlisten] Invariant failure: ret resulted in status UnknownError: 24: Too many open files at src/mongo/db/storage/wiredtiger/wiredtiger_session_cache.cpp 79</code></pre><p>解决办法</p>
<pre><code>ulimit -n 4096</code></pre><p>查看mongo连接数</p>
<pre><code>db.serverStatus().connections
{ &quot;current&quot; : 80, &quot;available&quot; : 52348, &quot;totalCreated&quot; : NumberLong(367) }</code></pre><p>Current表示当前到实例上正在运行的连接数。<br><br>Available表示当前实例还可以支持的并发连接数。<br></p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>mongo</tag>
        <tag>liunx</tag>
      </tags>
  </entry>
  <entry>
    <title>lamp</title>
    <url>/2020/05/13/lamp/</url>
    <content><![CDATA[<!-- 文章头部设置 -->

<blockquote>
<p>&amp;  表示任务在后台执行，如要在后台运行redis-server,则有  redis-server &amp;<br>&amp;&amp; 表示前一条命令执行成功时，才执行后一条命令 ，如 echo ‘1’ &amp;&amp; echo ‘2’<br>| 表示管道，上一条命令的输出，作为下一条命令参数，如 echo ‘yes’ | wc -l<br>|| 表示上一条命令执行失败后，才执行下一条命令，如 cat nofile || echo “fail”</p>
</blockquote>
<h1 id="安装apache"><a href="#安装apache" class="headerlink" title="安装apache"></a>安装apache</h1><h2 id="下载和安装依赖"><a href="#下载和安装依赖" class="headerlink" title="下载和安装依赖"></a>下载和安装依赖</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install autoconf libtool gcc expat expat-devel make zlib-devel gcc-c++ openssl-devel pcre-devel openssl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入 https://mirror.bit.edu.cn/apache//apr/ 找到最新的 apr 和 apr-util 包即可</span></span><br><span class="line">wget https://mirror.bit.edu.cn/apache//apr/apr-1.7.0.tar.gz</span><br><span class="line">wget https://mirror.bit.edu.cn/apache/httpd/httpd-2.4.43.tar.gz</span><br><span class="line">wget https://mirror.bit.edu.cn/apache//apr/apr-util-1.6.1.tar.gz</span><br></pre></td></tr></table></figure>

<h2 id="编译安装apr"><a href="#编译安装apr" class="headerlink" title="编译安装apr"></a>编译安装apr</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 编辑 configure文件，查找 $RM "$cfgfile" 这个地方，用#注释掉</span></span><br><span class="line">31880行 <span class="comment">#    $RM "$cfgfile"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在configure里面 RM='$RM  -f' 这里的$RM后面一定有一个空格。 如果后面没有空格，直接连接减号，就依然会报错。把 RM='$RM' 改为 RM='$RM -f'</span></span><br><span class="line">31279行     RM=<span class="string">'$RM -f'</span></span><br><span class="line"><span class="comment"># 更改上面两行，否则./configure会报错：rm: cannot remove `libtoolT': No such file or directory</span></span><br><span class="line">./configure --prefix=/home/lamp/apr</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<h2 id="编译安装apr-util"><a href="#编译安装apr-util" class="headerlink" title="编译安装apr-util"></a>编译安装apr-util</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指明apr的安装位置--with-apr=/home/lamp/apr</span></span><br><span class="line">./configure --prefix=/home/lamp/apr-util --with-apr=/home/lamp/apr</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<h2 id="编译安装apache"><a href="#编译安装apache" class="headerlink" title="编译安装apache"></a>编译安装apache</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./configure --prefix=/home/lamp/apache2 --with-apr=/home/lamp/apr --with-apr-util=/home/lamp/apr-util</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<h1 id="启动apache"><a href="#启动apache" class="headerlink" title="启动apache"></a>启动apache</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/lamp/apache2</span><br><span class="line"><span class="comment"># 修改端口为800</span></span><br><span class="line">./bin/httpd -k start</span><br><span class="line">curl localhost:800</span><br><span class="line"><span class="comment"># 显示&lt;html&gt;&lt;body&gt;&lt;h1&gt;It works!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="配置基于域名访问不同资源目录"><a href="#配置基于域名访问不同资源目录" class="headerlink" title="配置基于域名访问不同资源目录"></a>配置基于域名访问不同资源目录</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 编辑httpd.conf，在文件最后加入以下几行：</span></span><br><span class="line"></span><br><span class="line">&lt;/IfModule&gt;</span><br><span class="line">&lt;VirtualHost *:800&gt;</span><br><span class="line">    DocumentRoot <span class="string">"/home/lamp/apache2/htdocs/"</span></span><br><span class="line">    ServerName www.example.com</span><br><span class="line">    <span class="comment"># 访问www.example.com会访问/home/lamp/apache2/htdocs/目录下的资源</span></span><br><span class="line"></span><br><span class="line">&lt;/VirtualHost&gt;</span><br><span class="line"></span><br><span class="line">&lt;VirtualHost *:800&gt;</span><br><span class="line">    DocumentRoot <span class="string">"/home/lamp/apache2/htdocs/org/"</span></span><br><span class="line">    ServerName www.example.org</span><br><span class="line">    <span class="comment"># 访问www.example.org会访问/home/lamp/apache2/htdocs/org/目录下的资源</span></span><br><span class="line"></span><br><span class="line">&lt;/VirtualHost&gt;</span><br></pre></td></tr></table></figure>

<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置hosts文件！！！</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /home/lamp/apache2/</span><br><span class="line">mkdir htdocs/org/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑htdocs/index.html填入www.example.com</span></span><br><span class="line">cat &gt; htdocs/index.html &lt;&lt; EOF</span><br><span class="line">www.example.com</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑htdocs/org/index.html填入www.example.org</span></span><br><span class="line">cat &gt; htdocs/org/index.html &lt;&lt; EOF</span><br><span class="line">www.example.org</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启 访问</span></span><br><span class="line">./bin/httpd -k restart</span><br><span class="line"></span><br><span class="line">[root@www apache2]<span class="comment"># curl www.example.org:800</span></span><br><span class="line">www.example.org</span><br><span class="line">[root@www apache2]<span class="comment"># curl www.example.com:800</span></span><br><span class="line">www.example.com</span><br></pre></td></tr></table></figure>

<h2 id="配置基于端口访问不同资源目录"><a href="#配置基于端口访问不同资源目录" class="headerlink" title="配置基于端口访问不同资源目录"></a>配置基于端口访问不同资源目录</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在上文的基础上增加www.example.com:8000端口，直接在配置文件最下面添加以下内容</span></span><br><span class="line">&lt;VirtualHost *:8000&gt;</span><br><span class="line">    DocumentRoot <span class="string">"/home/lamp/apache2/htdocs/8000/"</span></span><br><span class="line">    ServerName www.example.com</span><br><span class="line">    <span class="comment"># 访问www.example.com:8000会访问/htdocs/8000/目录下的资源</span></span><br><span class="line"></span><br><span class="line">&lt;/VirtualHost&gt;</span><br><span class="line"><span class="comment"># 在监听端口下面增加新的监听端口</span></span><br><span class="line">Listen 800</span><br><span class="line">Listen 8000</span><br></pre></td></tr></table></figure>

<h3 id="验证-1"><a href="#验证-1" class="headerlink" title="验证"></a>验证</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir htdocs/8000</span><br><span class="line"></span><br><span class="line">cat &gt; htdocs/8000/index.html &lt;&lt; EOF</span><br><span class="line">www.example.com:8000</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查</span></span><br><span class="line">./bin/httpd -t   <span class="comment"># 显示Syntax OK即可</span></span><br><span class="line"></span><br><span class="line">./bin/httpd -k restart</span><br><span class="line"></span><br><span class="line">[root@www apache2]<span class="comment"># curl www.example.com:8000</span></span><br><span class="line">www.example.com:8000</span><br><span class="line">[root@www apache2]<span class="comment"># curl www.example.com:800</span></span><br><span class="line">www.example.com</span><br><span class="line">[root@www apache2]<span class="comment"># curl www.example.org:800</span></span><br><span class="line">www.example.org</span><br></pre></td></tr></table></figure>

<h2 id="配置基于虚拟主机访问不同资源目录"><a href="#配置基于虚拟主机访问不同资源目录" class="headerlink" title="配置基于虚拟主机访问不同资源目录"></a>配置基于虚拟主机访问不同资源目录</h2><p>&emsp;&emsp;注释掉上面的3个配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 增加新的配置</span></span><br><span class="line"><span class="comment"># 注意！IP地址是主机自带的IP地址，并非虚拟不存在的。改完配置要修改hosts解析！！！</span></span><br><span class="line">&lt;VirtualHost 192.168.1.100&gt;</span><br><span class="line">    DocumentRoot <span class="string">"/home/lamp/apache2/htdocs/100/"</span></span><br><span class="line">    ServerName www.example.com</span><br><span class="line">    <span class="comment"># 访问www.example.com:800会访问htdocs/100/目录下的资源</span></span><br><span class="line"></span><br><span class="line">&lt;/VirtualHost&gt;</span><br><span class="line"></span><br><span class="line">&lt;VirtualHost 192.168.1.200&gt;</span><br><span class="line">    DocumentRoot <span class="string">"/home/lamp/apache2/htdocs/200/"</span></span><br><span class="line">    ServerName www.example.org</span><br><span class="line">    <span class="comment"># 访问www.example.org:800会访问htdocs/200/目录下的资源</span></span><br><span class="line"></span><br><span class="line">&lt;/VirtualHost&gt;</span><br></pre></td></tr></table></figure>
<h3 id="验证-2"><a href="#验证-2" class="headerlink" title="验证"></a>验证</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./bin/httpd -k restart</span><br><span class="line"></span><br><span class="line">mkdir htdocs/&#123;1,2&#125;00</span><br><span class="line">cat &gt; htdocs/100/index.html &lt;&lt; EOF</span><br><span class="line">www.example.com  100</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">cat &gt; htdocs/200/index.html &lt;&lt; EOF</span><br><span class="line">www.example.org  200</span><br><span class="line">EOF</span><br><span class="line">./bin/httpd -k restart</span><br><span class="line"></span><br><span class="line">[root@www apache2]<span class="comment"># curl www.example.com:800</span></span><br><span class="line">www.example.com  100</span><br><span class="line">[root@www apache2]<span class="comment"># curl www.example.org:800</span></span><br><span class="line">www.example.org  200</span><br></pre></td></tr></table></figure>
<h2 id="配置基于简单的用户密码验证访问"><a href="#配置基于简单的用户密码验证访问" class="headerlink" title="配置基于简单的用户密码验证访问"></a>配置基于简单的用户密码验证访问</h2><p>&emsp;&emsp;注释掉上面的配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;Directory /usr/<span class="built_in">local</span>/apache2/htdocs/wang&gt;</span><br><span class="line">        AuthName <span class="string">"wang Auth"</span></span><br><span class="line">        AuthType basic</span><br><span class="line">        AuthUserFile /usr/<span class="built_in">local</span>/apache2/.htpasswd</span><br><span class="line">        Require user wang</span><br><span class="line">&lt;/Directory&gt;</span><br><span class="line"><span class="comment"># AuthName "wang Auth"   该字符串显示在网页访问时输入用户密码的对话框之上，实际测试并未显示</span></span><br><span class="line"><span class="comment"># AuthType basic         定义验证模块类型</span></span><br><span class="line"><span class="comment"># AuthUserFile /file     密码文件的存放地址</span></span><br><span class="line"><span class="comment"># Require user wang      设置哪些用户生效</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面这些注释也能实现用户密码访问，建议留存以便解决一些未知的bug，如果你是yum安装的httpd，你可以直接修改conf.d/userdir.conf文件，直接在最下面增加上述配置即可。</span></span><br><span class="line">&lt;IfModule mod_userdir.c&gt;</span><br><span class="line">    UserDir public_html</span><br><span class="line">&lt;/IfModule&gt;</span><br><span class="line"></span><br><span class="line">&lt;Directory /home/*/public_html&gt;</span><br><span class="line">    AllowOverride FileInfo AuthConfig Limit</span><br><span class="line">    Options MultiViews Indexes SymLinksIfOwnerMatch IncludesNoExec</span><br><span class="line">    &lt;Limit GET POST OPTIONS&gt;</span><br><span class="line">        Order allow,deny</span><br><span class="line">        Allow from all</span><br><span class="line">    &lt;/Limit&gt;</span><br><span class="line">    &lt;LimitExcept GET POST OPTIONS&gt;</span><br><span class="line">        Order deny,allow</span><br><span class="line">        Deny from all</span><br><span class="line">    &lt;/LimitExcept&gt;</span><br><span class="line">&lt;/Directory&gt;</span><br></pre></td></tr></table></figure>

<h3 id="验证-3"><a href="#验证-3" class="headerlink" title="验证"></a>验证</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./bin/httpd -k restart</span><br><span class="line"><span class="comment"># 创建用户：</span></span><br><span class="line">useradd wang</span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/apache2</span><br><span class="line">mkdir htdocs/wang</span><br><span class="line">cat &gt; htdocs/wang/index.html &lt;&lt; EOF</span><br><span class="line">wang auth</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成密码文件，修改密码再次执行此命令即可</span></span><br><span class="line">./bin/htpasswd -c -m /home/lamp/apache2/.htpasswd wang</span><br><span class="line"><span class="comment"># 输入密码a123456</span></span><br><span class="line"></span><br><span class="line">cat .htpasswd</span><br><span class="line"><span class="comment"># 显示 wang:$apr1$eL9wB7zB$F6bE1abbu1vGDVrW4Ji9V1</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th align="left">选项</th>
<th align="left">注释</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-c</td>
<td align="left">自动创建文件，仅应该在文件不存在时使用(初建时使用-c,再次创建不取消该选项则会覆盖之前内容)</td>
</tr>
<tr>
<td align="left">-m</td>
<td align="left">md5格式加密</td>
</tr>
<tr>
<td align="left">-s</td>
<td align="left">sha格式加密</td>
</tr>
<tr>
<td align="left">-D</td>
<td align="left">删除指定用户</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 访问</span></span><br><span class="line">curl www.example.com:800/wang</span><br><span class="line"><span class="comment"># 报错401</span></span><br><span class="line"><span class="comment"># 下载elinks</span></span><br><span class="line">wget http://rpmfind.net/linux/centos/8.1.1911/PowerTools/x86_64/os/Packages/elinks-0.12-0.58.pre6.el8.x86_64.rpm</span><br><span class="line">rpm -ivh elinks-0.12-0.58.pre6.el8.x86_64.rpm</span><br><span class="line"><span class="comment"># elinks访问</span></span><br><span class="line">elinks http://www.example.com:800/wang</span><br><span class="line"><span class="comment"># 输入用户名密码 &gt;&gt; 点击OK &gt;&gt; 点击here （①可以鼠标操作，②可以通过方向键移动光标，enter确认）</span></span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/13/lamp/lamp/0.jpg" alt><br><img src="/2020/05/13/lamp/lamp/1.jpg" alt><br><img src="/2020/05/13/lamp/lamp/2.jpg" alt></p>
<h3 id="扩展基于组用户密码访问"><a href="#扩展基于组用户密码访问" class="headerlink" title="扩展基于组用户密码访问"></a>扩展基于组用户密码访问</h3><p>&emsp;&emsp;上面的<strong>配置不变</strong>，增加两行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;Directory /usr/<span class="built_in">local</span>/apache2/htdocs/wang&gt;</span><br><span class="line">        AuthName <span class="string">"wang Auth"</span></span><br><span class="line">        AuthType basic</span><br><span class="line">        AuthUserFile /usr/<span class="built_in">local</span>/apache2/.htpasswd</span><br><span class="line">        Require user wang</span><br><span class="line">        AuthGroupFile /usr/<span class="built_in">local</span>/apache2/groupfile   <span class="comment"># 组文件</span></span><br><span class="line">        Require group wang   <span class="comment"># 允许的组</span></span><br><span class="line">&lt;/Directory&gt;</span><br><span class="line"><span class="comment"># 通过上面的配置文件可知，允许wang组里面的用户访问，允许用户wang访问</span></span><br></pre></td></tr></table></figure>

<h4 id="验证-4"><a href="#验证-4" class="headerlink" title="验证"></a>验证</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./bin/httpd -k restart</span><br><span class="line">cat &gt; groupfile &lt;&lt; EOF</span><br><span class="line">wang:<span class="built_in">test</span></span><br><span class="line">test0:test0</span><br><span class="line">EOF</span><br><span class="line"><span class="comment"># :前面是组名，后面是用户名；组名等于http.conf中的Require group wang规定的组名</span></span><br><span class="line"><span class="comment"># 增加用户test，test0</span></span><br><span class="line">./bin/htpasswd -m /home/lamp/apache2/.htpasswd <span class="built_in">test</span></span><br><span class="line">./bin/htpasswd -m /home/lamp/apache2/.htpasswd test0</span><br><span class="line"><span class="comment"># 由配置文件可知，允许test，和wang访问，不允许test0访问</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分别输入wang，test，test0用户密码验证即可</span></span><br><span class="line">elinks http://www.example.com:800/wang</span><br></pre></td></tr></table></figure>

<h1 id="一般遇到的问题"><a href="#一般遇到的问题" class="headerlink" title="一般遇到的问题"></a>一般遇到的问题</h1><ol>
<li>httpd.conf配置文件中，填写的路径不对</li>
<li>多使用./bin/httpd -t检查，可以避免很多的粗心错误</li>
<li>修改完配置文件一定记得重启，./bin/httpd -k restart</li>
<li>端口，资源目录，目录权限等，一定要再三验证</li>
<li>你遇到的其它问题欢迎留言~</li>
</ol>
<h1 id="编译MySQL"><a href="#编译MySQL" class="headerlink" title="编译MySQL"></a>编译MySQL</h1><p>&emsp;&emsp;安装依赖</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># MySQL源码地址：https://cdn.mysql.com//Downloads/MySQL-8.0/mysql-8.0.20.tar.gz</span></span><br><span class="line">yum install -y ncurses-devel libtirpc-devel cmake</span><br><span class="line"></span><br><span class="line"><span class="comment"># 缺少：libtirpc-devel</span></span><br><span class="line"><span class="comment"># 报错：Could not find rpc/rpc.h in /usr/include or /usr/include/tirpc</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 缺少：ncurses-devel</span></span><br><span class="line"><span class="comment"># 报错：Curses library not found. Please install appropriate package</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 缺少：rpcsvc</span></span><br><span class="line"><span class="comment"># 报错：Could not find rpcgen</span></span><br><span class="line"><span class="comment"># 编译安装</span></span><br><span class="line">wget https://github.com/thkukuk/rpcsvc-proto/releases/download/v1.4.1/rpcsvc-proto-1.4.1.tar.xz</span><br><span class="line">tar xf rpcsvc-proto-1.4.1.tar.xz</span><br><span class="line"><span class="built_in">cd</span> rpcsvc-proto-1.4.1/</span><br><span class="line">./configure &amp;&amp; make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir /home/lamp/mysql/data -p</span><br><span class="line"></span><br><span class="line">cmake . \</span><br><span class="line">-DCMAKE_INSTALL_PREFIX=/home/lamp/mysql \</span><br><span class="line">-DMYSQL_DATADIR=/home/lamp/mysql/data \</span><br><span class="line">-DMYSQL_UNIX_ADDR=/home/lamp/mysql/mysql.sock \</span><br><span class="line">-DWITH_INNODBBASE_STORAGE_ENGINE=1 \</span><br><span class="line">-DENABLE_LOCAL_INFILE=1 \</span><br><span class="line">-DEXTRA_CHARSETS=all \</span><br><span class="line">-DDEFAULT_CHARSET=utf8 \</span><br><span class="line">-DDEFAULT_COLLATION=utf8_general_ci \</span><br><span class="line">-DMYSQL_USER=mysql \</span><br><span class="line">-DWITH_DEBUG=0 \</span><br><span class="line">-DFORCE_INSOURCE_BUILD=1 \</span><br><span class="line">-DDOWNLOAD_BOOST=1 -DWITH_BOOST=/home/lamp/boost \</span><br><span class="line">-DWITH_EMBEDED_SERVER=0</span><br><span class="line"><span class="comment"># boost下载超时的话，记录下载地址：https://dl.bintray.com/boostorg/release/1.70.0/source/boost_1_70_0.tar.gz</span></span><br><span class="line"><span class="comment"># 使用迅雷下载，大约不到1min就下载好了</span></span><br><span class="line"><span class="comment"># 移动到/home/lamp/boost目录下面</span></span><br></pre></td></tr></table></figure>
<p>编译时间较长长长长长长长长长长长长长长长长😡</p>
<h2 id="一般遇到的问题-1"><a href="#一般遇到的问题-1" class="headerlink" title="一般遇到的问题"></a>一般遇到的问题</h2><ol>
<li>依赖问题</li>
<li>网速太慢</li>
<li>编译的时候内存不足</li>
<li>目录权限</li>
</ol>
<p>不等待直接编译PHP</p>
<h1 id="编译PHP"><a href="#编译PHP" class="headerlink" title="编译PHP"></a>编译PHP</h1><h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install libxml2-devel bzip2-devel net-snmp-devel curl-devel libpng-devel freetype-devel libjpeg-devel -y</span><br><span class="line"></span><br><span class="line">wget http://ftp.gnu.org/gnu/libiconv/libiconv-1.16.tar.gz</span><br><span class="line"><span class="comment"># wget http://ftp.gnu.org/gnu/libiconv/libiconv-1.14.tar.gz</span></span><br><span class="line">./configure --prefix=/usr/<span class="built_in">local</span> --with-apr=/home/lamp/apr</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line"></span><br><span class="line">wget https://sourceforge.net/projects/mcrypt/files/Libmcrypt/2.5.8/libmcrypt-2.5.8.tar.gz</span><br><span class="line">./configure &amp;&amp; make &amp;&amp; make install &amp;&amp; /sbin/ldconfig</span><br><span class="line"><span class="built_in">cd</span> libltdl/</span><br><span class="line">./configure --<span class="built_in">enable</span>-ltdl-install &amp;&amp; make &amp;&amp; make install</span><br><span class="line"></span><br><span class="line">wget https://jaist.dl.sourceforge.net/project/mhash/mhash/0.9.9.9/mhash-0.9.9.9.tar.gz</span><br><span class="line">./configure &amp;&amp; make &amp;&amp; make install</span><br><span class="line">ln -s /usr/<span class="built_in">local</span>/lib/* /usr/lib/</span><br><span class="line">ln -s /usr/<span class="built_in">local</span>/bin/libmcrypt-config /usr/bin/</span><br><span class="line"></span><br><span class="line">wget https://jaist.dl.sourceforge.net/project/mcrypt/MCrypt/2.6.8/mcrypt-2.6.8.tar.gz</span><br><span class="line"><span class="comment"># 解决报错：configure: error: *** libmcrypt was not found</span></span><br><span class="line">ln -s /usr/<span class="built_in">local</span>/bin/libmcrypt_config /usr/bin/libmcrypt_config</span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=/usr/<span class="built_in">local</span>/lib: LD_LIBRARY_PATH</span><br><span class="line">./configure &amp;&amp; make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<h2 id="安装PHP"><a href="#安装PHP" class="headerlink" title="安装PHP"></a>安装PHP</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://www.php.net/distributions/php-7.4.5.tar.gz</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>liunx</tag>
      </tags>
  </entry>
  <entry>
    <title>code</title>
    <url>/2020/05/13/code/</url>
    <content><![CDATA[<p>categories: 测试<br>    #!/usr/bin/python3<br>    def main():<br>        print(“hello world”)</p>
<pre><code>if __name__ == &quot;__mian__&quot;:
    main()</code></pre><h1 id="ceshi"><a href="#ceshi" class="headerlink" title="ceshi"></a>ceshi</h1><pre><code>#!/bin/bash
echo &quot;ceshi&quot;</code></pre><p> cehshi</p>
<pre><code>#!/usr/bin/python3
    def main():
        print(&quot;hello world&quot;)

    if __name__ == &quot;__mian__&quot;:
        main()</code></pre><p>hexo 文章插入图片的方法<br><br>设置站点配置_config.yml:将post_asset_folder: false改为post_asset_folder: true<br><br>安装插件:npm install <a href="https://github.com/CodeFalling/hexo-asset-image" target="_blank" rel="noopener">https://github.com/CodeFalling/hexo-asset-image</a> – save<br><br>运行hexo n “XXXXXX”,生成XXXXX.md博文时就会在/source/_posts目录下生成XXXXXX的文件夹，将你想在XXXXX博文中插入的照片放置到这个同名文件夹中即可，图片的命名随意<br><br>添加图片:在想添加的位置写入![](图片名字.图片格式),例如![](1.png)</p>
]]></content>
  </entry>
  <entry>
    <title>docker--容器创建后添加端口映射</title>
    <url>/2020/05/13/docker/</url>
    <content><![CDATA[<p>标注：[hash_of_the_container] 为容器id</p>
<pre><code>vim /var/lib/docker/containers/[hash_of_the_container]/hostconfig.json</code></pre><p>在 hostconfig.json 里有 “PortBindings”:{} 这个配置项，</p>
<p>改成 </p>
<pre><code>&quot;PortBindings&quot;:{&quot;9001/tcp&quot;:[{&quot;HostIp&quot;:&quot;&quot;,&quot;HostPort&quot;:&quot;900&quot;}]}
      前者为容器端口，后者为宿主机端口</code></pre><p>如果容器内端口从没有暴露，需要在修改config.v2.json</p>
<pre><code>vim /var/lib/docker/containers/[hash_of_the_container]/config.v2.json</code></pre><p>在 config.v2.json 里面添加一个配置项 </p>
<pre><code>&quot;ExposedPorts&quot;:{&quot;80/tcp&quot;:{}} ,</code></pre><p><font color="#FF0000">必须将这个配置项添加到 “Tty”: true, 前面</font></p>
<p>最后重启 docker的守护进程 systemctl restart  docker<br><br>启动容器id   docker start   ID<br></p>
<p>使用docker ps  查看容器端口是否映射<br><img src="/2020/05/13/docker/1.png" alt></p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>liunx</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>python-str</title>
    <url>/2020/04/23/python-str/</url>
    <content><![CDATA[<p>code here<br>从字符串中提取字符</p>
<pre><code>str = &quot;hello python&quot;
print(str[7])</code></pre><p>for循环遍历字符串中每一个字符</p>
<pre><code>for c in str:
    print(c)</code></pre><p>统计字符串长度</p>
<pre><code>str = &quot;hello python&quot;
print(len(str))</code></pre><p>统计一个字符在字符串中出现的次数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str = <span class="string">"hello python"</span></span><br><span class="line">print(str.count(<span class="string">"l"</span>))</span><br></pre></td></tr></table></figure>
<pre><code>puts &quot;Awesome!&quot; unless lame</code></pre><pre><code>

    代码

</code></pre>
]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>liunx</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>全球加速--阿里云</title>
    <url>/2020/01/16/jiasu/</url>
    <content><![CDATA[<h1 id="全球加速"><a href="#全球加速" class="headerlink" title="全球加速"></a>全球加速</h1><p>首先确定加速区域以及服务区域<br><br>例如：业务服务器在华北2（北京）,想让美国的玩家流畅访问,需要购买加速区域在北美,服务区域在中国大陆<br></p>
<p>创建全球加速后，会得到一个美国IP，把这个IP和华北2服务器的IP绑定同一个域名，根据解析路线区分解析。<br><br>如果是北京地区访问这个IP，返回的是华北2的服务器IP。相反如果是美国玩家访问，则会返回全球加速的IP。<br></p>
<pre><code>解析路线：比如，DnsCEO的智能DNS就会自动判断用户的上网路线是联通还是电信，然后智能返回联通或者电信的服务器IP。多线多地区智能DNS，能自动判断用户的上网路线是上海电信还是广东电信，然后智能返回对应的上海电信和广东电信的服务器IP。</code></pre><p>例如：<br>    <br>新加坡实例需要拥有弹性公网IP   (ECS控制台–&gt;更多–&gt;网络和安全组–&gt;公网IP转为弹性公网IP)<br></p>
<pre><code>还需要创建个弹性网卡
    网卡名称：自定义
    专有网络：需同ECS同一网络
    交换机：需同ECS同一网络
    安全组：需同ECS同一网络
然后绑定ECS</code></pre><p>创建一个全球加速实例，在全球加速主界面找到实例，然后添加IP(购买个ip就好)。然后点击创建的ip，绑定一个新加坡的实例</p>
<p>最后域名解析</p>
<p>需要购买一个域名版本管理套餐 绑定一个子域名<br>然后用子域名解析A记录</p>
<pre><code>test    A    世界_北美洲     xxx.xxx.xxx.xxx(全球加速ip)
test    A    默认         xxx.xxx.xxx.xxx(服务器ip)</code></pre>]]></content>
      <categories>
        <category>阿里云</category>
      </categories>
      <tags>
        <tag>阿里云</tag>
      </tags>
  </entry>
  <entry>
    <title>mongodb安装以及基础操作</title>
    <url>/2020/01/08/mongo/</url>
    <content><![CDATA[<h1 id="安装mongo数据库"><a href="#安装mongo数据库" class="headerlink" title="安装mongo数据库"></a>安装mongo数据库</h1><pre><code>cd  /etc/yum.repos.d/
vim   mongodb-org-3.2.repo
[mogodb-org]
name=MongoDB Repository
baseurl=http://mirrors.aliyun.com/mongodb/yum/redhat/6Server/mongodb-org/3.4/x86_64/
gpgcheck=0
enabled=1</code></pre><p>然后保存退出</p>
<pre><code>yum clean all    # 清除缓存
yum install  mongod-org  -y</code></pre><h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><pre><code># mongod.conf

# for documentation of all options, see:
#   http://docs.mongodb.org/manual/reference/configuration-options/

# where to write logging data.
systemLog:
  destination: file
  logAppend: true
  path: /var/log/mongodb/mongod.log     #  日志文件路径

# Where and how to store data.
storage:
  dbPath: /var/lib/mongo    # 数据保存路径
  journal:
    enabled: true        # 是否开启
#  engine:
#  mmapv1:
#  wiredTiger:

# how the process runs
processManagement:
  fork: true  # fork and run in background
  pidFilePath: /var/run/mongodb/mongod.pid  # location of pidfile

# network interfaces
net:
  port: 27017        # 监听端口
  bindIp: 192.168.1.163  # 允许连接的IP


#security:
#security:

#  authorization: enabled

#operationProfiling:

#replication:

#sharding:
## Enterprise-Only Options

#auditLog:

#snmp:</code></pre><h1 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h1><pre><code>mongo   IP   #  进入数据库

show  dbs    # 查看所有库

show tables    # 查看当前库的所有表

use   DBNAME    # 进入数据库

db.table.find()        # 查看表中的所有数据

db.table.find({name : xxx})    # 查看表中name为xxx的数据

db.table.find({name : xxx}).pretty()    # 查看表中name为xxx的数据   以json格式显示

db.table.count()    # 统计数据行数

db.tables.find().count()    # 统计行数   同上

db.table.count({name : xxx})    # 统计name为xxx的行数

db.table.update({},{$set:{name : xxx}})        # 把表中所有数据的name 改为 xxx

db.table.update({name : xxx},{$set:{ID : 666}})        # 把name 为 xxx 的ID 改为666  （只更改匹配到的第一条数据）

db.table.update({name : xxx},{$set:{ID : 666}},false,true)    # 把全部name 为 xxx的ID 改为666  （匹配到的所有数据）

db.payments.update({roleID : xxx, &quot;orderNo&quot; : &quot;xxx&quot;},{$set:{&quot;realMoney_usd&quot; : xxx}},true,false)     # 修改数据如果字段不存在 则新建

db.copyDatabase(&apos;old_name&apos;, &apos;new_name&apos;, &apos;localhost&apos;)    # 复制数据库

use  DBNAME     # 进入数据库
db.dropDatabase()    # 删除当前所在的库

db.table.drop()        # 删除表

db.table.remove({})    # 删除表中所有数据

db.table.remove({name : xxx})    # 删除表中被匹配到的第一条数据

db.table.remove({name : xxx},false,true)    # 删除表中被匹配到的所有数据

use DBNAME     # 进入数据库
db.create.table()    # 创建一个表      如果这个数据库之前不存在  创建表后会自动创建库</code></pre><h1 id="增删改查–扩展"><a href="#增删改查–扩展" class="headerlink" title="增删改查–扩展"></a>增删改查–扩展</h1><pre><code>db.roles.find({&quot;ID&quot;:{&quot;$lte&quot;: 200,&quot;$gte&quot;:155 },userType:41})    # 范围查询  查看ID 小于等于200  大于等于155 并且userType=41 的数据

db.roles.find({ &quot;name&quot; : {$regex:/大气的.*/i}})        # 模糊查询    匹配name 包含&quot;大气的&quot; 数据

db.towers.update({&quot;_id&quot; : ObjectId(&quot;5a6205e275a50f321e04b8ae&quot;)},{$set:{ &quot;levelCustomList.1.state&quot;:2}})        # 把匹配数据的levelCustomlist的第二个字段(state) 的值改为 2

db.oreseasons.update({&quot;_id&quot; : ObjectId(&quot;5ad227d8da0d2e0522930156&quot;)},{$unset:{&quot;groups.0&quot;:&apos;&apos;}},false, true)    # 把匹配数据的groups中第一个字段删除</code></pre><h1 id="数据库的备份以及恢复"><a href="#数据库的备份以及恢复" class="headerlink" title="数据库的备份以及恢复"></a>数据库的备份以及恢复</h1><pre><code>mongodump   -h  IP    -d  DBNAME    -o  dir    # 备份数据库

mongorestore   -h  IP   -d    DBNAME     dir/DBNAME/    # 恢复数据库</code></pre>]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>mongo</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>sshpass</title>
    <url>/2019/12/27/sshpass/</url>
    <content><![CDATA[<h3 id="使用前提：对于未连接过的主机。而又不输入yes进行确认。需要sshd服务的优化："><a href="#使用前提：对于未连接过的主机。而又不输入yes进行确认。需要sshd服务的优化：" class="headerlink" title="使用前提：对于未连接过的主机。而又不输入yes进行确认。需要sshd服务的优化："></a>使用前提：对于未连接过的主机。而又不输入yes进行确认。需要sshd服务的优化：</h3><pre><code># vim /etc/ssh/ssh_config   
StrictHostKeyChecking no
GSSAPIAuthentication no
UseDNS no

# service sshd restart</code></pre><h3 id="sshpass-命令安装："><a href="#sshpass-命令安装：" class="headerlink" title="sshpass 命令安装："></a>sshpass 命令安装：</h3><pre><code># yum -y install sshpass</code></pre><h3 id="sshpass的用法举例"><a href="#sshpass的用法举例" class="headerlink" title="sshpass的用法举例"></a>sshpass的用法举例</h3><pre><code>sshpass -p password ssh -o StrictHostKeyChecking=no lius@192.168.33.56 &quot;ls /tmp&quot;

-p: 指定密码
-o: ssh或scp的一个选项, StrictHostKeyChecking=no表示在第一次主机认证的时候, 自动接收远端主机密钥.</code></pre><h3 id="常用案例"><a href="#常用案例" class="headerlink" title="常用案例"></a>常用案例</h3><pre><code>#!/bin/bash
sshpass  -p password  ssh  -o  StrictHostKeyChecking=no  xxxx@IP  &lt;&lt; restartserver
cd   /subverison/data/
svn update

restartserver</code></pre>]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>sshpass</tag>
      </tags>
  </entry>
  <entry>
    <title>jenkins项目迁移</title>
    <url>/2019/12/24/remove/</url>
    <content><![CDATA[<pre><code>systemctl stop jenkins
cp -rp /var/lib/jenkins /home/jenkins
sed -i s&apos;@/var/lib/jenkins@/home/jenkins@&apos; /etc/sysconfig/jenkins #修改主目录
systemctl start jenkins
rm -rf /var/lib/jenkins</code></pre>]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>jenkins添加普通用户设置权限</title>
    <url>/2019/12/24/jenkins/</url>
    <content><![CDATA[<h3 id="jenkins创建普通用户并配置权限"><a href="#jenkins创建普通用户并配置权限" class="headerlink" title="jenkins创建普通用户并配置权限"></a>jenkins创建普通用户并配置权限</h3><p><br>1、首先在Manage Jenkins –&gt; 用户管理  创建用户<br><br>2、然后在Manage Jenkins –&gt; 全局设置 授权策略选择：<br><br>项目矩阵授权策略  添加用户或者用户组 选择权限<br><br><img src="/2019/12/24/jenkins/1.png" alt><br><br>3、找到需要授权的项目点击配置<br><br><img src="/2019/12/24/jenkins/2.png" alt><br><br>启用项目安全<br><br><img src="/2019/12/24/jenkins/3.png" alt><br><br>添加admin用户以及其他用户<br><br><img src="/2019/12/24/jenkins/4.png" alt><br><br>最后登录测试<br><br><br><br></p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>subversion+jenkinks部署</title>
    <url>/2019/12/03/test/</url>
    <content><![CDATA[<ul>
<li><a href="#1">1.subversion+jenkins安装部署</a><ul>
<li><a href="#2">1.1配置环境</a></li>
<li><a href="#3">1.2安装jenkins</a></li>
<li><a href="#4">1.3安装subversion</a></li>
</ul>
</li>
</ul>
<p>#</p><h4 id="2">1.1配置环境<br>    环境：centos6.9<br>    软件包：jdk-8u60-linux-x64.tar.gz<br>首先关闭selinux和防火墙<br><br><img src="/2019/12/03/test/1.png" alt><br><br>更改时间      &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;–可以写入计划任务中<br><br><img src="/2019/12/03/test/3.png" alt><br><br>创建目录   <p></p>
<pre><code>mkdir /application/</code></pre><p><br>解压jdk包到创建的目录中<br></p>
<pre><code>tar xf jdk-8u60-linux-x64.tar.gz   -C /application/</code></pre><p><br>做软连接<br></p>
<pre><code>ln -s  /application/jdk1.8.0_60/ /application/jdk</code></pre><p><br>设置环境变量<br></p>
<pre><code>sed -i.ori &apos;$a export  JAVA_HOME=/application/jdk\nexport PATH=$JAVA_HOME/bin:$JAVA_HOME/jre/bin:$PATH\nexport  CLASSPATH=.$CLASSPATH:$JAVA_HOME/lib:$JAVA_HOME/jre/lib:$JAVA_HOME/lib/tools.jar&apos;  /etc/profile</code></pre><p><br>source一下生效环境变量<br><br><img src="/2019/12/03/test/2.png" alt><br><br><img src="/2019/12/03/test/4.png" alt><br></p>
<h4 id="3">1.2安装jenkins

<p>下载yum源并且导入秘钥</p>
<br>

<pre><code>wget -O /etc/yum.repos.d/jenkins.repo http://pkg.jenkins-ci.org/redhat/jenkins.repo&lt;br/&gt;

rpm --import https://jenkins-ci.org/redhat/jenkins-ci.org.key</code></pre><p><br><img src="/2019/12/03/test/5.png" alt><br></p>
<pre><code>yum install jenkins -y </code></pre><p><br><img src="/2019/12/03/test/6.png" alt><br></p>
<pre><code>如果安装失败就到官网下载jenkins的rpm包
http://pkg.jenkins-ci.org/redhat-stable/</code></pre><p>编辑配置文件更改端口启动jenkins</p>
<pre><code>vim /etc/sysconfig/jenkins</code></pre><p>找到修改端口号：<br><br>JENKINS_PORT=”8080”  # 此端口不冲突可以不修改<br></p>
<pre><code>service  jenkins  start</code></pre><p><img src="/2019/12/03/test/7.png" alt><br><br>这里会报错 因为Jenkins默认找的jdk环境变量在/usr/bin下  我们需要更改下路径<br></p>
<pre><code>vim  /etc/init.d/jenkins</code></pre><p><br>找到candidates=”   这个配置项<br><br><img src="/2019/12/03/test/8.png" alt><br><br>可以使用这种方式找到路径<br><br><img src="/2019/12/03/test/9.png" alt><br><br>然后在次启动Jenkins    成功<br><br><img src="/2019/12/03/test/10.png" alt><br><br>在浏览器中访问<br><br>首次进入会要求输入初始密码如下图，<br><br><img src="/2019/12/03/test/11.png" alt><br><br>初始密码在：/var/lib/jenkins/secrets/initialAdminPassword<br><img src="/2019/12/03/test/12.png" alt><br><br><img src="/2019/12/03/test/13.png" alt><br><br><img src="/2019/12/03/test/14.png" alt><br><br><img src="/2019/12/03/test/15.png" alt><br><br><img src="/2019/12/03/test/16.png" alt><br><br><img src="/2019/12/03/test/17.png" alt><br><br><img src="/2019/12/03/test/18.png" alt><br><br><img src="/2019/12/03/test/19.png" alt><br><br><img src="/2019/12/03/test/20.png" alt></p>
<h4 id="4">1.3安装subversion

<p>配置好yum源 直接yum安装subversion </p>
<pre><code>yum -y install subversion </code></pre><p><br><img src="/2019/12/03/test/21.png" alt><br><br>查看版本号</p>
<pre><code>svnserve --version</code></pre><p>递归创建目录</p>
<pre><code>mkdir  /data/svn/program   -p</code></pre><p><br><img src="/2019/12/03/test/22.png" alt><br><br>创建svn版本库</p>
<pre><code>svnadmin create /data/svn/program/</code></pre><p>配置账号：</p>
<pre><code>vim /data/svn/program/conf/passwd

    [manager]
    xinlong = xinlong</code></pre><p><br><img src="/2019/12/03/test/23.png" alt><br><br>配置权限：</p>
<pre><code>vim /data/svn/program/conf/authz

    [groups]
    manager = xinlong

    [program:/]
    @manager = rw</code></pre><p><br><img src="/2019/12/03/test/24.png" alt><br><br>配置服务：</p>
<pre><code>vim /data/svn/program/conf/svnserve.conf

    anon-access = none ## 匿名用户可读(关闭)
    auth-access = write ## 授权用户可写
    password-db = /data/svn/program/conf/passwd ## 指定账号配置文件   绝对路径
    authz-db = /data/svn/program/conf/authz ## 指定权限配置文件  绝对路径
    realm = /data/svn/program ## 指定版本库的认证域，即在登录时提示的认证域名称。缺省值：一个UUID(Universal Unique IDentifier，全局唯一标示)。</code></pre><p><br><img src="/2019/12/03/test/25.png" alt><br><br>启动subversion</p>
<pre><code>svnserve -d</code></pre><p>开通HTTP协议 安装httpd及其svn模块</p>
<pre><code>yum -y install httpd mod_dav_svn</code></pre><p><br><img src="/2019/12/03/test/26.png" alt><br><br>确认模块 dav/dav_svn 已加载<br><br>(Centos6  路径是/etc/httpd/conf/httpd.conf )<br></p>
<pre><code>grep -E &quot;dav_module&quot; /etc/httpd/conf.modules.d/00-dav.conf</code></pre><p><br><img src="/2019/12/03/test/27.png" alt><br><br>( Centos6  路径是 /etc/httpd/conf.d/subversion.conf )</p>
<pre><code>grep -E &quot;dav_svn_module&quot; /etc/httpd/conf.modules.d/10-subversion.conf</code></pre><p><br><img src="/2019/12/03/test/28.png" alt><br><br>SVN HTTP 配置</p>
<pre><code>vim /etc/httpd/conf/httpd.conf

    &lt;Location /program&gt;
    DAV svn
    SVNPath /data/svn/program
    AuthType Basic
    AuthName &quot;SVN program repository&quot;
    AuthUserFile /data/svn/program/conf/svn-auth.htpasswd
    AuthzSVNAccessFile /data/svn/program/conf/authz
    # Authorization: Authenticated users only
    # SVNListParentPath on
    Satisfy all
    Require valid-user
    &lt;/Location&gt;</code></pre><p><br><img src="/2019/12/03/test/29.png" alt><br><br>创建 SVN HTTP 用户</p>
<pre><code>-m 表示以 md5 加密密码

touch  /data/svn/program/conf/svn-auth.htpasswd</code></pre><p><br><img src="/2019/12/03/test/30.png" alt><br></p>
<pre><code>htpasswd -m  /data/svn/program/conf/svn-auth.htpasswd    xinlong</code></pre><p><br><img src="/2019/12/03/test/31.png" alt><br><br>启动httpd服务<br><br><img src="/2019/12/03/test/32.png" alt><br><br>客户端验证(<a href="http://xxx" target="_blank" rel="noopener">http://xxx</a>)</p>
<p>Windows 下使用 Chrome 浏览器访问: <a href="http://ip/program/，输入用户名" target="_blank" rel="noopener">http://ip/program/，输入用户名</a> chalres 及其密码，成功。<br><br><img src="/2019/12/03/test/33.png" alt><br><br><br>TortoiseSVN检测<br><br>右击  点击SVN checkout<br><br><img src="/2019/12/03/test/34.png" alt><br><br><img src="/2019/12/03/test/35.png" alt><br><br><img src="/2019/12/03/test/36.png" alt><br><br><img src="/2019/12/03/test/37.png" alt><br><br><img src="/2019/12/03/test/38.png" alt><br><br>然后右击 点击SVN commit</p>
<p><img src="/2019/12/03/test/39.png" alt><br><br><img src="/2019/12/03/test/40.png" alt><br><br><img src="/2019/12/03/test/41.png" alt><br><br><img src="/2019/12/03/test/42.png" alt><br><br>访问网站也可以看到</p>
<p><img src="/2019/12/03/test/43.png" alt><br><br><img src="/2019/12/03/test/44.png" alt><br></p>
<h3 id="进入Jenkins的主界面点击新建或创建一个新任务"><a href="#进入Jenkins的主界面点击新建或创建一个新任务" class="headerlink" title="进入Jenkins的主界面点击新建或创建一个新任务"></a>进入Jenkins的主界面点击新建或创建一个新任务<br></h3><p><br>输入项目的名字选择自由风格点击OK<br><br><img src="/2019/12/03/test/45.png" alt><br><br><img src="/2019/12/03/test/46.png" alt><br><br>选择源码管理中的Subversion(SVN) 填写第五步搭建SVN的地址(里面需要有代码)<br><br><img src="/2019/12/03/test/47.png" alt><br><br><img src="/2019/12/03/test/48.png" alt><br><br><img src="/2019/12/03/test/49.png" alt><br><br><img src="/2019/12/03/test/50.png" alt><br><br><img src="/2019/12/03/test/51.png" alt><br><br><img src="/2019/12/03/test/52.png" alt><br><br><img src="/2019/12/03/test/53.png" alt><br><br><img src="/2019/12/03/test/54.png" alt></p>
<pre><code>    #!/bin/bash
date=`date +&quot;%H:%M&quot;`
file=`ls -l  /data/program/  |grep db  |awk -F&quot; &quot; &apos;{print $(NF-1)}&apos;`
if [ &quot;$date&quot; == &quot;$file&quot; ];then
echo &quot;no&quot;
else
echo &quot;checkout&quot;
svn  checkout  http://192.168.1.240/program/  /data/install/   --username  xinlong
echo &quot;OK&quot; &gt;/data/ok.txt
echo &quot;OK&quot;
fi</code></pre><p><br><img src="/2019/12/03/test/55.png" alt><br><br><img src="/2019/12/03/test/56.png" alt><br><br><img src="/2019/12/03/test/57.png" alt><br><br><img src="/2019/12/03/test/58.png" alt><br><br><img src="/2019/12/03/test/59.png" alt><br><br><img src="/2019/12/03/test/60.png" alt><br><br><img src="/2019/12/03/test/61.png" alt><br><br><img src="/2019/12/03/test/62.png" alt><br><br><img src="/2019/12/03/test/63.png" alt><br><br><img src="/2019/12/03/test/64.png" alt><br><br><img src="/2019/12/03/test/65.png" alt><br><br><img src="/2019/12/03/test/66.png" alt><br><br><img src="/2019/12/03/test/67.png" alt><br><br><img src="/2019/12/03/test/68.png" alt><br><br><img src="/2019/12/03/test/69.png" alt><br></p>
<h3 id="下面步骤可以更改http-svn-为https"><a href="#下面步骤可以更改http-svn-为https" class="headerlink" title="下面步骤可以更改http svn 为https"></a>下面步骤可以更改http svn 为https</h3><p><br>开通 HTTPS 协议<br></p>
<h3 id="3-1-安装-ssl-模块"><a href="#3-1-安装-ssl-模块" class="headerlink" title="3.1 安装 ssl 模块"></a>3.1 安装 ssl 模块</h3><pre><code>yum -y install mod_ssl openssl</code></pre><h3 id="3-2-生成证书"><a href="#3-2-生成证书" class="headerlink" title="3.2 生成证书"></a>3.2 生成证书</h3><pre><code>mkdir /etc/httpd/ssl
cp nginx.key /etc/httpd/ssl/httpd.key
cp nginx.crt /etc/httpd/ssl/httpd.crt</code></pre><h3 id="3-3-配置证书"><a href="#3-3-配置证书" class="headerlink" title="3.3 配置证书"></a>3.3 配置证书</h3><pre><code>vim /etc/httpd/conf.d/ssl.conf
SSLCertificateFile    /etc/httpd/ssl/httpd.crt
SSLCertificateKeyFile /etc/httpd/ssl/httpd.key</code></pre><p>如果要停用 https 改用 http，只需注释下面的 SSLRequireSSL 一行。</p>
<pre><code>vim /etc/httpd/conf/httpd.conf

&lt;Location /program&gt;
    ## ......

    Require valid-user
    SSLRequireSSL
&lt;/Location&gt;</code></pre><h3 id="3-4-重启服务"><a href="#3-4-重启服务" class="headerlink" title="3.4 重启服务"></a>3.4 重启服务</h3><pre><code>systemctl restart httpd</code></pre><h3 id="3-5-防火墙放行"><a href="#3-5-防火墙放行" class="headerlink" title="3.5 防火墙放行"></a>3.5 防火墙放行</h3><pre><code>vim /etc/sysconfig/iptables
-A INPUT -m state --state NEW -m tcp -p tcp --dport 443 -j ACCEPT</code></pre><p>重启生效</p>
<pre><code>sudo systemctl restart iptables</code></pre><h3 id="3-6-客户端验证-https-xxx"><a href="#3-6-客户端验证-https-xxx" class="headerlink" title="3.6 客户端验证(https://xxx)"></a>3.6 客户端验证(<a href="https://xxx" target="_blank" rel="noopener">https://xxx</a>)</h3><p><br>Windows 下使用 Chrome 浏览器访问: <a href="https://ip/program/，输入用户名" target="_blank" rel="noopener">https://ip/program/，输入用户名</a> charles 及其密码，成功。此时只能使用 https 访问，http 已被禁用。<br><br><br><br><br><br><br></p>
</h4></h4></h4>]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>jenkins</tag>
        <tag>subversion</tag>
      </tags>
  </entry>
</search>
