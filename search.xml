<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>zabbix报错解决</title>
    <url>/2020/07/02/zabbix-error/</url>
    <content><![CDATA[<h2 id="下载yum源报错"><a href="#下载yum源报错" class="headerlink" title="下载yum源报错"></a>下载yum源报错</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[sgsm@localhost yum.repos.d]$ sudo  rpm -ivh http://repo.zabbix.com/zabbix/4.0/rhel/7/x86_64/zabbix-release-4.0-1.el7.noarch.rpm </span><br><span class="line">	获取http://repo.zabbix.com/zabbix/4.0/rhel/7/x86_64/zabbix-release-4.0-1.el7.noarch.rpm</span><br><span class="line">	准备中...                          <span class="comment">################################# [100%]</span></span><br><span class="line">        file /etc/yum.repos.d/zabbix.repo from install of zabbix-release-4.0-1.el7.noarch conflicts with file from package zabbix-release-3.2-1.el7.noarch</span><br></pre></td></tr></table></figure>
<p>这是因为服务器上已经部署了zabbix,卸载原来的zabbix就可以了 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum  remove   zabbix-release-3.2-1.el7.noarch   -y</span><br></pre></td></tr></table></figure>

<h2 id="后台登录密码忘记"><a href="#后台登录密码忘记" class="headerlink" title="后台登录密码忘记"></a>后台登录密码忘记</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; use zabbix</span><br><span class="line">	Reading table information <span class="keyword">for</span> completion of table and column names</span><br><span class="line">	You can turn off this feature to get a quicker startup with -A</span><br><span class="line"></span><br><span class="line">	Database changed</span><br><span class="line">mysql&gt; update users <span class="built_in">set</span> passwd=<span class="string">'5fce1b3e34b520afeffb37ce08c7cd66'</span> <span class="built_in">where</span> userid=<span class="string">'1'</span>;</span><br><span class="line">	Query OK, 1 row affected (0.01 sec)</span><br><span class="line">	Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line">		</span><br><span class="line"><span class="comment"># 由于密码是md5加密的，我们可以查看默认的zabbix密码的md5</span></span><br><span class="line">mysql&gt; use zabbix;</span><br><span class="line"></span><br><span class="line">mysql&gt; update users <span class="built_in">set</span> passwd=<span class="string">'5fce1b3e34b520afeffb37ce08c7cd66'</span> <span class="built_in">where</span> userid=<span class="string">'1'</span>;</span><br></pre></td></tr></table></figure>
<p>重新设置密码为zabbix,然后重新登陆 用户：Admin   密码：zabbix</p>
<h2 id="zabbix设置中文出现乱码"><a href="#zabbix设置中文出现乱码" class="headerlink" title="zabbix设置中文出现乱码"></a>zabbix设置中文出现乱码</h2><p>zabbix语言设置为中文后,有乱码如下：<br><br><img src="/2020/07/02/zabbix-error/1.png" alt><br></p>
<p>1.从 windows 下控制面板-&gt;字体-&gt;选择一种中文字库例如“楷体”<br><br><img src="/2020/07/02/zabbix-error/2.png" alt><br><br><img src="/2020/07/02/zabbix-error/3.png" alt><br><br><br><br>2.将字体上传至/usr/share/zabbix/assets/fonts (根据zabbix的安装位置 可以使用find查找一下路径) 目录下<br><br><img src="/2020/07/02/zabbix-error/99.png" alt><br><br>注意：查找到zabbix有两个fonts目录 就去配置文件看下使用的那个目录(版本不同 路径就不同)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[sgsm@localhost fonts]$ cat ../include/defines.inc.php   |grep  path</span><br><span class="line">define(<span class="string">'ZBX_FONTPATH'</span>,                          realpath(<span class="string">'assets/fonts'</span>)); // <span class="built_in">where</span> to search <span class="keyword">for</span> font (GD &gt; 2.0.18)</span><br><span class="line">[sgsm@localhost fonts]$</span><br></pre></td></tr></table></figure>

<p><br>使用rz 拉取到服务器<br><br><img src="/2020/07/02/zabbix-error/7.png" alt></p>
<p>3.修改 zabbix 页面管理的中文字体设置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@zabbix-server zabbix-2.4.5]<span class="comment"># vim /usr/share/zabbix/include/defines.inc.php</span></span><br><span class="line"><span class="comment">#修改如下 2 行</span></span><br><span class="line">define(<span class="string">'ZBX_FONT_NAME'</span>, <span class="string">'simkai'</span>);</span><br><span class="line">define(<span class="string">'ZBX_GRAPH_FONT_NAME'</span>, <span class="string">'simkai'</span>);</span><br><span class="line">修改后的 zabbix 界面。</span><br></pre></td></tr></table></figure>
<p>修改后的 zabbix 界面<br><br><img src="/2020/07/02/zabbix-error/5.png" alt><br></p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>liunx</tag>
      </tags>
  </entry>
  <entry>
    <title>zabbix配置微信告警</title>
    <url>/2020/06/30/zabbix-wechat/</url>
    <content><![CDATA[<h2 id="首先需要申请一个企业号"><a href="#首先需要申请一个企业号" class="headerlink" title="首先需要申请一个企业号"></a>首先需要申请一个企业号</h2><p>申请企业号，需要一个绑定你本人开户银行卡的微信号。<br><br>申请网址 <a href="https://qy.weixin.qq.com/" target="_blank" rel="noopener">https://qy.weixin.qq.com/</a><br><br>点击“立即注册”。<br><br>根据提示注册企业号，到“选择类型”时，选择最右边的企业号。<br><br>注意：企业描述中：“报警”是敏感词不能使用。<br><br>登录之后，可以看到如下页面<br><br><img src="/2020/06/30/zabbix-wechat/1.png" alt><br><br>按照下图依次点击。<br><br><img src="/2020/06/30/zabbix-wechat/2.png" alt><br><br><img src="/2020/06/30/zabbix-wechat/3.png" alt><br><br><img src="/2020/06/30/zabbix-wechat/4.png" alt></p>
<h2 id="关注企业号的方法"><a href="#关注企业号的方法" class="headerlink" title="关注企业号的方法"></a>关注企业号的方法</h2><p>点击左侧的“设置”-二维码，使用微信扫一扫扫描二维码<br><br><img src="/2020/06/30/zabbix-wechat/5.png" alt><br><br>点击左侧列的“应用中心”，点击“我的应用”下面的加号<br><br><img src="/2020/06/30/zabbix-wechat/6.png" alt><br><br>填写应用名称，描述。一切正常的话，点击进入刚才创建的应用<br><br><img src="/2020/06/30/zabbix-wechat/7.png" alt><br><br>这里的应用 id 号需要记住。后面需要填写</p>
<h2 id="设置管理员"><a href="#设置管理员" class="headerlink" title="设置管理员"></a>设置管理员</h2><p>设置-功能设置-权限管理-新建管理组<br><br><img src="/2020/06/30/zabbix-wechat/8.png" alt><br><br><img src="/2020/06/30/zabbix-wechat/9.png" alt><br><br><img src="/2020/06/30/zabbix-wechat/10.png" alt><br><br>注意：这里要记录下来下面的 CorpID 和 Secret。</p>
<h2 id="编写脚本"><a href="#编写脚本" class="headerlink" title="编写脚本"></a>编写脚本</h2><p>在/usr/lib/zabbix/alertscripts目录(配置文件定义)下新建一个名为 wechat.sh 的脚本文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">CropID=<span class="string">'ww13d3c1c55e5d3414'</span>   <span class="comment"># 企业id-在网页应用管理可以查到</span></span><br><span class="line">Secret=<span class="string">'-qo7YckISjsL11u8kI5PF0gGJrjYKlk0ISF2ftAPuzQ'</span>   <span class="comment"># SecretID-在网页应用管理可以查到</span></span><br><span class="line">GURL=<span class="string">"https://qyapi.weixin.qq.com/cgi-bin/gettoken?corpid=<span class="variable">$CropID</span>&amp;corpsecret=<span class="variable">$Secret</span>"</span></span><br><span class="line">Gtoken=`/usr/bin/curl -s -G <span class="variable">$GURL</span> | awk -F<span class="string">'access_token":"'</span> <span class="string">'&#123;print $2&#125;'</span>|awk -F<span class="string">'"'</span> <span class="string">'&#123;print $1&#125;'</span> `</span><br><span class="line">PURL=<span class="string">"https://qyapi.weixin.qq.com/cgi-bin/message/send?access_token=<span class="variable">$Gtoken</span>"</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">body</span></span>() &#123;</span><br><span class="line"><span class="built_in">local</span> int AppID=1000002  <span class="comment"># 应用id-在网页应用管理可以查到</span></span><br><span class="line"><span class="built_in">local</span> UserID=<span class="variable">$1</span></span><br><span class="line"><span class="built_in">local</span> PartyID=1</span><br><span class="line"><span class="built_in">local</span> Msg=$(<span class="built_in">echo</span> <span class="string">"<span class="variable">$@</span>"</span> | cut -d<span class="string">" "</span> -f3-)</span><br><span class="line"><span class="built_in">printf</span> <span class="string">'&#123;\n'</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">'\t"touser": "'</span><span class="string">"<span class="variable">$User</span>"</span>\"<span class="string">",\n"</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">'\t"toparty": "'</span><span class="string">"<span class="variable">$PartyID</span>"</span>\"<span class="string">",\n"</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">'\t"msgtype": "text",\n'</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">'\t"agentid": "'</span><span class="string">" <span class="variable">$AppID</span> "</span>\"<span class="string">",\n"</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">'\t"text": &#123;\n'</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">'\t\t"content": "'</span><span class="string">"<span class="variable">$Msg</span>"</span>\"<span class="string">"\n"</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">'\t&#125;,\n'</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">'\t"safe":"0"\n'</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">'&#125;\n'</span></span><br><span class="line">&#125;</span><br><span class="line">/usr/bin/curl --data-ascii <span class="string">"<span class="variable">$(body $1 $2 $3)</span>"</span> <span class="variable">$PURL</span></span><br></pre></td></tr></table></figure>
<p>需要设置权限不然调用的时候会报错没有权限</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo  chown zabbix:zabbix   wechat.sh  -R </span><br><span class="line">sudo  chmod +x     wechat.sh</span><br></pre></td></tr></table></figure>
<p>执行./wechat.sh 1 1 test 看自己微信是否能收到信息，如果能的话，继续下一步。反之检查上面有什么问题。</p>
<h2 id="zabbix后台配置"><a href="#zabbix后台配置" class="headerlink" title="zabbix后台配置"></a>zabbix后台配置</h2><p>管理—示警介类型—创建媒体类型<br><br>创建报警媒介类型 (脚本参数分别对应：收件人地址、主题、详细内容)<br><br><img src="/2020/06/30/zabbix-wechat/21.png" alt><br><br>配置用户 选择admin用户<br><br><img src="/2020/06/30/zabbix-wechat/22.png" alt><br><br>添加报警媒介<br><br><img src="/2020/06/30/zabbix-wechat/23.png" alt><br><br>创建报警动作 配置-动作-创建动作,新建动作<br><br><img src="/2020/06/30/zabbix-wechat/24.png" alt><br><br>新建操作<br><br><img src="/2020/06/30/zabbix-wechat/25.png" alt><br><br><img src="/2020/06/30/zabbix-wechat/26.png" alt><br></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">操作</span><br><span class="line"></span><br><span class="line">	故障&#123;TRIGGER.STATUS&#125;,服务器:&#123;HOSTNAME1&#125;发生: &#123;TRIGGER.NAME&#125;故障!</span><br><span class="line">	</span><br><span class="line">	告警主机:&#123;HOSTNAME1&#125;</span><br><span class="line">	告警时间:&#123;EVENT.DATE&#125; &#123;EVENT.TIME&#125;</span><br><span class="line">	告警等级:&#123;TRIGGER.SEVERITY&#125;</span><br><span class="line">	告警信息: &#123;TRIGGER.NAME&#125;</span><br><span class="line">	告警项目:&#123;TRIGGER.KEY1&#125;</span><br><span class="line">	问题详情:&#123;ITEM.NAME&#125;:&#123;ITEM.VALUE&#125;</span><br><span class="line">	当前状态:&#123;TRIGGER.STATUS&#125;:&#123;ITEM.VALUE1&#125;</span><br><span class="line">	事件 ID:&#123;EVENT.ID&#125;</span><br></pre></td></tr></table></figure>

<p>添加恢复操作<br><br><img src="/2020/06/30/zabbix-wechat/27.png" alt><br></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">恢复操作</span><br><span class="line"></span><br><span class="line">	恢复&#123;TRIGGER.STATUS&#125;, 服务器:&#123;HOSTNAME1&#125;: &#123;TRIGGER.NAME&#125;已恢复!</span><br><span class="line">	</span><br><span class="line">	告警主机:&#123;HOSTNAME1&#125;</span><br><span class="line">	告警时间:&#123;EVENT.DATE&#125; &#123;EVENT.TIME&#125;</span><br><span class="line">	告警等级:&#123;TRIGGER.SEVERITY&#125;</span><br><span class="line">	告警信息: &#123;TRIGGER.NAME&#125;</span><br><span class="line">	告警项目:&#123;TRIGGER.KEY1&#125;</span><br><span class="line">	问题详情:&#123;ITEM.NAME&#125;:&#123;ITEM.VALUE&#125;</span><br><span class="line">	当前状态:&#123;TRIGGER.STATUS&#125;:&#123;ITEM.VALUE1&#125;</span><br><span class="line">	事件 ID:&#123;EVENT.ID&#125;</span><br></pre></td></tr></table></figure>

<p>配置完成后测试(修改触发器或者关闭进程)<br><br><img src="/2020/06/30/zabbix-wechat/28.png" alt><br><br><img src="/2020/06/30/zabbix-wechat/29.png" alt><br><br><img src="/2020/06/30/zabbix-wechat/30.png" alt><br></p>
<h2 id="邮件内容以及在动作日志中查看发送记录"><a href="#邮件内容以及在动作日志中查看发送记录" class="headerlink" title="邮件内容以及在动作日志中查看发送记录"></a>邮件内容以及在动作日志中查看发送记录</h2><p><img src="/2020/06/30/zabbix-wechat/35.png" alt></p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>liunx</tag>
      </tags>
  </entry>
  <entry>
    <title>zabbix监控搭建及配置邮件报警</title>
    <url>/2020/06/29/zabbix/</url>
    <content><![CDATA[<h2 id="环境配置-server端和agent端"><a href="#环境配置-server端和agent端" class="headerlink" title="环境配置(server端和agent端)"></a>环境配置(server端和agent端)</h2><p>升级系统组件到最新的版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo  yum -y update</span><br></pre></td></tr></table></figure>
<p>关闭selinux</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">setenforce 0       <span class="comment">#临时关闭命令</span></span><br><span class="line">vi /etc/selinux/config    <span class="comment">#将SELINUX=enforcing改为SELINUX=disabled 设置后需要重启才能生效</span></span><br><span class="line">getenforce         <span class="comment">#检测selinux是否关闭，Disabled 为关闭</span></span><br></pre></td></tr></table></figure>
<p>关闭防火墙</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --state    <span class="comment">#查看默认防火墙状态，关闭后显示not running，开启后显示running</span></span><br><span class="line">systemctl stop firewalld.service    <span class="comment">#临时关闭firewal</span></span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld.service <span class="comment">#禁止firewall开机启动</span></span><br></pre></td></tr></table></figure>

<h2 id="zabbix服务端配置-server端"><a href="#zabbix服务端配置-server端" class="headerlink" title="zabbix服务端配置(server端)"></a>zabbix服务端配置(server端)</h2><p>zabbix需要借助LAMP或者LNMP环境,LAMP比较方便配置所以先搭建LAMP环境</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装软件包和其他工具包</span></span><br><span class="line"> yum install -y httpd mariadb-server mariadb php php-mysql php-gd libjpeg* php-ldap php-odbc php-pear php-xml php-xmlrpc php-mhash</span><br><span class="line"> rpm -qa httpd php   mariadb   </span><br><span class="line"> <span class="comment"># 或者  </span></span><br><span class="line"> rpm -qa httpd php mysql-community-server</span><br></pre></td></tr></table></figure>
<p>添加首页支持格式　</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim  /etc/httpd/conf/httpd.conf</span><br><span class="line">     DirectoryIndex index.html index.php</span><br></pre></td></tr></table></figure>
<p>配置时区  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/php.ini</span><br><span class="line">      date.timezone = PRC</span><br></pre></td></tr></table></figure>
<p>启动并加入开启自启动</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl start httpd   <span class="comment">#启动并加入开机自启动httpd</span></span><br><span class="line">systemctl <span class="built_in">enable</span> httpd</span><br><span class="line">systemctl start mysqld  <span class="comment">#启动并加入开机自启动mysqld</span></span><br><span class="line">systemctl <span class="built_in">enable</span> mysqld</span><br><span class="line"></span><br><span class="line">ss -anplt | grep httpd   <span class="comment">#查看httpd启动情况，80端口监控表示httpd已启动</span></span><br><span class="line">ss -naplt | grep mysqld  <span class="comment">#查看mysqld启动情况，3306端口监控表示mysqld已启动</span></span><br></pre></td></tr></table></figure>
<p>创建一个测试页测试</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo  sh -c <span class="string">'echo "&lt;?php echo phpinfo();?&gt;"  &gt; index.php '</span>  </span><br><span class="line"><span class="comment"># 直接使用sudo echo 会提示权限不足   例如：sudo echo "&lt;?php echo phpinfo();?&gt;"  &gt; index.php</span></span><br></pre></td></tr></table></figure>
<p><img src="/2020/06/29/zabbix/1.png" alt></p>
<h2 id="数据库配置-server端"><a href="#数据库配置-server端" class="headerlink" title="数据库配置(server端)"></a>数据库配置(server端)</h2><p>初始化数据库设置数据库root密码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mysqladmin -u root password 123456  </span><br><span class="line"></span><br><span class="line"><span class="comment">#root用户登陆数据库</span></span><br><span class="line">mysql -u root -p123456       </span><br><span class="line"><span class="comment">#创建zabbix数据库（中文编码格式）</span></span><br><span class="line">CREATE DATABASE zabbix character <span class="built_in">set</span> utf8 collate utf8_bin;   </span><br><span class="line"><span class="comment">#授予zabbix用户zabbix数据库的所有权限，密码admin123</span></span><br><span class="line">GRANT all ON zabbix.* TO <span class="string">'zabbix'</span>@<span class="string">'%'</span> IDENTIFIED BY <span class="string">'admin123'</span>;  </span><br><span class="line"><span class="comment">#刷新权限</span></span><br><span class="line">flush privileges;   </span><br><span class="line"><span class="comment">#退出数据库 </span></span><br><span class="line">quit</span><br></pre></td></tr></table></figure>
<p><img src="/2020/06/29/zabbix/2.png" alt></p>
<p>数据库连接测试页</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /var/www/html/index.php </span><br><span class="line">    &lt;?php</span><br><span class="line">    <span class="variable">$link</span>=mysql_connect(<span class="string">'172.18.20.224'</span>,<span class="string">'zabbix'</span>,<span class="string">'admin123'</span>); </span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$link</span>) <span class="built_in">echo</span> <span class="string">"&lt;h1&gt;Success!!&lt;/h1&gt;"</span>;   <span class="comment">#显示Success表示连接数据库成功</span></span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">echo</span> <span class="string">"Fail!!"</span>;</span><br><span class="line">    mysql_close();</span><br><span class="line">    ?&gt;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/06/29/zabbix/3.png" alt></p>
<h2 id="安装zabbix-server端"><a href="#安装zabbix-server端" class="headerlink" title="安装zabbix(server端)"></a>安装zabbix(server端)</h2><p>安装依赖包和组件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo  yum -y install net-snmp net-snmp-devel curl curl-devel libxml2 libxml2-devel libevent-devel.x86_64 javacc.noarch  javacc-javadoc.noarch javacc-maven-plugin.noarch javacc*</span><br><span class="line"><span class="comment"># 安装php支持zabbix组件</span></span><br><span class="line">sudo  yum install php-bcmath php-mbstring -y </span><br><span class="line"><span class="comment"># 会自动生成yum源文件，保证系统可以上网</span></span><br><span class="line">sudo  rpm -ivh http://repo.zabbix.com/zabbix/4.0/rhel/7/x86_64/zabbix-release-4.0-1.el7.noarch.rpm  </span><br><span class="line"><span class="comment"># 清理yum缓存</span></span><br><span class="line">sudo yum clean all </span><br><span class="line"><span class="comment"># 安装zabbix组件</span></span><br><span class="line">sudo  yum install zabbix-server-mysql zabbix-web-mysql -y</span><br></pre></td></tr></table></figure>
<p>安装zabbix后会有一个数据库文件,需要把这个文件恢复到数据库中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span>   /usr/share/doc/zabbix-server-mysql-4.0.21/</span><br><span class="line"><span class="comment">#导入数据到数据库zabbix中(最后一个zabbix是数据库zabbix)，且因为用户zabbix是%(任意主机)，所以登录时需要加上当前主机ip(-h 192.168.1.122),密码是用户zabbix登陆密码admin123</span></span><br><span class="line">sudo  zcat  create.sql.gz | mysql -uzabbix -p -h 192.168.1.122 zabbix</span><br></pre></td></tr></table></figure>

<p>在配置文件中配置数据库用户及密码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim  /etc/zabbix/zabbix_server.conf </span><br><span class="line"></span><br><span class="line">    DBHost=192.168.1.122</span><br><span class="line">    DBName=zabbix</span><br><span class="line">    DBUser=zabbix</span><br><span class="line">    DBPassword=admin123</span><br></pre></td></tr></table></figure>
<p>确定数据库用户及密码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep -n <span class="string">'^'</span>[a-Z] /etc/zabbix/zabbix_server.conf</span><br></pre></td></tr></table></figure>

<p>修改时区</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo  vim /etc/httpd/conf.d/zabbix.conf  </span><br><span class="line"><span class="comment"># 将# php_value date.timezone Europe/Riga 变更成php_value date.timezone Asia/Shanghai</span></span><br><span class="line"></span><br><span class="line">    php_value date.timezone Asia/Shanghai</span><br></pre></td></tr></table></figure>
<p>启动并加入开机自启动zabbix-server</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> zabbix-server </span><br><span class="line">systemctl start zabbix-server</span><br><span class="line"><span class="comment">#   监听在10051端口上,如果没监听成功，可重启zabbix-server服务试试</span></span><br><span class="line">netstat -anpt | grep zabbix</span><br></pre></td></tr></table></figure>
<p>默认用户和密码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">默认账号Admin</span><br><span class="line">默认密码为zabbix  密码经过MD5加密后为5fce1b3e34b520afeffb37ce08c7cd66</span><br></pre></td></tr></table></figure>
<h2 id="welcom-zabbix-后台"><a href="#welcom-zabbix-后台" class="headerlink" title="welcom zabbix(后台)"></a>welcom zabbix(后台)</h2><p>如果以上步骤无误，现在可以使用web打开   </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http://192.168.1.122/zabbix　  <span class="comment"># 注意这里IE浏览器打不开,使用其他浏览器</span></span><br></pre></td></tr></table></figure>

<p><img src="/2020/06/29/zabbix/5.png" alt><br><br>这里必须全部都是OK<br><br><img src="/2020/06/29/zabbix/6.png" alt><br><br><img src="/2020/06/29/zabbix/7.png" alt><br><br><img src="/2020/06/29/zabbix/8.png" alt><br><br><img src="/2020/06/29/zabbix/9.png" alt><br><br>安装成功<br><br><img src="/2020/06/29/zabbix/10.png" alt><br><br>进入界面后设置语言<br><br><img src="/2020/06/29/zabbix/11.png" alt><br><br>选择Chinese<br><br><img src="/2020/06/29/zabbix/12.png" alt><br></p>
<h2 id="Agent端配置-agent端"><a href="#Agent端配置-agent端" class="headerlink" title="Agent端配置(agent端)"></a>Agent端配置(agent端)</h2><p>安装依赖包和组件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo  yum -y install net-snmp net-snmp-devel curl curl-devel libxml2 libxml2-devel libevent-devel.x86_64 javacc.noarch  javacc-javadoc.noarch javacc-maven-plugin.noarch javacc*</span><br><span class="line"><span class="comment"># 安装php支持zabbix组件</span></span><br><span class="line">sudo  yum install php-bcmath php-mbstring -y </span><br><span class="line"><span class="comment"># 会自动生成yum源文件，保证系统可以上网</span></span><br><span class="line">sudo  rpm -ivh http://repo.zabbix.com/zabbix/4.0/rhel/7/x86_64/zabbix-release-4.0-1.el7.noarch.rpm  </span><br><span class="line"><span class="comment"># 清理yum缓存</span></span><br><span class="line">sudo yum clean all </span><br><span class="line"><span class="comment"># 安装zabbix-agent </span></span><br><span class="line">sudo   yum install zabbix-agent  -y</span><br></pre></td></tr></table></figure>
<p>修改zabbix-agent的配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim   /etc/zabbix/zabbix_agentd.conf</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 指定zabbix服务器的IP</span></span><br><span class="line">    Server=192.168.1.122    </span><br><span class="line">    <span class="comment"># 指定zabbix服务器的IP</span></span><br><span class="line">    ServerActive=192.168.1.122  </span><br><span class="line">    <span class="comment"># 指定后台显示名称</span></span><br><span class="line">    Hostname=<span class="built_in">test</span>     </span><br><span class="line">    <span class="comment"># 是否支持自定义key  默认为 0  不支持</span></span><br><span class="line">    UnsafeUserParameters=1   </span><br><span class="line">			</span><br><span class="line">    <span class="comment"># 自定义key  监控项</span></span><br><span class="line">    UserParameter=prod.redis,ps -ef|grep <span class="string">'redis'</span> |grep -v <span class="string">'grep'</span>|wc -l     </span><br><span class="line">    <span class="comment"># 自定义key  监控项</span></span><br><span class="line">    UserParameter=prod.mongo,ps -ef|grep <span class="string">'mongo'</span> |grep -v <span class="string">'grep'</span>|wc -l   </span><br><span class="line">    <span class="comment"># 自定义key  监控项  </span></span><br><span class="line">    UserParameter=prod.node,ps -ef|grep <span class="string">'node'</span> |grep -v <span class="string">'grep'</span>|wc -l</span><br></pre></td></tr></table></figure>
<p>启动agent端</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/usr/sbin/zabbix_agentd  -c /etc/zabbix/zabbix_agentd.conf     <span class="comment"># 启动agent端</span></span><br><span class="line">systemctl  restart   zabbix-agent   <span class="comment"># 重启</span></span><br></pre></td></tr></table></figure>

<h2 id="zabbix服务器上测试-server端"><a href="#zabbix服务器上测试-server端" class="headerlink" title="zabbix服务器上测试(server端)"></a>zabbix服务器上测试(server端)</h2><p>需要下载 zabbix-get</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum install  zabbix-get   -y</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[sgsm@localhost zabbix-server-mysql-4.0.21]$ zabbix_get -s 192.168.1.220 -p 10050 -k prod.redis     <span class="comment"># 显示数值 代表成功</span></span><br><span class="line">1  </span><br><span class="line">[sgsm@localhost zabbix-server-mysql-4.0.21]$</span><br></pre></td></tr></table></figure>

<h2 id="zabbix后台配置监控项-后台"><a href="#zabbix后台配置监控项-后台" class="headerlink" title="zabbix后台配置监控项(后台)"></a>zabbix后台配置监控项(后台)</h2><p>创建群组<br><br><img src="/2020/06/29/zabbix/13.png" alt><br><br>设置组名<br><br><img src="/2020/06/29/zabbix/14.png" alt><br><br><img src="/2020/06/29/zabbix/15.png" alt><br><br>创建主机<br><br><img src="/2020/06/29/zabbix/16.png" alt><br><br><img src="/2020/06/29/zabbix/18.png" alt><br><br><img src="/2020/06/29/zabbix/19.png" alt><br><br><img src="/2020/06/29/zabbix/20.png" alt><br><br><img src="/2020/06/29/zabbix/21.png" alt><br><br>创建监控项<br><br><img src="/2020/06/29/zabbix/22.png" alt><br><br><img src="/2020/06/29/zabbix/23.png" alt><br><br><img src="/2020/06/29/zabbix/24.png" alt><br><br>创建触发器<br><br><img src="/2020/06/29/zabbix/25.png" alt><br><br><img src="/2020/06/29/zabbix/26.png" alt><br><br><img src="/2020/06/29/zabbix/27.png" alt><br><br><img src="/2020/06/29/zabbix/28.png" alt><br><br>可以在最新数据查看当前值<br><br><img src="/2020/06/29/zabbix/29.png" alt><br><br><img src="/2020/06/29/zabbix/30.png" alt></p>
<p>修改状态测试<br><br><img src="/2020/06/29/zabbix/31.png" alt><br><br><img src="/2020/06/29/zabbix/32.png" alt><br><br><img src="/2020/06/29/zabbix/33.png" alt><br><br><img src="/2020/06/29/zabbix/34.png" alt><br>至此监控配置完成,下面需要配置邮件服务,当有服务宕机发邮件告警</p>
<h2 id="配置媒介邮件-server端"><a href="#配置媒介邮件-server端" class="headerlink" title="配置媒介邮件(server端)"></a>配置媒介邮件(server端)</h2><p>首先需要在邮件获取授权码<br><br><img src="/2020/06/29/zabbix/40.png" alt><br><br><img src="/2020/06/29/zabbix/41.png" alt><br><br><img src="/2020/06/29/zabbix/42.png" alt><br></p>
<p>本次测试使用mailx服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 关闭当前postfix邮件</span></span><br><span class="line">sudo  systemctl stop postfix</span><br><span class="line">chkconfig  postfix  off</span><br><span class="line"><span class="comment"># 安装mailx</span></span><br><span class="line">sudo yum install mailx  -y</span><br></pre></td></tr></table></figure>
<p>配置邮件服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo  vim /etc/mail.rc</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 发件人地址</span></span><br><span class="line">    <span class="built_in">set</span> from=xxxxxx@qq.com smtp=smtp.qq.com    </span><br><span class="line">    <span class="comment"># 收件人地址                       授权码(邮箱IMAP/SMTP服务的授权码)</span></span><br><span class="line">    <span class="built_in">set</span> smtp-auth-user=xxxxxx@qq.com smtp-auth-password=xxxxxx      </span><br><span class="line">    <span class="built_in">set</span> smtp-auth=login</span><br></pre></td></tr></table></figure>
<p>测试发送邮件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"zabbix test mail"</span> |mail -s <span class="string">"zabbix"</span> xxxxxx@qq.com</span><br></pre></td></tr></table></figure>

<h2 id="配置发送邮件-后台"><a href="#配置发送邮件-后台" class="headerlink" title="配置发送邮件(后台)"></a>配置发送邮件(后台)</h2><p>管理—示警介类型—创建媒体类型<br><br>创建报警媒介类型 (脚本参数分别对应：收件人地址、主题、详细内容)<br><br><img src="/2020/06/29/zabbix/50.png" alt><br><br>配置用户 选择admin用户<br><br><img src="/2020/06/29/zabbix/51.png" alt><br><br>添加报警媒介<br><br><img src="/2020/06/29/zabbix/52.png" alt><br><br>创建报警动作 配置-动作-创建动作,新建动作<br><br><img src="/2020/06/29/zabbix/53.png" alt><br><br>新建操作<br><br><img src="/2020/06/29/zabbix/54.png" alt><br><br><img src="/2020/06/29/zabbix/55.png" alt><br><br>添加恢复操作<br><br><img src="/2020/06/29/zabbix/56.png" alt><br></p>
<p>配置完成后测试(修改触发器或者关闭进程)<br><br><img src="/2020/06/29/zabbix/57.png" alt><br><br><img src="/2020/06/29/zabbix/58.png" alt><br><br><img src="/2020/06/29/zabbix/59.png" alt><br><br><img src="/2020/06/29/zabbix/60.png" alt><br><br><img src="/2020/06/29/zabbix/61.png" alt><br><br><img src="/2020/06/29/zabbix/62.png" alt><br><br>邮件内容以及在动作日志中查看发送记录<br><br><img src="/2020/06/29/zabbix/63.png" alt></p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>liunx</tag>
      </tags>
  </entry>
  <entry>
    <title>python基础之文件操作</title>
    <url>/2020/06/28/python-16/</url>
    <content><![CDATA[<h2 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h2><p>在python3中,打开文件的函数是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">open(file, mode=<span class="string">'r'</span>, buffering=<span class="literal">None</span>, encoding=<span class="literal">None</span>, errors=<span class="literal">None</span>, newline=<span class="literal">None</span>, closefd=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<pre><code>file：文件名
mode：打开模式,默认只读模式
encoding：打开文件的编码方式</code></pre><p>模式介绍：</p>
<pre><code>r：只读模式(默认)
w：只写模式,如果文件不存在就创建,如果存在,写入的数据就会覆盖原来的数据
b：二进制模式
t：文本模式
+：可读可写模式
a：追加模式,如果文件存在则文件指针指向文件末尾(追加数据),如果不存在就创建
r+：读追加模式,先读,在追加
w+：读写模式,先写,意味着原本内容丢失,再读</code></pre><p>文件使用完毕后必须关闭： 文件指针.close() </p>
<h2 id="读操作"><a href="#读操作" class="headerlink" title="读操作"></a>读操作</h2><p>file.txt文件内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">my</span><br><span class="line">sas</span><br><span class="line">aaa</span><br><span class="line"><span class="built_in">test</span></span><br><span class="line">中文</span><br><span class="line">中文</span><br><span class="line">葫芦娃</span><br></pre></td></tr></table></figure>
<p>reads()是读出全部内容</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">"r"</span>.center(<span class="number">50</span>,<span class="string">'-'</span>))</span><br><span class="line">f=open(<span class="string">"file.txt"</span>,encoding=<span class="string">"utf-8"</span>)</span><br><span class="line">print(f.read())</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test.py
------------------------r-------------------------
my
sas
aaa
test
中文
中文
葫芦娃

进程已结束，退出代码 0</code></pre><p>readline()是读出一行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">"r"</span>.center(<span class="number">50</span>,<span class="string">'-'</span>))</span><br><span class="line">f=open(<span class="string">"file.txt"</span>,encoding=<span class="string">"utf-8"</span>)</span><br><span class="line">print(f.readline())</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test.py
------------------------r-------------------------
my


进程已结束，退出代码 0</code></pre><p>readlines()是读出全部内容,并整理成一个列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">"r"</span>.center(<span class="number">50</span>,<span class="string">'-'</span>))</span><br><span class="line">f=open(<span class="string">"file.txt"</span>,encoding=<span class="string">"utf-8"</span>)</span><br><span class="line">print(f.readlines())</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test.py
------------------------r-------------------------
[&apos;my\n&apos;, &apos;sas\n&apos;, &apos;aaa\n&apos;, &apos;test\n&apos;, &apos;中文\n&apos;, &apos;中文\n&apos;, &apos;葫芦娃&apos;]

进程已结束，退出代码 0</code></pre><p>调用read()会一次性读取文件的全部内容，如果文件有20G，内存就爆了，所以，要保险起见，可以反复调用read(size)方法，每次最多读取size个字节的内容。另外，调用readline()可以每次读取一行内容，调用readlines()一次读取所有内容并按行返回list。因此，要根据需要决定怎么调用。</p>
<p>如果文件很小，read()一次性读取最方便；如果不能确定文件大小，反复调用read(size)比较保险；如果是配置文件，调用readlines()最方便：</p>
<h2 id="写操作"><a href="#写操作" class="headerlink" title="写操作"></a>写操作</h2><p>写文件和读文件是一样的，唯一区别是调用open()函数时，传入标识符’w’或者’wb’表示写文本文件或写二进制文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = open(<span class="string">'E:\python\python\test.txt'</span>, <span class="string">'w'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">'Hello, python!'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.close()</span><br></pre></td></tr></table></figure>
<h2 id="with"><a href="#with" class="headerlink" title="with"></a>with</h2><p>为了便捷的关闭文件，python增加了with功能，当with体执行完将自动关闭打开的文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">"file.txt"</span>,<span class="string">"r+"</span>,encoding=<span class="string">"utf-8"</span>) <span class="keyword">as</span> f: <span class="comment">##将自动执行f.close()</span></span><br><span class="line"> f.write(<span class="string">"金刚"</span>)</span><br></pre></td></tr></table></figure>


<p>多个文件的读写</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'C:\Desktop\text.txt'</span>,<span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'C:\Desktop\text1.txt'</span>,<span class="string">'r'</span>) <span class="keyword">as</span> f1:</span><br><span class="line">        <span class="keyword">with</span> open(<span class="string">'C:\Desktop\text2.txt'</span>,<span class="string">'r'</span>) <span class="keyword">as</span> f2　　　　　　</span><br><span class="line">        ........　　　　　　　</span><br><span class="line">        ........　　　　　　　</span><br><span class="line">        ........</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">''</span>C:\Desktop\text.txt<span class="string">','</span><span class="string">r') as f:</span></span><br><span class="line"><span class="string">........</span></span><br><span class="line"><span class="string">with open('</span><span class="string">'C:\Desktop\text1.txt'</span>,<span class="string">'r'</span>) <span class="keyword">as</span> f1:</span><br><span class="line">........</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'C:\Desktop\text2.txt'</span>,<span class="string">'r'</span>) <span class="keyword">as</span> f2:</span><br><span class="line">........</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>liunx</tag>
      </tags>
  </entry>
  <entry>
    <title>python基础之正则表达式</title>
    <url>/2020/06/26/python-15/</url>
    <content><![CDATA[<h2 id="re模块"><a href="#re模块" class="headerlink" title="re模块"></a>re模块</h2><p>常用语法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">re.match(<span class="string">r""</span>,<span class="string">""</span>)</span><br><span class="line"><span class="comment"># 调用模块re的match函数,第一个是正则表达式,第二个是需要处理的字符串</span></span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re </span><br><span class="line">a = re.match(<span class="string">r"hello"</span>,<span class="string">"hello world"</span>)  </span><br><span class="line">print(a.group())  <span class="comment"># 如果打印出来有内容,表示已匹配到</span></span><br></pre></td></tr></table></figure>
<p>re.match的返回值是一个对象,如果只显示匹配到的内容,可以使用对象.group()  如：print(a.group()) </p>
<h2 id="匹配单个字符"><a href="#匹配单个字符" class="headerlink" title="匹配单个字符"></a>匹配单个字符</h2><p>如果匹配正常会打印对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">a = re.match(<span class="string">r"hello"</span>,<span class="string">"hello world"</span>)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\python练习\venv\Scripts\python.exe E:/程序代码/hexo/test.py
&lt;re.Match object; span=(0, 5), match=&apos;hello&apos;&gt;

进程已结束，退出代码 0</code></pre><p>如果匹配失败会打印None</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">b =  re.match(<span class="string">r"test"</span>,<span class="string">"hello world"</span>)</span><br><span class="line">print(b)  <span class="comment"># 打印变量b  会显示none</span></span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\python练习\venv\Scripts\python.exe E:/程序代码/hexo/test.py
None

进程已结束，退出代码 0</code></pre><p>. 匹配任意一个字符(除了\n)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">a = re.match(<span class="string">r"速度与激情."</span>,<span class="string">"速度与激情8"</span>)  </span><br><span class="line">print(a.group())</span><br><span class="line">b = re.match(<span class="string">r"速度与激情."</span>,<span class="string">"速度与激情a"</span>)</span><br><span class="line">print(b.group())</span><br><span class="line">c = re.match(<span class="string">r"速度与激情."</span>,<span class="string">"速度与激情aa"</span>)</span><br><span class="line">print(c.group())   <span class="comment">#只会匹配到速度与激情a  最后一个a 不会被匹配</span></span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\python练习\venv\Scripts\python.exe E:/程序代码/hexo/test.py
速度与激情8
速度与激情a
速度与激情a

进程已结束，退出代码 0</code></pre><p>[] 匹配[]中列举的字符</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">a = re.match(<span class="string">r"速度与激情[1-8]"</span>,<span class="string">"速度与激情8"</span>) </span><br><span class="line">print(a.group())  <span class="comment"># 如果想排除4、5  可以写成[1-36-8] 这个意思是1-3  6-8</span></span><br><span class="line">b = re.match(<span class="string">r"速度与激情[1-8]"</span>,<span class="string">"速度与激情9"</span>)</span><br><span class="line">print(b.group())  <span class="comment"># 因为[]只有1-8 所以这里会报错</span></span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\python练习\venv\Scripts\python.exe E:/程序代码/hexo/test.py
Traceback (most recent call last):
速度与激情8
  File &quot;E:/程序代码/hexo/test.py&quot;, line 5, in &lt;module&gt;
    print(b.group())
AttributeError: &apos;NoneType&apos; object has no attribute &apos;group&apos;

进程已结束，退出代码 1</code></pre><p>\d 匹配数字 0-9</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">a = re.match(<span class="string">r"速度与激情\d"</span>,<span class="string">"速度与激情8"</span>)</span><br><span class="line">print(a.group())</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\python练习\venv\Scripts\python.exe E:/程序代码/hexo/test.py
速度与激情8

进程已结束，退出代码 0</code></pre><p>\D 匹配非数字</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">a = re.match(<span class="string">r"速度与激情\D"</span>,<span class="string">"速度与激情八"</span>)</span><br><span class="line">print(a.group())</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\python练习\venv\Scripts\python.exe E:/程序代码/hexo/test.py
速度与激情八

进程已结束，退出代码 0</code></pre><p>\s 匹配空白 即 空格 tab键</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">a = re.match(<span class="string">r"速度与激情\s\D"</span>,<span class="string">"速度与激情 八"</span>)</span><br><span class="line">print(a.group())</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\python练习\venv\Scripts\python.exe E:/程序代码/hexo/test.py
速度与激情 八

进程已结束，退出代码 0</code></pre><p>\S 匹配非空白</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">a = re.match(<span class="string">r"速度与激情\S"</span>,<span class="string">"速度与激情八"</span>)</span><br><span class="line">print(a.group())</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\python练习\venv\Scripts\python.exe E:/程序代码/hexo/test.py
速度与激情八

进程已结束，退出代码 0</code></pre><p>\w 匹配单个字符 即a-z、A-Z、0-9 包括中文字符</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">a = re.match(<span class="string">r"速度与激情\w\w"</span>,<span class="string">"速度与激情八a"</span>)</span><br><span class="line">print(a.group())</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\python练习\venv\Scripts\python.exe E:/程序代码/hexo/test.py
速度与激情八a

进程已结束，退出代码 0</code></pre><p>\W 匹配非单词字符</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">a = re.match(<span class="string">r"速度与激情\W"</span>,<span class="string">"速度与激情#"</span>)</span><br><span class="line">print(a.group())</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\python练习\venv\Scripts\python.exe E:/程序代码/hexo/test.py
速度与激情#

进程已结束，退出代码 0</code></pre><h2 id="匹配多个字符"><a href="#匹配多个字符" class="headerlink" title="匹配多个字符"></a>匹配多个字符</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">aa = re.match(<span class="string">r"速度与激情\d&#123;1,3&#125;"</span>,<span class="string">"速度与激情1"</span>)</span><br><span class="line">print(aa.group())</span><br><span class="line"></span><br><span class="line">bb = re.match(<span class="string">r"速度与激情\d&#123;1,3&#125;"</span>,<span class="string">"速度与激情12"</span>)</span><br><span class="line">print(bb.group())</span><br><span class="line"></span><br><span class="line">cc = re.match(<span class="string">r"速度与激情\d&#123;1,3&#125;"</span>,<span class="string">"速度与激情125"</span>)</span><br><span class="line">print(cc.group())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以此证明 \d 后面大括号里面是匹配的位数 最少1位  最多3位</span></span><br><span class="line"></span><br><span class="line">dd = re.match(<span class="string">r"\d&#123;11&#125;"</span>,<span class="string">"12345678901"</span>)</span><br><span class="line">print(dd.group())</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\python练习\venv\Scripts\python.exe E:/程序代码/hexo/test.py
速度与激情1
速度与激情12
速度与激情125
12345678901

进程已结束，退出代码 0</code></pre><ul>
<li><p>匹配前一个字符出现0次或者无限次</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">aa = re.match(<span class="string">r"速度与激情\d*"</span>,<span class="string">"速度与激情111111"</span>)</span><br><span class="line">print(aa.group())</span><br><span class="line">bb = re.match(<span class="string">r"速度与激情\d*"</span>,<span class="string">"速度与激情"</span>)</span><br><span class="line">print(bb.group())</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p>D:\python练习\venv\Scripts\python.exe E:/程序代码/hexo/test.py<br>速度与激情111111<br>速度与激情</p>
<p>进程已结束，退出代码 0</p>
</li>
</ul>
<ul>
<li><p>匹配前一个字符出现1次或者无限次(至少出现1次否则报错)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">aa = re.match(<span class="string">r"速度与激情\d+"</span>,<span class="string">"速度与激情111111"</span>)</span><br><span class="line">print(aa.group())</span><br><span class="line">bb = re.match(<span class="string">r"速度与激情\d+"</span>,<span class="string">"速度与激情"</span>)</span><br><span class="line">print(bb.group())</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p>D:\python练习\venv\Scripts\python.exe E:/程序代码/hexo/test.py<br>速度与激情111111<br>Traceback (most recent call last):<br>  File “E:/程序代码/hexo/test.py”, line 5, in <module></module></p>
<pre><code>print(bb.group())</code></pre><p>AttributeError: ‘NoneType’ object has no attribute ‘group’</p>
<p>进程已结束，退出代码 1</p>
</li>
</ul>
<p>？  匹配前一个字符出现1次或者0次</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">ee = re.match(<span class="string">r"010-\d&#123;8&#125;"</span>,<span class="string">"010-12345678"</span>)</span><br><span class="line">print(ee.group())</span><br><span class="line"></span><br><span class="line">ff = re.match(<span class="string">r"010-?\d&#123;8&#125;"</span>,<span class="string">"010-12345678"</span>)  <span class="comment"># 这样-就可以不输入了</span></span><br><span class="line">print(ff.group())</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\python练习\venv\Scripts\python.exe E:/程序代码/hexo/test.py
010-12345678
010-12345678

进程已结束，退出代码 0</code></pre><p>{m} 匹配前一个字符出现m次</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">ee = re.match(<span class="string">r"010-\d&#123;8&#125;"</span>,<span class="string">"010-12345678"</span>)</span><br><span class="line">print(ee.group())</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\python练习\venv\Scripts\python.exe E:/程序代码/hexo/test.py
010-12345678

进程已结束，退出代码 0</code></pre><p>{m，n} 匹配前一个字符出现从m次到n次</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">gg = re.match(<span class="string">r"\d&#123;3,4&#125;-?\d&#123;8&#125;"</span>,<span class="string">"0530-12345678"</span>)</span><br><span class="line">print(gg.group())</span><br><span class="line">dd = re.match(<span class="string">r"\d&#123;3,4&#125;-?\d&#123;8&#125;"</span>,<span class="string">"010-12345678"</span>)</span><br><span class="line">print(dd.group())</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\python练习\venv\Scripts\python.exe E:/程序代码/hexo/test.py
0530-12345678
010-12345678

进程已结束，退出代码 0</code></pre><h2 id="匹配结尾开头"><a href="#匹配结尾开头" class="headerlink" title="匹配结尾开头"></a>匹配结尾开头</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    names = [<span class="string">"age"</span>,<span class="string">"_age"</span>,<span class="string">"1age"</span>,<span class="string">"age1"</span>,<span class="string">"a_age"</span>,<span class="string">"age_1_"</span>,<span class="string">"age!"</span>,<span class="string">"a#123"</span>,<span class="string">"_____"</span>]</span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> names:</span><br><span class="line">        ret = re.match(<span class="string">r"[a-zA-Z][a-zA-Z_]*"</span>,name)</span><br><span class="line">        <span class="keyword">if</span> ret:   <span class="comment"># 判断是否有值   有值就打印出来</span></span><br><span class="line">                print(<span class="string">"变量名：%s 符合要求....通过正则匹配出来的数据是%s"</span> % (name,ret.group()))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">                print(<span class="string">"变量名：%s 不符合要求"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\python练习\venv\Scripts\python.exe E:/程序代码/hexo/test.py
变量名：age 符合要求....通过正则匹配出来的数据是age
变量名：%s 不符合要求
变量名：%s 不符合要求
变量名：age1 符合要求....通过正则匹配出来的数据是age
变量名：a_age 符合要求....通过正则匹配出来的数据是a_age
变量名：age_1_ 符合要求....通过正则匹配出来的数据是age_
变量名：age! 符合要求....通过正则匹配出来的数据是age
变量名：a#123 符合要求....通过正则匹配出来的数据是a
变量名：%s 不符合要求

进程已结束，退出代码 0</code></pre><p>匹配结尾</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    names = [<span class="string">"age"</span>,<span class="string">"_age"</span>,<span class="string">"1age"</span>,<span class="string">"age1"</span>,<span class="string">"a_age"</span>,<span class="string">"age_1_"</span>,<span class="string">"age!"</span>,<span class="string">"a#123"</span>,<span class="string">"_____"</span>]</span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> names:</span><br><span class="line">        ret = re.match(<span class="string">r"[a-zA-Z][a-zA-Z0-9_]*$"</span>,name)  <span class="comment"># 匹配a-zA-Z开头一直到a-zA-Z0-9_结尾</span></span><br><span class="line">        <span class="keyword">if</span> ret:</span><br><span class="line">                print(<span class="string">"变量名：%s 符合要求....通过正则匹配出来的数据是%s"</span> % (name,ret.group()))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">                print(<span class="string">"变量名：%s 不符合要求"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\python练习\venv\Scripts\python.exe E:/程序代码/hexo/test.py
变量名：age 符合要求....通过正则匹配出来的数据是age
变量名：%s 不符合要求
变量名：%s 不符合要求
变量名：age1 符合要求....通过正则匹配出来的数据是age1
变量名：a_age 符合要求....通过正则匹配出来的数据是a_age
变量名：age_1_ 符合要求....通过正则匹配出来的数据是age_1_
变量名：%s 不符合要求
变量名：%s 不符合要求
变量名：%s 不符合要求

进程已结束，退出代码 0</code></pre><p>转义匹配</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    email = input(<span class="string">"请输入一个邮箱地址: "</span>)</span><br><span class="line"></span><br><span class="line">    ret = re.match(<span class="string">r"[a-zA-Z0-9_]&#123;4,20&#125;@163\.com$"</span>,email)</span><br><span class="line">    <span class="keyword">if</span> ret:</span><br><span class="line">        print(<span class="string">"%s 符合要求"</span> % email)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"%s 不符合要求"</span>  % email)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\python练习\venv\Scripts\python.exe E:/程序代码/hexo/test.py
请输入一个邮箱地址: laowang@163acom
laowang@163acom 不符合要求

进程已结束，退出代码 0

D:\python练习\venv\Scripts\python.exe E:/程序代码/hexo/test.py
请输入一个邮箱地址: laowang@163.com
laowang@163.com 符合要求

进程已结束，退出代码 0</code></pre><p>| 匹配左右任意一个表达式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>  re</span><br><span class="line"><span class="comment"># 判断多个类型邮箱</span></span><br><span class="line">a = re.match(<span class="string">r"[a-zA-Z0-9_]&#123;4,20&#125;@(163|126)\.com$"</span>,<span class="string">"laowang@126.com"</span>)</span><br><span class="line">print(a.group())</span><br><span class="line">b = re.match(<span class="string">r"[a-zA-Z0-9_]&#123;4,20&#125;@(163|126)\.com$"</span>,<span class="string">"laowang@163.com"</span>)</span><br><span class="line">print(b.group())</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\python练习\venv\Scripts\python.exe E:/程序代码/hexo/test.py
laowang@126.com
laowang@163.com

进程已结束，退出代码 0</code></pre><p>(ab) 分组-将括号中字符作为一个分组 可以使用group(1)或者group(2)取出</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>  re</span><br><span class="line"><span class="comment"># 判断多个类型邮箱  使用分组()保存数据</span></span><br><span class="line">a = re.match(<span class="string">r"[a-zA-Z0-9_]&#123;4,20&#125;@(163|126)\.com$"</span>,<span class="string">"laowang@126.com"</span>)</span><br><span class="line">print(a.group(<span class="number">1</span>))</span><br><span class="line">b = re.match(<span class="string">r"([a-zA-Z0-9_]&#123;4,20&#125;)@(163|126)\.com$"</span>,<span class="string">"laowang@163.com"</span>)</span><br><span class="line">print(b.group(<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<p>运行结果:</p>
<pre><code>D:\python练习\venv\Scripts\python.exe E:/程序代码/hexo/test.py
126
laowang

进程已结束，退出代码 0</code></pre><p>\num 引用分组num匹配到的字符</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>  re</span><br><span class="line"><span class="comment"># \num 引用分组num匹配到的字符</span></span><br><span class="line">html_str = <span class="string">"&lt;h1&gt;hello test&lt;/h1&gt;"</span></span><br><span class="line"><span class="comment"># 可以使用 \num  判断&lt;h1&gt; 是否是一对</span></span><br><span class="line">a = re.match(<span class="string">r"&lt;(\w*)&gt;.*&lt;/\1&gt;"</span>,html_str)</span><br><span class="line">print(a.group())</span><br><span class="line"></span><br><span class="line">html_str1 = <span class="string">"&lt;body&gt;&lt;h1&gt;hello test&lt;/h1&gt;&lt;/body&gt;"</span></span><br><span class="line"><span class="comment"># body 是第一个分组   h1 是第二个 所以 写为&lt;/\2&gt;&lt;/\1&gt;</span></span><br><span class="line">b = re.match(<span class="string">r"&lt;(\w*)&gt;&lt;(\w*)&gt;.*&lt;/\2&gt;&lt;/\1&gt;"</span>,html_str1)</span><br><span class="line">print(b.group())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 扩展 为分组命名</span></span><br><span class="line"><span class="comment"># (?P&lt;name&gt;)  分组起名</span></span><br><span class="line"><span class="comment">#（?P=name）引用别名为name分组匹配到的字符串</span></span><br><span class="line">html_str3 = <span class="string">"&lt;body&gt;&lt;h1&gt;hello test&lt;/h1&gt;&lt;/body&gt;"</span></span><br><span class="line">c = re.match(<span class="string">r"&lt;(?P&lt;NAME1&gt;\w*)&gt;&lt;(?P&lt;NAME2&gt;\w*)&gt;.*&lt;/(?P=NAME2)&gt;&lt;/(?P=NAME1)&gt;"</span>,html_str1)</span><br><span class="line">print(c.group())</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\python练习\venv\Scripts\python.exe E:/程序代码/hexo/test.py
&lt;h1&gt;hello test&lt;/h1&gt;
&lt;body&gt;&lt;h1&gt;hello test&lt;/h1&gt;&lt;/body&gt;
&lt;body&gt;&lt;h1&gt;hello test&lt;/h1&gt;&lt;/body&gt;

进程已结束，退出代码 0</code></pre><h2 id="re模块高级用法"><a href="#re模块高级用法" class="headerlink" title="re模块高级用法"></a>re模块高级用法</h2><p>re.match(pattern, string, flags=0) 从字符串的起始位置匹配，如果起始位置匹配不成功的话，match()就返回none</p>
<p>re.search(pattern, string, flags=0) 扫描整个字符串并返回第一个成功的匹配</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">ret = re.search(<span class="string">r"\d+"</span>,<span class="string">"阅读次数为 9999"</span>)  <span class="comment"># 返回第一个成功的匹配</span></span><br><span class="line">print(ret.group())</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\python练习\venv\Scripts\python.exe E:/程序代码/hexo/test2.py
9999

进程已结束，退出代码 0</code></pre><p>re.findall(pattern, string, flags=0) 找到RE匹配的所有字符串，并把他们作为一个列表返回</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">ret = re.findall(<span class="string">r"\d+"</span>,<span class="string">"python = 9999, c = 7890, c++ = 12345"</span>)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\python练习\venv\Scripts\python.exe E:/程序代码/hexo/test2.py
[&apos;9999&apos;, &apos;7890&apos;, &apos;12345&apos;]

进程已结束，退出代码 0</code></pre><p>re.finditer(pattern, string, flags=0) 找到RE匹配的所有字符串，并把他们作为一个迭代器返回</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">re.sub(pattern, repl, string, count=<span class="number">0</span>, flags=<span class="number">0</span>) 替换匹配到的字符串</span><br><span class="line">```python</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>liunx</tag>
      </tags>
  </entry>
  <entry>
    <title>shell命令行工具</title>
    <url>/2020/06/22/shell-commond/</url>
    <content><![CDATA[<h2 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在第一个匹配行到第二个匹配行后各加 <span class="built_in">test</span>     然后删除匹配到的第一个<span class="built_in">test</span></span></span><br><span class="line">cat  aa  | sed   "/path/,/--&gt;/a test"  |sed '0,/test/&#123;/test/d&#125;'</span><br></pre></td></tr></table></figure>

<p>docker build 失败(如果可以导入镜像但是除去FROM第一个指令就报错 那就是linux与docker版本的兼容性问题)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum remove docker  docker-common docker-selinux dockesr-engine</span><br><span class="line">sudo yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line">sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line">sudo yum install docker-ce</span><br><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure>

<h2 id="ssh登录失败"><a href="#ssh登录失败" class="headerlink" title="ssh登录失败"></a>ssh登录失败</h2><p>购买云服务器vpc网络的时候,第一次购买后配置使用,使用后退租,再次购买可能会购买到相同的内网ip服务器,然后ssh 连接的时候就会报错,如下：<br><br><img src="/2020/06/22/shell-commond/1.png" alt><br><br>报错问题:这个ip已存在 .ssh/known_hosts 文件中,但是上次连接的秘钥,和这次不同,所以无法登陆<br><br>解决办法：<br><br>编辑 .ssh/known_hosts 文件 找到 有问题的ip,删除哪一行登陆信息就ok了</p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>liunx</tag>
      </tags>
  </entry>
  <entry>
    <title>python基础之抛出异常</title>
    <url>/2020/06/20/python-14/</url>
    <content><![CDATA[<h2 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h2><p>在程序开发中,如果对默认代码不能确定是否正确,可以增加try(尝试)来捕获异常,语法格式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 不能确定正确执行的代码</span></span><br><span class="line">    num = int(input(<span class="string">"请输入一个整数："</span>))</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="comment"># 错误的处理代码</span></span><br><span class="line">    print(<span class="string">"请输入一个整数"</span>)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test.py
请输入一个整数：66

进程已结束，退出代码 0</code></pre><p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test.py
请输入一个整数：aa
请输入一个整数

进程已结束，退出代码 0</code></pre><h2 id="错误类偶像捕获异常"><a href="#错误类偶像捕获异常" class="headerlink" title="错误类偶像捕获异常"></a>错误类偶像捕获异常</h2><p>在程序执行时,可能遇到不同类型的异常,并且需要针对不同的类型的异常,做出不同的响应<br><br>当python解释器抛出异常时,最后一行错误信息的第一个单词就是错误类型,如：ValueError，ZeroDivisionError<br><br>例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    num = int(input(<span class="string">"请输入一个整数："</span>))</span><br><span class="line">    <span class="comment"># 使用 8 除以用户输入的整数并且输出</span></span><br><span class="line">    result = <span class="number">8</span> / num</span><br><span class="line">    print(result)</span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">    print(<span class="string">"除 0 错误"</span>)</span><br><span class="line"><span class="keyword">except</span> ValueError:</span><br><span class="line">    print(<span class="string">"请输入正确的整数"</span>)</span><br></pre></td></tr></table></figure>
<p>运行结果(输入 0 )：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test.py
请输入一个整数：0
除 0 错误

进程已结束，退出代码 0</code></pre><p>运行结果(输入非整数)：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test.py
请输入一个整数：aa
请输入正确的整数

进程已结束，退出代码 0</code></pre><p>运行结果(正常)：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test.py
请输入一个整数：10
0.8

进程已结束，退出代码 </code></pre><p>可以填写不同类型的异常   例如ValueError，ZeroDivisionError   以此类推</p>
<h2 id="捕获未知错误"><a href="#捕获未知错误" class="headerlink" title="捕获未知错误"></a>捕获未知错误</h2><p>在开发时,要预判到所有可能出现的错误,还是有一定难度的,如果需要无论出现任何错误,都不会因为python解释器抛出异常而被终止,可以在增加一个except,语法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">except</span>  Exception  <span class="keyword">as</span>   变量名：</span><br><span class="line">    print(<span class="string">"未知错误 %s"</span> % 变量名)</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment">#不能确定正确执行的代码</span></span><br><span class="line">    num = int(input(<span class="string">"请输入一个整数 ："</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#使用 8 除以用户输入的整数并且输出</span></span><br><span class="line">    result = <span class="number">8</span> / num</span><br><span class="line">    print(result)</span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">    print(<span class="string">"除 0 错误"</span>)</span><br><span class="line">    <span class="comment">#以上代码之后错误类型是0时  会抛出错误  其他的都是导致异常退出</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> result:</span><br><span class="line">    print(<span class="string">"未知错误 %s"</span> % result)</span><br><span class="line">    <span class="comment">#这样其他的错误也可以被捕获到</span></span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test.py
请输入一个整数 ：aa
未知错误 invalid literal for int() with base 10: &apos;aa&apos;

进程已结束，退出代码 0</code></pre><h2 id="异常捕获完整语法"><a href="#异常捕获完整语法" class="headerlink" title="异常捕获完整语法"></a>异常捕获完整语法</h2><p>语法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">except</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">except</span> <span class="number">2</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> result:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment">#没有异常才会执行的代码</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="comment">#无论是否有异常，都会执行的代码</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>else：只有在没有异常的情况下才会执行的代码<br><br>finally：无论是否有异常都会被执行的代码<br><br>例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment">#不能确定正确执行的代码</span></span><br><span class="line">    num = int(input(<span class="string">"请输入一个整数 ："</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#使用 8 除以用户输入的整数并且输出</span></span><br><span class="line">    result = <span class="number">8</span> / num</span><br><span class="line">    print(result)</span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">    print(<span class="string">"除 0 错误"</span>)</span><br><span class="line"><span class="keyword">except</span> ValueError:</span><br><span class="line">    print(<span class="string">"请输入正确的整数"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"没有错误执行"</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    print(<span class="string">"全部执行"</span>)</span><br></pre></td></tr></table></figure>
<p>运行结果(除 0 错误)：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test.py
请输入一个整数 ：0
除 0 错误
全部执行

进程已结束，退出代码 0</code></pre><p>运行结果(没有错误):</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test.py
请输入一个整数 ：8
1.0
没有错误执行
全部执行

进程已结束，退出代码 0</code></pre><h2 id="异常的传递"><a href="#异常的传递" class="headerlink" title="异常的传递"></a>异常的传递</h2><p>异常的传递–当函数/方法执行出现异常,会将异常传递给函数/方法的调用一方,如果传递到主程序,仍然没有异常处理,程序才会被终止<br><br>提示：<br><br>在开发中,可以在主程序中增加异常捕获,而在主函数中调用其他的函数,只要出现异常,都会传递到主函数的异常捕获中,这样就不需要在代码中增加大量的异常捕获,能够保证代码的整洁</p>
<p>需求：</p>
<pre><code>1、定义函数demo1()提示用户输入一个整数并且返还
2、定义函数demo2()调用demo1()
3、在主程序中调用demo2()</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#定义函数demo1 返回用户输入的整数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span>  int(input(<span class="string">"请输入一个整数："</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义函数demo2  调用函数demo1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span>  demo1()</span><br><span class="line"></span><br><span class="line"><span class="comment">#利用异常的传递性，在主程序中捕获异常</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    print(demo1())</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span>  result:</span><br><span class="line">    print(<span class="string">"未知错误 %s"</span> % result)</span><br></pre></td></tr></table></figure>
<p>运行结果(正常)：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test.py
请输入一个整数：1
1

进程已结束，退出代码 0</code></pre><p>运行结果(异常)：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test.py
请输入一个整数：a
未知错误 invalid literal for int() with base 10: &apos;a&apos;

进程已结束，退出代码 0</code></pre><h2 id="主动抛出异常并且捕获"><a href="#主动抛出异常并且捕获" class="headerlink" title="主动抛出异常并且捕获"></a>主动抛出异常并且捕获</h2><p>抛出raise异常：在开发中,除了代码执行错误python解释器会抛出异常之外,还可以根据应用程序特有的业务需求主动抛出异常</p>
<pre><code>如果函数中没有定义任何返回  如果使用print输出 就会输出一个None  （*args  是一个多值的元组参数）</code></pre><p>主动抛出异常并且捕获,python中提供了一个Exception异常类,在开发时,如果满足特定业务需求时,希望抛出异常可以：</p>
<pre><code>1、创建一个Exception的对象
2、使用raise 关键字抛出异常对象</code></pre><p>需求：</p>
<pre><code>1、定义input_password函数，提示用户输入密码
2、如果用户输入长度&lt;8 抛出异常
3、如果用户输入长度&gt;=8 返回输入的密码</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="comment"># 1、定义input_password函数，提示用户输入密码</span></span><br><span class="line">    pwd = input(<span class="string">"请输入密码："</span>)</span><br><span class="line">    <span class="comment"># 2、如果用户输入长度 &lt; 8  抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> len(pwd) &gt;= <span class="number">8</span>:</span><br><span class="line">        <span class="keyword">return</span> pwd</span><br><span class="line">    print(<span class="string">"主动抛出异常"</span>)</span><br><span class="line">    ex = Exception(<span class="string">"密码长度不够"</span>)</span><br><span class="line">    <span class="keyword">raise</span> ex</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    print(input_password()) <span class="comment"># 执行函数并打印</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span>  result:  <span class="comment"># 捕获所有异常 并 传递到result 变量</span></span><br><span class="line">    print(result)</span><br><span class="line"><span class="keyword">finally</span>:   <span class="comment"># 所有情况下都会执行的代码</span></span><br><span class="line">    print(<span class="string">"代码结束"</span>)</span><br></pre></td></tr></table></figure>
<p>运行结果(正常)：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test.py
请输入密码：12345678
12345678
代码结束

进程已结束，退出代码 0</code></pre><p>运行结果(异常)：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test.py
请输入密码：123456
主动抛出异常
密码长度不够
代码结束

进程已结束，退出代码 0</code></pre>]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>liunx</tag>
      </tags>
  </entry>
  <entry>
    <title>python基础之常用模块</title>
    <url>/2020/06/18/python-13/</url>
    <content><![CDATA[<h2 id="列出指定目录下的所有文件"><a href="#列出指定目录下的所有文件" class="headerlink" title="列出指定目录下的所有文件"></a>列出指定目录下的所有文件</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>  os</span><br><span class="line">print(os.listdir(<span class="string">"../hexo"</span>))  <span class="comment"># 列出指定目录下的所有文件并打印</span></span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test2.py
[&apos;test.py&apos;, &apos;test2.py&apos;]

进程已结束，退出代码 0</code></pre><h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>  os</span><br><span class="line">print(os.listdir(<span class="string">"../hexo"</span>)) </span><br><span class="line">os.remove(<span class="string">"pwd.py"</span>)  <span class="comment"># 删除pwd.py文件</span></span><br><span class="line">print(os.listdir(<span class="string">"../hexo"</span>))</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test2.py
[&apos;pwd.py&apos;, &apos;test.py&apos;, &apos;test2.py&apos;]
[&apos;test.py&apos;, &apos;test2.py&apos;]

进程已结束，退出代码 0</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.unlink(<span class="string">"pwd.py"</span>)  <span class="comment"># 删除pwd.py文件   与remove相同</span></span><br></pre></td></tr></table></figure>
<h2 id="重命名文件"><a href="#重命名文件" class="headerlink" title="重命名文件"></a>重命名文件</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>  os</span><br><span class="line">print(os.listdir(<span class="string">"../hexo"</span>))</span><br><span class="line">os.rename(<span class="string">"test.py"</span>,<span class="string">"numcount.py"</span>)  <span class="comment"># (原来名字,新名字)</span></span><br><span class="line">print(os.listdir(<span class="string">"../hexo"</span>))</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test2.py
[&apos;test.py&apos;, &apos;test2.py&apos;]
[&apos;numcount.py&apos;, &apos;test2.py&apos;]

进程已结束，退出代码 0</code></pre><h2 id="改变当前工作目录"><a href="#改变当前工作目录" class="headerlink" title="改变当前工作目录"></a>改变当前工作目录</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>  os</span><br><span class="line">print(os.listdir(<span class="string">"../hexo"</span>))</span><br><span class="line">os.chdir(<span class="string">"../python"</span>)  <span class="comment"># 切换工作目录至python下</span></span><br><span class="line">print(os.listdir())</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test2.py
[&apos;numcount.py&apos;, &apos;test2.py&apos;]
[&apos;video.html&apos;,  &apos;自动偷取.js&apos;]

进程已结束，退出代码 0</code></pre><h2 id="获取当前文件路径"><a href="#获取当前文件路径" class="headerlink" title="获取当前文件路径"></a>获取当前文件路径</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>  os</span><br><span class="line">print(os.getcwd())</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test2.py
E:\资料\python\hexo

进程已结束，退出代码 0</code></pre><h2 id="新建目录"><a href="#新建目录" class="headerlink" title="新建目录"></a>新建目录</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>  os</span><br><span class="line">os.mkdir(<span class="string">"../hexo/mkdir"</span>)  <span class="comment"># 在hexo目录下创建名为mkdir的目录</span></span><br><span class="line">print(os.listdir())</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test2.py
[&apos;mkdir&apos;, &apos;numcount.py&apos;, &apos;test2.py&apos;]

进程已结束，退出代码 0</code></pre><h2 id="删除空目录-删除非空目录-使用shutil-rmtree"><a href="#删除空目录-删除非空目录-使用shutil-rmtree" class="headerlink" title="删除空目录(删除非空目录,使用shutil.rmtree())"></a>删除空目录(删除非空目录,使用shutil.rmtree())</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>  os</span><br><span class="line">os.rmdir(<span class="string">"../hexo/mkdir"</span>)   <span class="comment"># 删除名为mkdir的空目录</span></span><br><span class="line">print(os.listdir())</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test2.py
[&apos;numcount.py&apos;, &apos;test2.py&apos;]

进程已结束，退出代码 0</code></pre><h2 id="创建多级目录"><a href="#创建多级目录" class="headerlink" title="创建多级目录"></a>创建多级目录</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>  os</span><br><span class="line">os.makedirs(<span class="string">"../hexo/mkdir/screen"</span>)  <span class="comment"># 创建目录mkdir 并在mkdir下创建screen</span></span><br><span class="line">print(os.listdir(<span class="string">"mkdir"</span>))</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test2.py
[&apos;screen&apos;]

进程已结束，退出代码 0</code></pre><h2 id="删除多级目录"><a href="#删除多级目录" class="headerlink" title="删除多级目录"></a>删除多级目录</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>  os</span><br><span class="line">os.removedirs(<span class="string">"../hexo/mkdir/screen"</span>)  <span class="comment"># 删除递归目录</span></span><br><span class="line">print(os.listdir())</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test2.py
[&apos;numcount.py&apos;, &apos;test2.py&apos;]

进程已结束，退出代码 0</code></pre><h2 id="获取文件属性"><a href="#获取文件属性" class="headerlink" title="获取文件属性"></a>获取文件属性</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>  os</span><br><span class="line">print(os.stat(<span class="string">"numcount.py"</span>))   <span class="comment"># 获取文件属性并打印</span></span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test2.py
os.stat_result(st_mode=33206, st_ino=17732923533531673, st_dev=1744964457, st_nlink=1, st_uid=0, st_gid=0, st_size=171, st_atime=1592297075, st_mtime=1592297075, st_ctime=1591942241)

进程已结束，退出代码 0</code></pre><h2 id="修改文件权限"><a href="#修改文件权限" class="headerlink" title="修改文件权限"></a>修改文件权限</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>  os</span><br><span class="line"><span class="keyword">import</span> stat   <span class="comment"># 权限模块</span></span><br><span class="line">print(os.stat(<span class="string">"numcount.py"</span>).st_mode)</span><br><span class="line">print(oct(os.stat(<span class="string">"numcount.py"</span>).st_mode)[<span class="number">-3</span>:])</span><br><span class="line">os.chmod(<span class="string">"numcount.py"</span>,stat.S_IWRITE)   </span><br><span class="line">print(oct(os.stat(<span class="string">"numcount.py"</span>).st_mode)[<span class="number">-3</span>:])</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test2.py
33060
444
666

进程已结束，退出代码 0</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 常用权限</span></span><br><span class="line">stat.S_ISVTX: Save text image after execution. 在执行之后保存文字和图片</span><br><span class="line">stat.S_IREAD: Read by owner. 对于拥有者读的权限</span><br><span class="line">stat.S_IWRITE: Write by owner. 对于拥有者写的权限</span><br><span class="line">stat.S_IEXEC: Execute by owner. 对于拥有者执行的权限</span><br><span class="line">stat.S_IRWXU: Read, write, <span class="keyword">and</span> execute by owner. 对于拥有者读写执行的权限</span><br><span class="line">stat.S_IRUSR: Read by owner. 对于拥有者读的权限</span><br><span class="line">stat.S_IWUSR: Write by owner. 对于拥有者写的权限</span><br><span class="line">stat.S_IXUSR: Execute by owner. 对于拥有者执行的权限</span><br><span class="line">stat.S_IRWXG: Read, write, <span class="keyword">and</span> execute by group. 对于同组的人读写执行的权限</span><br><span class="line">stat.S_IRGRP: Read by group. 对于同组读的权限</span><br><span class="line">stat.S_IWGRP: Write by group. 对于同组写的权限</span><br><span class="line">stat.S_IXGRP: Execute by group. 对于同组执行的权限</span><br><span class="line">stat.S_IRWXO: Read, write, <span class="keyword">and</span> execute by others. 对于其他组读写执行的权限</span><br><span class="line">stat.S_IROTH: Read by others. 对于其他组读的权限</span><br><span class="line">stat.S_IWOTH: Write by others. 对于其他组写的权限</span><br><span class="line">stat.S_IXOTH: Execute by others. 对于其他组执行的权限</span><br></pre></td></tr></table></figure>
<h2 id="修改文件时间戳"><a href="#修改文件时间戳" class="headerlink" title="修改文件时间戳"></a>修改文件时间戳</h2><p>参数</p>
<pre><code>path -- 文件路径

times -- 如果时间是 None, 则文件的访问和修改设为当前时间 。 否则, 时间是一个 2-tuple数字, (atime, mtime) 用来分别作为访问和修改的时间。</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>  os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">print(os.stat(<span class="string">"numcount.py"</span>).st_mtime)  <span class="comment">#  打印修改前时间戳</span></span><br><span class="line">os.utime(<span class="string">"numcount.py"</span>,<span class="literal">None</span>)   <span class="comment"># 将时间戳修改为当前时间</span></span><br><span class="line">print(os.stat(<span class="string">"numcount.py"</span>).st_mtime)</span><br><span class="line">print(time.time())    <span class="comment"># 查看当前时间戳</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>  os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">print(os.stat(<span class="string">"numcount.py"</span>).st_mtime) <span class="comment">#  打印修改前时间戳</span></span><br><span class="line">os.utime(<span class="string">"numcount.py"</span>,(<span class="number">1592534641</span>,<span class="number">1592534641</span>))  <span class="comment"># 将时间戳修改为指定时间</span></span><br><span class="line">print(os.stat(<span class="string">"numcount.py"</span>).st_mtime)</span><br><span class="line">print(time.time())</span><br></pre></td></tr></table></figure>
<h2 id="执行操作系统命令"><a href="#执行操作系统命令" class="headerlink" title="执行操作系统命令"></a>执行操作系统命令</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> os       <span class="comment"># 导入模块</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.system(<span class="string">"ls"</span>)    <span class="comment"># 执行ls操作</span></span><br><span class="line">db              nohup.out                 update.js  find_date.sh    qq.sh                </span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.system(<span class="string">"pwd"</span>)   <span class="comment"># 执行pwd操作</span></span><br><span class="line">/home/sgsm</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>
<h2 id="os-path模块"><a href="#os-path模块" class="headerlink" title="os.path模块"></a>os.path模块</h2><p>os.path.split(filename) 将文件路径和文件名分割(会将最后一个目录作为文件名而分离)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>  os</span><br><span class="line">print(os.path.split(<span class="string">"numcount.py"</span>))</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test2.py
(&apos;&apos;, &apos;numcount.py&apos;)

进程已结束，退出代码 0</code></pre><p>os.path.splitext(filename) 将文件路径和文件扩展名分割成一个元组</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>  os</span><br><span class="line">print(os.path.splitext(<span class="string">"numcount.py"</span>))</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test2.py
(&apos;numcount&apos;, &apos;.py&apos;)

进程已结束，退出代码 0</code></pre><p>os.path.dirname(filename) 返回文件路径的目录部分</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>  os</span><br><span class="line">print(os.path.abspath(__file__))  <span class="comment"># 查看文件的绝对路径 </span></span><br><span class="line">print(os.path.dirname(<span class="string">"E:\资料\python\hexo\\test2.py"</span>))   <span class="comment"># 因为\t是特殊符号所以需要转义</span></span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test2.py
E:\资料\python\hexo\test2.py
E:\资料\python\hexo

进程已结束，退出代码 0</code></pre><p>os.path.basename(filename) 返回文件路径的文件名部分</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>  os</span><br><span class="line">print(os.path.abspath(__file__))</span><br><span class="line">print(os.path.basename(<span class="string">"E:\资料\python\hexo\\test2.py"</span>))</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test2.py
E:\资料\python\hexo\test2.py
test2.py

进程已结束，退出代码 0</code></pre><p>os.path.join(dirname,basename) 将文件路径和文件名凑成完整文件路径</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>  os</span><br><span class="line">print(os.path.abspath(__file__))</span><br><span class="line">print(os.path.join(<span class="string">"E:\资料\python\hexo\\test2.py"</span>))</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test2.py
E:\资料\python\hexo\test2.py
E:\资料\python\hexo\test2.py

进程已结束，退出代码 0</code></pre><p>os.path.abspath(name) 获得绝对路径   (<strong>file</strong>) 代表当前文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>  os</span><br><span class="line">print(os.path.abspath(__file__))</span><br><span class="line">print(os.path.abspath(<span class="string">"E:\资料\python\hexo\\numcount.py"</span>))</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test2.py
E:\资料\python\hexo\test2.py
E:\资料\python\hexo\numcount.py

进程已结束，退出代码 0</code></pre><p>os.path.splitunc(path) 把路径分割为挂载点和文件名</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>  os</span><br><span class="line">print(os.path.abspath(__file__))</span><br><span class="line">print(os.path.splitunc(<span class="string">"E:\资料\python\hexo\\numcount.py"</span>))</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test2.py
E:\资料\python\hexo\test2.py
(&apos;&apos;, &apos;E:\\资料\\python\\hexo\\numcount.py&apos;)

进程已结束，退出代码 0</code></pre><p>os.path.normpath(path) 规范path字符串形式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>  os</span><br><span class="line">print(os.path.abspath(__file__))</span><br><span class="line">print(os.path.normpath(<span class="string">"E:\资料\python\hexo\\numcount.py"</span>))</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test2.py
E:\资料\python\hexo\test2.py
E:\资料\python\hexo\numcount.py

进程已结束，退出代码 0</code></pre><p>os.path.exists() 判断文件或目录是否存在</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>  os</span><br><span class="line">print(os.path.exists(<span class="string">"E:\资料\python\hexo\\numcount.py"</span>))</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test2.py
True

进程已结束，退出代码 0</code></pre><p>os.path.isabs() 如果path是绝对路径，返回True</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>  os </span><br><span class="line">print(os.path.isabs(<span class="string">"../numcount.py"</span>))     <span class="comment"># 相对路径</span></span><br><span class="line">print(os.path.isabs(<span class="string">"E:\资料\python\hexo\\numcount.py"</span>))  <span class="comment"># 绝对路径</span></span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test2.py
False
True

进程已结束，退出代码 0</code></pre><p>os.path.realpath(path) #返回path的真实路径  (realpath 返回的是 使用软链 的真实地址   abspath 返回目标地址)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>  os</span><br><span class="line">print(os.path.abspath(<span class="string">"numcount.py"</span>))</span><br><span class="line">print(os.path.realpath(<span class="string">"numcount.py"</span>))</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test2.py
E:\资料\python\hexo\numcount.py
E:\资料\python\hexo\numcount.py

进程已结束，退出代码 0</code></pre><p>os.path.relpath(path[, start]) #从start开始计算相对路径 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>  os</span><br><span class="line">print(os.path.relpath(<span class="string">"E:\资料\python\hexo\\numcount.py"</span>, <span class="string">"E:\资料"</span>))  <span class="comment"># 从"E:\资料"开始计算</span></span><br><span class="line">print(os.path.relpath(<span class="string">"E:\资料\python\hexo\\numcount.py"</span>, <span class="string">""</span>))  <span class="comment"># 如果不指定 默认从当前位置计算</span></span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test2.py
python\hexo\numcount.py
numcount.py

进程已结束，退出代码 0</code></pre><p>os.path.normcase(path) #转换path的大小写和斜杠</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>  os</span><br><span class="line">print(os.path.normcase(<span class="string">"E:\资料\python\hexo\\numcount.py"</span>))</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test2.py
e:\资料\python\hexo\numcount.py

进程已结束，退出代码 0</code></pre><p>os.path.isdir() 判断name是不是一个目录，name不是目录就返回false</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>  os</span><br><span class="line">print(os.path.isdir(<span class="string">"E:\资料\python\hexo\\numcount.py"</span>))</span><br><span class="line">print(os.path.isdir(<span class="string">"E:\资料\python\hexo"</span>))</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test2.py
False
True

进程已结束，退出代码 0</code></pre><p>os.path.isfile() 判断name是不是一个文件，不存在返回false</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>  os</span><br><span class="line">print(os.path.isfile(<span class="string">"E:\资料\python\hexo\\numcount.py"</span>))</span><br><span class="line">print(os.path.isfile(<span class="string">"E:\资料\python\hexo"</span>))</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test2.py
True
False

进程已结束，退出代码 0</code></pre><p>os.path.islink() 判断文件是否连接文件,返回boolean</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>  os</span><br><span class="line">print(os.path.islink(<span class="string">"E:\资料\python\hexo\\numcount.py"</span>))</span><br><span class="line">print(os.path.islink(<span class="string">"E:\资料\python\hexo"</span>))</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test2.py
False
False

进程已结束，退出代码 0</code></pre><p>os.path.ismount() 指定路径是否存在且为一个挂载点，返回boolean</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>  os</span><br><span class="line">print(os.path.ismount(<span class="string">"E:\资料\python\hexo\\numcount.py"</span>))</span><br><span class="line">print(os.path.ismount(<span class="string">"E:\资料\python\hexo"</span>))</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test2.py
False
False

进程已结束，退出代码 0</code></pre><p>os.path.samefile() 是否相同路径的文件，返回boolean</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>  os</span><br><span class="line">print(os.path.samefile(<span class="string">"E:\资料\python\hexo\\numcount.py"</span>,<span class="string">"E:\资料\python\hexo"</span>))</span><br><span class="line">print(os.path.samefile(<span class="string">"E:\资料\python\hexo\\numcount.py"</span>,<span class="string">"E:\资料\python\hexo\\numcount.py"</span>))</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test2.py
False
True

进程已结束，退出代码 0</code></pre><p>os.path.getatime() 返回最近访问时间 浮点型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>  os</span><br><span class="line">print(os.path.getatime(<span class="string">"E:\资料\python\hexo\\numcount.py"</span>))</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test2.py
1592534641.0

进程已结束，退出代码 0</code></pre><p>os.path.getmtime() 返回上一次修改时间 浮点型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>  os</span><br><span class="line">print(os.path.getmtime(<span class="string">"E:\资料\python\hexo\\numcount.py"</span>))</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test2.py
1592534641.0

进程已结束，退出代码 0</code></pre><p>os.path.getctime() 返回文件创建时间 浮点型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>  os</span><br><span class="line">print(os.path.getctime(<span class="string">"E:\资料\python\hexo\\numcount.py"</span>))</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test2.py
1591942241.7330246

进程已结束，退出代码 0</code></pre><p>os.path.getsize() 返回文件大小 字节单位</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>  os</span><br><span class="line">print(os.path.getsize(<span class="string">"E:\资料\python\hexo\\numcount.py"</span>))</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test2.py
171

进程已结束，退出代码 0</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.path.commonprefix(list) <span class="comment">#返回list(多个路径)中，所有path共有的最长的路径</span></span><br><span class="line">os.path.lexists <span class="comment">#路径存在则返回True,路径损坏也返回True</span></span><br><span class="line">os.path.expanduser(path) <span class="comment">#把path中包含的”~”和”~user”转换成用户目录</span></span><br><span class="line">os.path.expandvars(path) <span class="comment">#根据环境变量的值替换path中包含的”$name”和”$&#123;name&#125;”</span></span><br><span class="line">os.path.sameopenfile(fp1, fp2) <span class="comment">#判断fp1和fp2是否指向同一文件</span></span><br><span class="line">os.path.samestat(stat1, stat2) <span class="comment">#判断stat tuple stat1和stat2是否指向同一个文件</span></span><br><span class="line">os.path.splitdrive(path) <span class="comment">#一般用在windows下，返回驱动器名和路径组成的元组</span></span><br><span class="line">os.path.walk(path, visit, arg) <span class="comment">#遍历path，给每个path执行一个函数详细见手册</span></span><br><span class="line">os.path.supports_unicode_filenames() 设置是否支持unicode路径名</span><br></pre></td></tr></table></figure>

<h2 id="stat模块"><a href="#stat模块" class="headerlink" title="stat模块"></a>stat模块</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">描述os.stat()返回的文件属性列表中各值的意义</span><br><span class="line">fileStats = os.stat(path) 获取到的文件属性列表</span><br><span class="line">fileStats[stat.ST_MODE] 获取文件的模式</span><br><span class="line">fileStats[stat.ST_SIZE] 文件大小</span><br><span class="line">fileStats[stat.ST_MTIME] 文件最后修改时间</span><br><span class="line">fileStats[stat.ST_ATIME] 文件最后访问时间</span><br><span class="line">fileStats[stat.ST_CTIME] 文件创建时间</span><br><span class="line">stat.S_ISDIR(fileStats[stat.ST_MODE]) 是否目录</span><br><span class="line">stat.S_ISREG(fileStats[stat.ST_MODE]) 是否一般文件</span><br><span class="line">stat.S_ISLNK(fileStats[stat.ST_MODE]) 是否连接文件</span><br><span class="line">stat.S_ISSOCK(fileStats[stat.ST_MODE]) 是否COCK文件</span><br><span class="line">stat.S_ISFIFO(fileStats[stat.ST_MODE]) 是否命名管道</span><br><span class="line">stat.S_ISBLK(fileStats[stat.ST_MODE]) 是否块设备</span><br><span class="line">stat.S_ISCHR(fileStats[stat.ST_MODE]) 是否字符设置</span><br></pre></td></tr></table></figure>

<h2 id="sys模块"><a href="#sys模块" class="headerlink" title="sys模块"></a>sys模块</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sys.argv 命令行参数List，第一个元素是程序本身路径 </span><br><span class="line">sys.path 返回模块的搜索路径，初始化时使用PYTHONPATH环境变量的值 </span><br><span class="line">sys.modules.keys() 返回所有已经导入的模块列表</span><br><span class="line">sys.modules 返回系统导入的模块字段，key是模块名，value是模块 </span><br><span class="line">sys.exc_info() 获取当前正在处理的异常类,exc_type、exc_value、exc_traceback当前处理的异常详细信息</span><br><span class="line">sys.exit(n) 退出程序，正常退出时exit(<span class="number">0</span>)</span><br><span class="line">sys.hexversion 获取Python解释程序的版本值，<span class="number">16</span>进制格式如：<span class="number">0x020403F0</span></span><br><span class="line">sys.version 获取Python解释程序的版本信息</span><br><span class="line">sys.platform 返回操作系统平台名称</span><br><span class="line">sys.stdout 标准输出</span><br><span class="line">sys.stdout.write(‘aaa‘) 标准输出内容</span><br><span class="line">sys.stdout.writelines() 无换行输出</span><br><span class="line">sys.stdin 标准输入</span><br><span class="line">sys.stdin.read() 输入一行</span><br><span class="line">sys.stderr 错误输出</span><br><span class="line">sys.exc_clear() 用来清除当前线程所出现的当前的或最近的错误信息 </span><br><span class="line">sys.exec_prefix 返回平台独立的python文件安装的位置 </span><br><span class="line">sys.byteorder 本地字节规则的指示器，big-endian平台的值是‘big‘,little-endian平台的值是‘little‘ </span><br><span class="line">sys.copyright 记录python版权相关的东西 </span><br><span class="line">sys.api_version 解释器的C的API版本 </span><br><span class="line">sys.version_info ‘final‘表示最终,也有‘candidate‘表示候选，表示版本级别，是否有后继的发行 </span><br><span class="line">sys.getdefaultencoding() 返回当前你所用的默认的字符编码格式 </span><br><span class="line">sys.getfilesystemencoding() 返回将Unicode文件名转换成系统文件名的编码的名字 </span><br><span class="line">sys.builtin_module_names Python解释器导入的内建模块列表 </span><br><span class="line">sys.executable Python解释程序路径 </span><br><span class="line">sys.getwindowsversion() 获取Windows的版本 </span><br><span class="line">sys.stdin.readline() 从标准输入读一行，sys.stdout.write(“a”) 屏幕输出a</span><br><span class="line">sys.setdefaultencoding(name) 用来设置当前默认的字符编码(详细使用参考文档) </span><br><span class="line">sys.displayhook(value) 如果value非空，这个函数会把他输出到sys.stdout(详细使用参考文档)</span><br></pre></td></tr></table></figure>

<h2 id="datetime-date-time模块"><a href="#datetime-date-time模块" class="headerlink" title="datetime,date,time模块"></a>datetime,date,time模块</h2><p>datetime.date.today() 本地日期对象,(用str函数可得到它的字面表示(2014-03-24))</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line">now = datetime.date.today()</span><br><span class="line">print(now)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test2.py
2020-06-19

进程已结束，退出代码 0</code></pre><p>datetime.date.isoformat(obj) 当前[年-月-日]字符串表示(2014-03-24)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line">time = datetime.date.today()</span><br><span class="line">print(datetime.date.isoformat(time))</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test2.py
2020-06-19

进程已结束，退出代码 0</code></pre><p>datetime.date.fromtimestamp() 返回一个日期对象，参数是时间戳,返回 [年-月-日]</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line">time = datetime.date.fromtimestamp(<span class="number">1592481600</span>)</span><br><span class="line">print(time)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test2.py
2020-06-18

进程已结束，退出代码 0</code></pre><p>datetime.date.weekday(obj) 返回一个日期对象的星期数,周一是0</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line">time = datetime.date.fromtimestamp(<span class="number">1592481600</span>)</span><br><span class="line">print(time.weekday())    <span class="comment">#  打印当前时间的星期数   周一是0</span></span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test2.py
3

进程已结束，退出代码 0</code></pre><p>datetime.date.isoweekday(obj) 返回一个日期对象的星期数,周一是1</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line">time = datetime.date.fromtimestamp(<span class="number">1592481600</span>)</span><br><span class="line">print(time.isoweekday())</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test2.py
4

进程已结束，退出代码 0</code></pre><p>datetime.date.isocalendar(obj) 把日期对象返回一个带有年 第几周 周几的元组</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line">time = datetime.date.today()</span><br><span class="line">print(time.isocalendar())</span><br><span class="line">print(datetime.date.isocalendar(time))</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test2.py
(2020, 25, 5)
(2020, 25, 5)

进程已结束，退出代码 0</code></pre><h2 id="datetime对象："><a href="#datetime对象：" class="headerlink" title="datetime对象："></a>datetime对象：</h2><p>datetime.datetime.today() 返回一个包含本地时间(含微秒数)的datetime对象 2014-03-24 23:31:50.419000</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line">time = datetime.datetime.today()</span><br><span class="line">print(time)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test2.py
2020-06-19 17:58:32.643581

进程已结束，退出代码 0</code></pre><p>datetime.datetime.now([tz]) 返回指定时区的datetime对象   默认当前时区 2014-03-24 23:31:50.419000</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line">time = datetime.datetime.now()</span><br><span class="line">print(time)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test2.py
2020-06-19 18:01:00.380030

进程已结束，退出代码 0</code></pre><p>datetime.datetime.utcnow() 返回一个零时区的datetime对象   </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line">time = datetime.datetime.utcnow()</span><br><span class="line">print(time)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test2.py
2020-06-19 10:03:02.280002

进程已结束，退出代码 0</code></pre><p>datetime.fromtimestamp(timestamp[,tz]) 按时间戳返回一个datetime对象，可指定时区,可用于strftime转换为日期表示 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span>  time</span><br><span class="line">time = datetime.datetime.fromtimestamp(<span class="number">1592481600</span>)</span><br><span class="line">print(time)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test2.py
2020-06-18 20:00:00

进程已结束，退出代码 0</code></pre><p>datetime.utcfromtimestamp(timestamp) 按时间戳返回一个UTC-datetime对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span>  time</span><br><span class="line">time = datetime.datetime.utcfromtimestamp(<span class="number">1592481600</span>)</span><br><span class="line">print(time)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test2.py
2020-06-18 12:00:00

进程已结束，退出代码 0</code></pre><p>datetime.datetime.strptime(‘2014-03-16 12:21:21‘,”%Y-%m-%d %H:%M:%S”) 将字符串转为datetime对象<br><br>可以自定义格式     就是将时间戳转换成你想要的时间格式<br></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line">time = datetime.datetime.strptime(<span class="string">"2020-05-01 10:00:00"</span>,<span class="string">"%Y-%m-%d %H:%M:%S"</span>)</span><br><span class="line">print(time)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test2.py
2020-05-01 10:00:00

进程已结束，退出代码 0</code></pre><p>datetime.datetime.strftime(datetime.datetime.now(), ‘%Y%m%d %H%M%S‘) 将datetime对象转换为str表示形式<br><br>可以自定义格式     就是将时间戳转换成你想要的时间格式<br></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span>  time</span><br><span class="line">time = datetime.datetime.fromtimestamp(<span class="number">1592481600</span>)</span><br><span class="line">print(time.strftime(<span class="string">"%Y%m%d %H%M%S"</span>))</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test2.py
20200618 200000

进程已结束，退出代码 0</code></pre><p>datetime.date.today().timetuple() 转换为时间戳datetime元组对象，可用于转换时间戳</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span>  time</span><br><span class="line">time = datetime.datetime.today(<span class="number">1592481600</span>)</span><br><span class="line">print(time.timetuple())</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test2.py
time.struct_time(tm_year=2020, tm_mon=6, tm_mday=18, tm_hour=20, tm_min=0, tm_sec=0, tm_wday=3, tm_yday=170, tm_isdst=-1)

进程已结束，退出代码 0</code></pre><p>datetime.datetime.now().timetuple()</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span>  time</span><br><span class="line">time = datetime.datetime.now()</span><br><span class="line">print(time.timetuple())</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test2.py
time.struct_time(tm_year=2020, tm_mon=6, tm_mday=19, tm_hour=19, tm_min=15, tm_sec=6, tm_wday=4, tm_yday=171, tm_isdst=-1)

进程已结束，退出代码 0</code></pre><p>time.mktime(timetupleobj) 将datetime元组对象转为时间戳</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span>  time</span><br><span class="line">aa = (<span class="number">2020</span>, <span class="number">6</span>, <span class="number">19</span>, <span class="number">19</span>, <span class="number">15</span>, <span class="number">6</span>,<span class="number">4</span>, <span class="number">171</span>,<span class="number">-1</span>)  <span class="comment"># 定义时间元祖</span></span><br><span class="line">time = time.mktime(aa)      <span class="comment"># 转换元祖为时间戳</span></span><br><span class="line">print(time)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test2.py
1592565306.0

进程已结束，退出代码 0</code></pre><p>time.time() 当前时间戳</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span>  time</span><br><span class="line">time = time.time()</span><br><span class="line">print(time)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test2.py
1592565722.2161117

进程已结束，退出代码 0</code></pre><p>time.localtime()  当前时间  以元祖格式显示</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span>  time</span><br><span class="line">time = time.localtime()</span><br><span class="line">print(time)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test2.py
time.struct_time(tm_year=2020, tm_mon=6, tm_mday=19, tm_hour=19, tm_min=22, tm_sec=50, tm_wday=4, tm_yday=171, tm_isdst=0)

进程已结束，退出代码 0</code></pre><p>time.gmtime()  和 time.localtime()  时区不同</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span>  time</span><br><span class="line">qq = time.gmtime()</span><br><span class="line">print(qq)</span><br><span class="line">aa = time.localtime()</span><br><span class="line">print(aa)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test2.py
time.struct_time(tm_year=2020, tm_mon=6, tm_mday=19, tm_hour=11, tm_min=31, tm_sec=3, tm_wday=4, tm_yday=171, tm_isdst=0)
time.struct_time(tm_year=2020, tm_mon=6, tm_mday=19, tm_hour=19, tm_min=31, tm_sec=3, tm_wday=4, tm_yday=171, tm_isdst=0)

进程已结束，退出代码 0</code></pre><h2 id="datetime模块案例"><a href="#datetime模块案例" class="headerlink" title="datetime模块案例"></a>datetime模块案例</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span>  time</span><br><span class="line"></span><br><span class="line"><span class="comment"># datetime.date</span></span><br><span class="line">localtime = datetime.date.today()   <span class="comment"># 获取当前时间</span></span><br><span class="line">print(localtime.strftime(<span class="string">"%Y-%m-%d"</span>))   <span class="comment"># 打印当前时间的年月日</span></span><br><span class="line">print(localtime.fromtimestamp(<span class="number">1592681600</span>))  <span class="comment"># 打印时间戳的年月日</span></span><br><span class="line">print(localtime.isoweekday())  <span class="comment"># 查看今天周几    周一为1</span></span><br><span class="line">print(localtime.weekday())   <span class="comment"># 查看今天周几  周一为0</span></span><br><span class="line">print(localtime.isocalendar()) <span class="comment"># 以元祖格式显示 年  第几周   周几</span></span><br><span class="line">print(localtime.isoformat())  <span class="comment"># 打印当前时间的年月日</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># datetime.datetime</span></span><br><span class="line">d_localtime = datetime.datetime.now() <span class="comment"># 获取当前时间</span></span><br><span class="line">print(d_localtime)  <span class="comment"># 打印当前时间(包含微秒)</span></span><br><span class="line">print(d_localtime.year,<span class="string">"-"</span>,d_localtime.month,<span class="string">"-"</span>,d_localtime.day)  <span class="comment"># 打印年月日</span></span><br><span class="line">print(d_localtime.hour,<span class="string">":"</span>,d_localtime.minute,<span class="string">":"</span>,d_localtime.second)   <span class="comment"># 打印时分秒</span></span><br><span class="line">print(datetime.datetime.utcnow()) <span class="comment"># 打印零时区的当前时间</span></span><br><span class="line">print(d_localtime.strptime(<span class="string">"2020-10-01 10:10:10"</span>,<span class="string">"%Y-%m-%d %H:%M:%S"</span>))  <span class="comment"># 打印自定义时间</span></span><br><span class="line">print(d_localtime.strftime(<span class="string">"%H:%M:%S"</span>)) <span class="comment"># 打印自定义格式</span></span><br><span class="line">print(d_localtime.timetuple())  <span class="comment"># 以元祖格式显示</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># time</span></span><br><span class="line">now = aa = (<span class="number">2020</span>, <span class="number">6</span>, <span class="number">19</span>, <span class="number">19</span>, <span class="number">15</span>, <span class="number">6</span>,<span class="number">4</span>, <span class="number">171</span>,<span class="number">-1</span>)  <span class="comment"># 定义时间元祖</span></span><br><span class="line">print(time.mktime(now))   <span class="comment"># 元祖转换为时间戳</span></span><br><span class="line">print(time.time())  <span class="comment"># 打印当前时间戳</span></span><br><span class="line">print(time.localtime())  <span class="comment">#  打印当前时间 以元祖的格式</span></span><br><span class="line">print(time.gmtime())  <span class="comment"># 打印零时区的时间   以元祖的格式</span></span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test2.py
2020-06-20
2020-06-21
6
5
(2020, 25, 6)
2020-06-20
2020-06-20 09:37:43.631672
2020 - 6 - 20
9 : 37 : 43
2020-06-20 01:37:43.631672
2020-10-01 10:10:10
09:37:43
time.struct_time(tm_year=2020, tm_mon=6, tm_mday=20, tm_hour=9, tm_min=37, tm_sec=43, tm_wday=5, tm_yday=172, tm_isdst=-1)
1592565306.0
1592617063.6546738
time.struct_time(tm_year=2020, tm_mon=6, tm_mday=20, tm_hour=9, tm_min=37, tm_sec=43, tm_wday=5, tm_yday=172, tm_isdst=0)
time.struct_time(tm_year=2020, tm_mon=6, tm_mday=20, tm_hour=1, tm_min=37, tm_sec=43, tm_wday=5, tm_yday=172, tm_isdst=0)

进程已结束，退出代码 0</code></pre><h2 id="hashilb-md5模块"><a href="#hashilb-md5模块" class="headerlink" title="hashilb,md5模块"></a>hashilb,md5模块</h2><p>hashlib.md5(‘md5_str‘).hexdigest() 对指定字符串md5加密</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib   <span class="comment"># 导入模块</span></span><br><span class="line">str = <span class="string">"test"</span>  <span class="comment">#  定义需要加密的字符串</span></span><br><span class="line">str1 = hashlib.md5()  <span class="comment">#  md5转码utf-8</span></span><br><span class="line">str1.update(str.encode(<span class="string">"utf-8"</span>))  <span class="comment"># 必须指定转码格式</span></span><br><span class="line">print(str1.hexdigest()) <span class="comment"># 加密字符串</span></span><br><span class="line">print(str1.digest())</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/hexo.py
098f6bcd4621d373cade4e832627b4f6
b&quot;\t\x8fk\xcdF!\xd3s\xca\xdeN\x83&amp;&apos;\xb4\xf6&quot;

进程已结束，退出代码 0</code></pre><h2 id="random模块"><a href="#random模块" class="headerlink" title="random模块"></a>random模块</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="comment"># 产生0-1的随机浮点数</span></span><br><span class="line">print(random.random())</span><br><span class="line"><span class="comment"># 产生指定范围内的随机浮点数</span></span><br><span class="line">print(random.uniform(<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line"><span class="comment"># 产生指定范围内的随机整数</span></span><br><span class="line">print(random.randint(<span class="number">5</span>,<span class="number">10</span>))</span><br><span class="line"><span class="comment"># 从一个指定步长的集合中产生随机数</span></span><br><span class="line">print(random.randrange(<span class="number">10</span>,<span class="number">30</span>,<span class="number">5</span>)) <span class="comment"># (从10-30 步长为5 产生随机数 10，15,20,25,30)</span></span><br><span class="line"><span class="comment"># 从序列中获取一个随机元素  random.choice(sequence)</span></span><br><span class="line"><span class="comment"># 参数sequence表示一个有序类型。这里要说明 一下：sequence在python不是一种特定的类型，而是泛指一系列的类型。list, tuple, 字符串都属于sequence</span></span><br><span class="line">str = <span class="string">"test"</span>,<span class="string">"test2"</span>,<span class="string">"test3"</span>,<span class="string">"test4"</span></span><br><span class="line">print(random.choice(str))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将一个列表中的元素打乱</span></span><br><span class="line">list = [<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>,<span class="string">"e"</span>,<span class="string">"f"</span>,<span class="string">"g"</span>]</span><br><span class="line">random.shuffle(list)</span><br><span class="line">print(list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从序列中随机获取指定长度的片段</span></span><br><span class="line">list = [<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>,<span class="string">"e"</span>,<span class="string">"f"</span>,<span class="string">"g"</span>]</span><br><span class="line">print(random.sample(list,<span class="number">4</span>))   <span class="comment"># 打印序列中的前四个</span></span><br><span class="line">num = [<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>,<span class="string">"4"</span>,<span class="string">"5"</span>,<span class="string">"6"</span>]</span><br><span class="line">print(random.sample(num,<span class="number">3</span>))  <span class="comment"># 打印序列中的前三个</span></span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/hexo.py
0.630213372552819
1.6560316051826613
7
25
test2
[&apos;d&apos;, &apos;g&apos;, &apos;b&apos;, &apos;f&apos;, &apos;e&apos;, &apos;a&apos;, &apos;c&apos;]
[&apos;g&apos;, &apos;b&apos;, &apos;e&apos;, &apos;f&apos;]
[&apos;1&apos;, &apos;6&apos;, &apos;5&apos;]

进程已结束，退出代码 0</code></pre>]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python基础之模块导入</title>
    <url>/2020/06/18/python-12/</url>
    <content><![CDATA[<h2 id="模块的概念"><a href="#模块的概念" class="headerlink" title="模块的概念"></a>模块的概念</h2><pre><code>模块是python程序架构的一个核心概念
每一个以扩展名py结尾的python源代码文件都是一个模块
模块名同样也是一个标识符。需要符合标识符的命名规则
在模块中定义的全局变量、函数、类都是提供给外界直接使用的工具
模块就好比是工具包，要想使用这个工具包中的工具，就需要先导入这个模块</code></pre><h2 id="import语句"><a href="#import语句" class="headerlink" title="import语句"></a>import语句</h2><p>当解释器遇到 import 语句，如果模块在当前的搜索路径就会被导入,搜索路径是一个解释器会先进行搜索的所有目录的列表。如想要导入模块 support，需要把命令放在脚本的顶端<br><br>想使用 Python 源文件，只需在另一个源文件里执行 import 语句，语法如下：<br></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 提示：在导入模块时，每个导入应该独占一行</span></span><br><span class="line"><span class="keyword">import</span> 模块名<span class="number">1</span></span><br><span class="line"><span class="keyword">import</span> 模块名<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>导入之后,通过模块名.  使用模块提供的工具–全局变量、函数、类</p>
<h2 id="import导入指定别名"><a href="#import导入指定别名" class="headerlink" title="import导入指定别名"></a>import导入指定别名</h2><p>import  模块名  as  模块别名</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>  test_1  <span class="keyword">as</span>  T1</span><br><span class="line">T1.hello()</span><br></pre></td></tr></table></figure>
<h2 id="from-…-import-局部导入"><a href="#from-…-import-局部导入" class="headerlink" title="from … import 局部导入"></a>from … import 局部导入</h2><p>如果希望从某一模块中，导入部分工具，就可以使用from…import 的方式<br><br>from  模块名  import 工具名<br><br>使用from导入后  不需要通过模块名.   的方式调用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> test_2  <span class="keyword">import</span> hello</span><br><span class="line"><span class="comment">#直接调用  不需要通过模块名.   的方式调用</span></span><br><span class="line">hello()</span><br></pre></td></tr></table></figure>
<p>注意：如果两个模块，存在同名的函数，那么后导入模块的函数，会覆盖先导入的函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ... <span class="keyword">import</span> ... <span class="keyword">as</span> ...</span><br></pre></td></tr></table></figure>
<h2 id="路径搜索和搜索路径"><a href="#路径搜索和搜索路径" class="headerlink" title="路径搜索和搜索路径"></a>路径搜索和搜索路径</h2><p>上面提到的都是导入同级目录下的模块,如果不在同一级目录下：<br><br>import  module_name 实际上是找 module_name.py文件,是文件就一定有路径<br><br>导入模块就是：找到.py文件的位置,把他执行一遍   使用sys.path.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">print(sys.path)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test2.py
[&apos;E:\\资料\\python\\hexo&apos;, &apos;E:\\资料\\python&apos;, &apos;E:\\资料\\python\\面向对象\\模块&apos;, &apos;E:\\资料\\python\\自走棋&apos;, &apos;E:\\资料\\python\\飞机大战&apos;, &apos;D:\\软件下载\\python36.zip&apos;, &apos;D:\\软件下载\\DLLs&apos;, &apos;D:\\软件下载\\lib&apos;, &apos;D:\\软件下载&apos;, &apos;C:\\Users\\Administrator\\AppData\\Roaming\\Python\\Python36\\site-packages&apos;, &apos;D:\\软件下载\\lib\\site-packages&apos;, &apos;D:\\install\\PyCharm 2018.3.4\\helpers\\pycharm_matplotlib_backend&apos;]

进程已结束，退出代码 0</code></pre><p>里面的’’指的是当前路径,这也是为何查找模块先从当前目录查找的原因</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>  os    <span class="comment"># 导入os模块</span></span><br><span class="line">print(os.path.abspath(__file__))   <span class="comment"># 当前文件绝对路径</span></span><br><span class="line">print(os.path.dirname(os.path.abspath(__file__)))  <span class="comment"># 获取目录名</span></span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test2.py
E:\资料\python\hexo\test2.py
E:\资料\python\hexo

进程已结束，退出代码 0</code></pre><h2 id="导入优化"><a href="#导入优化" class="headerlink" title="导入优化"></a>导入优化</h2><pre><code class="python"><span class="keyword">import</span> module_test
<span class="comment"># import 导入情况,如果重复调用,python就会重复查找,避免重复查找,可以使用from的方式导入</span>
<span class="keyword">from</span> module_test  <span class="keyword">import</span>  test</code></pre>
]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python基础之for循环</title>
    <url>/2020/06/17/python-11/</url>
    <content><![CDATA[<h2 id="for循环语句"><a href="#for循环语句" class="headerlink" title="for循环语句"></a>for循环语句</h2><p>python中for循环可以遍历任何序列的项目,如一个列表或者一个字符串,语法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> name i list:</span><br><span class="line">      print(name)</span><br></pre></td></tr></table></figure>
<p>示例:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> letter <span class="keyword">in</span> <span class="string">"python"</span>:</span><br><span class="line">    print(<span class="string">"当前字母 %s"</span> % letter)</span><br><span class="line"></span><br><span class="line">list = [<span class="string">"banana"</span>,<span class="string">"apple"</span>,<span class="string">"mango"</span>]</span><br><span class="line"><span class="keyword">for</span>  fruit <span class="keyword">in</span> list:</span><br><span class="line">    print(<span class="string">"当前水果 %s"</span> % fruit)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"Good bye"</span>)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test2.py
当前字母 p
当前字母 y
当前字母 t
当前字母 h
当前字母 o
当前字母 n
当前水果 banana
当前水果 apple
当前水果 mango
Good bye

进程已结束，退出代码 0</code></pre><h2 id="通过序列索引迭代"><a href="#通过序列索引迭代" class="headerlink" title="通过序列索引迭代"></a>通过序列索引迭代</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">list = [<span class="string">"banana"</span>,<span class="string">"apple"</span>,<span class="string">"mango"</span>]</span><br><span class="line"><span class="keyword">for</span>  fruit <span class="keyword">in</span> range(len(list)):</span><br><span class="line">    print(<span class="string">"当前水果 %s"</span> % list[fruit])</span><br><span class="line"></span><br><span class="line">print(<span class="string">"Good bye"</span>)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test2.py
当前水果 banana
当前水果 apple
当前水果 mango
Good bye

进程已结束，退出代码 0</code></pre><p>以上实例我们使用了内置函数 len() 和 range(),函数 len() 返回列表的长度，即元素的个数。 range返回一个序列的数。</p>
<h2 id="循环使用else语句"><a href="#循环使用else语句" class="headerlink" title="循环使用else语句"></a>循环使用else语句</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,<span class="number">20</span>):</span><br><span class="line">    <span class="keyword">if</span> i%<span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        print(<span class="string">"%d 是一个双数"</span> % i)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"%d 是一个单数"</span> % i)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test2.py
2 是一个双数
3 是一个单数
4 是一个双数
5 是一个单数
6 是一个双数
7 是一个单数
8 是一个双数
9 是一个单数
10 是一个双数
11 是一个单数
12 是一个双数
13 是一个单数
14 是一个双数
15 是一个单数
16 是一个双数
17 是一个单数
18 是一个双数
19 是一个单数

进程已结束，退出代码 0</code></pre><h2 id="跳出当前循环和退出循环"><a href="#跳出当前循环和退出循环" class="headerlink" title="跳出当前循环和退出循环"></a>跳出当前循环和退出循环</h2><p>break退出循环</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> letter <span class="keyword">in</span> <span class="string">"python"</span>:</span><br><span class="line">    <span class="keyword">if</span> letter == <span class="string">"h"</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    print(<span class="string">"当前字母 %s"</span> % letter)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test2.py
当前字母 p
当前字母 y
当前字母 t

进程已结束，退出代码 0</code></pre><p>continue跳出当前循环</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> letter <span class="keyword">in</span> <span class="string">"python"</span>:</span><br><span class="line">    <span class="keyword">if</span> letter == <span class="string">"h"</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    print(<span class="string">"当前字母 %s"</span> % letter)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test2.py
当前字母 p
当前字母 y
当前字母 t
当前字母 o
当前字母 n

进程已结束，退出代码 0</code></pre><h2 id="循环遍历练习"><a href="#循环遍历练习" class="headerlink" title="循环遍历练习"></a>循环遍历练习</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name_list = [<span class="string">"张三"</span>,<span class="string">"李四"</span>,<span class="string">"王五"</span>,<span class="string">"赵六"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">##使用循环遍历</span></span><br><span class="line"><span class="comment">##循环打印列表中的数据 第一个除外</span></span><br><span class="line">a = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> myname <span class="keyword">in</span> name_list:</span><br><span class="line"></span><br><span class="line">    a += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> a == <span class="number">1</span>:</span><br><span class="line">        print(<span class="string">"错误"</span>)</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"myname is %s"</span> % myname)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python基础之while循环</title>
    <url>/2020/06/17/python-10/</url>
    <content><![CDATA[<h2 id="while循环语句"><a href="#while循环语句" class="headerlink" title="while循环语句"></a>while循环语句</h2><p>python编程中while用于循环执行程序,即在某条件下,循环执行某段程序,以处理需要重复处理的相同任务,格式为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> 判断条件:</span><br><span class="line">    执行语句</span><br></pre></td></tr></table></figure>
<p>执行语句可以是单个语句或语句块。判断条件可以是任何表达式，任何非零、或非空（null）的值均为true。当判断条件假 false 时，循环结束。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> count &lt; <span class="number">9</span>:</span><br><span class="line">    print(<span class="string">"the count is %d"</span> % count)</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">print(<span class="string">"Good bye !"</span>)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test2.py
the count is 0
the count is 1
the count is 2
the count is 3
the count is 4
the count is 5
the count is 6
the count is 7
the count is 8
Good bye !

进程已结束，退出代码 0</code></pre><p>while 语句时还有另外两个重要的命令 continue，break 来跳过循环，continue 用于跳过该次循环，break 则是用于退出循环，此外”判断条件”还可以是个常值，表示循环必定成立，具体用法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打印1-10所有的双数</span></span><br><span class="line">i = <span class="number">1</span>     <span class="comment"># 定义变量</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="number">10</span>:   <span class="comment"># while判断条件 如果 i 小于10 就执行</span></span><br><span class="line">    i += <span class="number">1</span>      <span class="comment"># 计数器 i + 1 </span></span><br><span class="line">    <span class="keyword">if</span> i%<span class="number">2</span> &gt; <span class="number">0</span>:    <span class="comment"># 判断如果 i 除以 2 余数 大于 0 就退出</span></span><br><span class="line">        <span class="keyword">continue</span>    </span><br><span class="line">    print(i,end=<span class="string">","</span>)   <span class="comment">#  打印所有双数  以","分割   end="" 代表不换行</span></span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test2.py
2,4,6,8,10,
进程已结束，退出代码 0</code></pre><p>无限循环</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 无限循环</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    print(<span class="string">"hello"</span>)</span><br></pre></td></tr></table></figure>

<h2 id="循环使用else语句"><a href="#循环使用else语句" class="headerlink" title="循环使用else语句"></a>循环使用else语句</h2><p>在 python 中，while … else 在循环条件为 false 时执行 else 语句块：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> count &lt; <span class="number">5</span>:</span><br><span class="line">    print(<span class="string">"%d 小于 5"</span> % count)</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"%d 大于等于 5"</span> % count)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test2.py
0 小于 5
1 小于 5
2 小于 5
3 小于 5
4 小于 5
5 大于等于 5

进程已结束，退出代码 0</code></pre><h2 id="循环练习"><a href="#循环练习" class="headerlink" title="循环练习"></a>循环练习</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">	</span><br><span class="line">	num = random.randint(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line">	counter = <span class="number">0</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> counter &lt; <span class="number">5</span>:</span><br><span class="line">	    answer = int(input(<span class="string">'guess the number: '</span>))</span><br><span class="line">	    <span class="keyword">if</span> answer &gt; num:</span><br><span class="line">	        print(<span class="string">'猜大了'</span>)</span><br><span class="line">	    <span class="keyword">elif</span> answer &lt; num:</span><br><span class="line">	        print(<span class="string">'猜小了'</span>)</span><br><span class="line">	    <span class="keyword">else</span>:</span><br><span class="line">	        print(<span class="string">'猜对了'</span>)</span><br><span class="line">	        <span class="keyword">break</span></span><br><span class="line">	    counter += <span class="number">1</span></span><br><span class="line">	<span class="keyword">else</span>:  <span class="comment"># 循环被break就不执行了，没有被break才执行</span></span><br><span class="line">	    print(<span class="string">'the number is:'</span>, num)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python基础之基本运算</title>
    <url>/2020/06/16/python-9/</url>
    <content><![CDATA[<h2 id="Python语言支持以下类型的运算符"><a href="#Python语言支持以下类型的运算符" class="headerlink" title="Python语言支持以下类型的运算符:"></a>Python语言支持以下类型的运算符:</h2><pre><code>算术运算符
比较运算符
赋值运算符
逻辑运算符
位运算符
成员运算符
身份运算符
运算符优先级</code></pre><h2 id="python算术运算符"><a href="#python算术运算符" class="headerlink" title="python算术运算符"></a>python算术运算符</h2><p>以下假设变量： a = 10, b = 20:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">运算符	      描述                                                	实例</span><br><span class="line">+        加 - 两个对象相加                                       a + b 结果输出 <span class="number">30</span></span><br><span class="line">-        减 - 得到负数或是一个数减去另一个数                       a - b 结果输出 <span class="number">-10</span> </span><br><span class="line">*        乘 - 两个数相乘是返回一个被重复若干次的字符串              a * b 结果输出 <span class="number">200</span></span><br><span class="line">/	       除 - x除以y	b / a                                   输出结果 <span class="number">2</span></span><br><span class="line">%	       取模 - 返回除法的余数	                                b % a 输出结果 <span class="number">0</span></span><br><span class="line">**	     幂 - 返回x的y次幂	a**b 为<span class="number">10</span>的<span class="number">20</span>次方                    输出结果 <span class="number">100000000000000000000</span></span><br><span class="line">//	     取整除 - 返回商的整数部分（向下取整）                     &gt;&gt;&gt; <span class="number">9</span>//<span class="number">2</span></span><br><span class="line">                                                                <span class="number">4</span></span><br><span class="line">                                                                &gt;&gt;&gt; <span class="number">-9</span>//<span class="number">2</span></span><br><span class="line">                                                                <span class="number">-5</span></span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">21</span></span><br><span class="line">b = <span class="number">10</span></span><br><span class="line">c = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">c = a + b</span><br><span class="line">print(<span class="string">"c的值为 %d"</span> % c)</span><br><span class="line"></span><br><span class="line">c = a - b</span><br><span class="line">print(<span class="string">"c的值为 %d"</span> % c)</span><br><span class="line"></span><br><span class="line">c = a * b</span><br><span class="line">print(<span class="string">"c的值为 %d"</span> % c)</span><br><span class="line"></span><br><span class="line">c = a / b</span><br><span class="line">print(<span class="string">"c的值为 %d"</span> % c)</span><br><span class="line"></span><br><span class="line">c = a % b</span><br><span class="line">print(<span class="string">"c的值为 %d"</span> % c)</span><br><span class="line"></span><br><span class="line">a = <span class="number">2</span></span><br><span class="line">b = <span class="number">3</span></span><br><span class="line">c = a ** b</span><br><span class="line">print(<span class="string">"c的值为 %d"</span> % c)</span><br><span class="line"></span><br><span class="line">a = <span class="number">10</span></span><br><span class="line">b = <span class="number">5</span></span><br><span class="line">c = a // b</span><br><span class="line">print(<span class="string">"c的值为 %d"</span> % c)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test2.py
c的值为 31
c的值为 11
c的值为 210
c的值为 2
c的值为 1
c的值为 8
c的值为 2

进程已结束，退出代码 0</code></pre><p>注意：python2.x里,整数除以整数只能得到整数,如果想要得到小数部分,把其中一个数改成浮点数即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span>/<span class="number">2</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1.0</span>/<span class="number">2</span></span><br><span class="line"><span class="number">0.5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span>/float(<span class="number">2</span>)</span><br><span class="line"><span class="number">0.5</span></span><br></pre></td></tr></table></figure>

<h2 id="python比较运算符"><a href="#python比较运算符" class="headerlink" title="python比较运算符"></a>python比较运算符</h2><p>以下假设变量a为10，变量b为20：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">运算符	      描述                                                                                        	实例</span><br><span class="line">==	    等于 - 比较对象是否相等	                                                                         (a == b) 返回 <span class="literal">False</span>。</span><br><span class="line">!=	    不等于 - 比较两个对象是否不相等	                                                                 (a != b) 返回 true.</span><br><span class="line">&lt;&gt;	    不等于 - 比较两个对象是否不相等。 python3 已废弃。	                                                 (a &lt;&gt; b) 返回 true。这个运算符类似 != 。</span><br><span class="line">&gt;	      大于 - 返回x是否大于y	                                                                         (a &gt; b) 返回 <span class="literal">False</span>。</span><br><span class="line">&lt;	      小于 - 返回x是否小于y。所有比较运算符返回<span class="number">1</span>表示真，返回<span class="number">0</span>表示假。这分别与特殊的变量<span class="literal">True</span>和<span class="literal">False</span>等价。	 (a &lt; b) 返回 true。</span><br><span class="line">&gt;=	    大于等于 - 返回x是否大于等于y。	                                                                 (a &gt;= b) 返回 <span class="literal">False</span>。</span><br><span class="line">&lt;=	    小于等于 - 返回x是否小于等于y。	                                                                 (a &lt;= b) 返回 true。</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">21</span></span><br><span class="line">b = <span class="number">10</span></span><br><span class="line">c = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> a == b:</span><br><span class="line">    print(<span class="string">"a 等于 b"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"a 不等于 b"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> a != b:</span><br><span class="line">    print(<span class="string">"a 不等于 b"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"a 等于  b"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> a &lt; b:</span><br><span class="line">    print(<span class="string">"a 小于 b"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"a 大于等于 b"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> a &gt; b:</span><br><span class="line">    print(<span class="string">"a 大于 b"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"a 小于等于 b"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改变量 a 和 b 的值</span></span><br><span class="line">a = <span class="number">5</span></span><br><span class="line">b = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> a &lt;= b:</span><br><span class="line">    print(<span class="string">"a 小于等于 b"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"a 大于 b"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> b &gt;= a:</span><br><span class="line">    print(<span class="string">"b 大于等于 a"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"b 小于 a"</span>)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test2.py
a 不等于 b
a 不等于 b
a 大于等于 b
a 大于 b
a 小于等于 b
b 大于等于 a

进程已结束，退出代码 0</code></pre><h2 id="python赋值运算符"><a href="#python赋值运算符" class="headerlink" title="python赋值运算符"></a>python赋值运算符</h2><p>以下假设变量a为10,变量b为20：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">运算符	描述	实例</span><br><span class="line">=	      简单的赋值运算符	              c = a + b 将 a + b 的运算结果赋值为 c</span><br><span class="line">+=	      加法赋值运算符	                  c += a 等效于 c = c + a</span><br><span class="line">-=	      减法赋值运算符	                  c -= a 等效于 c = c - a</span><br><span class="line">*=	      乘法赋值运算符	                  c *= a 等效于 c = c * a</span><br><span class="line">/=	      除法赋值运算符	                  c /= a 等效于 c = c / a</span><br><span class="line">%=	      取模赋值运算符	                  c %= a 等效于 c = c % a</span><br><span class="line">**=	      幂赋值运算符	                  c **= a 等效于 c = c ** a</span><br><span class="line">//=	      取整除赋值运算符	              c //= a 等效于 c = c // a</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">21</span></span><br><span class="line">b = <span class="number">10</span></span><br><span class="line">c = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">c = a + b</span><br><span class="line">print(<span class="string">"c 的值为 %d"</span> % c)</span><br><span class="line"></span><br><span class="line">c += a</span><br><span class="line">print(<span class="string">"c 的值为 %d"</span> % c)</span><br><span class="line"></span><br><span class="line">c *= a</span><br><span class="line">print(<span class="string">"c 的值为 %d"</span> % c)</span><br><span class="line"></span><br><span class="line">c /= a</span><br><span class="line">print(<span class="string">"c 的值为 %d"</span> % c)</span><br><span class="line"></span><br><span class="line">c = <span class="number">2</span></span><br><span class="line">c %= a</span><br><span class="line">print(<span class="string">"c 的值为 %d"</span> % c)</span><br><span class="line"></span><br><span class="line">c **= a</span><br><span class="line">print(<span class="string">"c 的值为 %d"</span> % c)</span><br><span class="line"></span><br><span class="line">c //= a</span><br><span class="line">print(<span class="string">"c 的值为 %d"</span> % c)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test2.py
c 的值为 31
c 的值为 52
c 的值为 1092
c 的值为 52
c 的值为 2
c 的值为 2097152
c 的值为 99864

进程已结束，退出代码 0</code></pre><h2 id="python逻辑运算符"><a href="#python逻辑运算符" class="headerlink" title="python逻辑运算符"></a>python逻辑运算符</h2><p>Python语言支持逻辑运算符，以下假设变量 a 为 10, b为 20:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">and</span>	    x <span class="keyword">and</span> y	    布尔<span class="string">"与"</span> - 如果 x 为 <span class="literal">False</span>，x <span class="keyword">and</span> y 返回 <span class="literal">False</span>，否则它返回 y 的计算值。 	    (a <span class="keyword">and</span> b) 返回 <span class="number">20</span>。</span><br><span class="line"><span class="keyword">or</span>	    x <span class="keyword">or</span> y	    布尔<span class="string">"或"</span> - 如果 x 是非 <span class="number">0</span>，它返回 x 的值，否则它返回 y 的计算值。	            (a <span class="keyword">or</span> b) 返回 <span class="number">10</span>。</span><br><span class="line"><span class="keyword">not</span>	    <span class="keyword">not</span> x	    布尔<span class="string">"非"</span> - 如果 x 为 <span class="literal">True</span>，返回 <span class="literal">False</span> 。如果 x 为 <span class="literal">False</span>，它返回 <span class="literal">True</span>。	        <span class="keyword">not</span>(a <span class="keyword">and</span> b) 返回 <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">10</span></span><br><span class="line">b = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> a <span class="keyword">and</span> b:</span><br><span class="line">    print(<span class="string">"变量 a 和 b 都为true"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"变量 a 和 b 有一个不为 true"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> a <span class="keyword">or</span> b:</span><br><span class="line">    print(<span class="string">"变量 a 和 b 都为 true，或其中一个变量为true"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"变量 a 和 b 都不为true"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改变量 a 的值</span></span><br><span class="line">a = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> a <span class="keyword">and</span> b:</span><br><span class="line">    print(<span class="string">"变量 a 和 b 都为true"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"变量 a 和 b 有一个不为true"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> a <span class="keyword">or</span> b:</span><br><span class="line">    print(<span class="string">"变量 a 和 b 都为true，活其中一个变量为true"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"变量 a 和 b 都不为true"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span>(a <span class="keyword">and</span> b):</span><br><span class="line">    print(<span class="string">"变量 a 和 b 都为 false，或其中一个变量为 false"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"变量 a 和 b 都为 true"</span>)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test2.py
变量 a 和 b 都为true
变量 a 和 b 都为 true，或其中一个变量为true
变量 a 和 b 有一个不为true
变量 a 和 b 都为true，活其中一个变量为true
变量 a 和 b 都为 false，或其中一个变量为 false

进程已结束，退出代码 0</code></pre><h2 id="python成员运算符"><a href="#python成员运算符" class="headerlink" title="python成员运算符"></a>python成员运算符</h2><p>除了以上的一些运算符之外，Python还支持成员运算符，测试实例中包含了一系列的成员，包括字符串，列表或元组。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">运算符              	描述	                                                                  实例</span><br><span class="line"><span class="keyword">in</span>	        如果在指定的序列中找到值返回 <span class="literal">True</span>，否则返回 <span class="literal">False</span>。 	            x 在 y 序列中 , 如果 x 在 y 序列中返回 <span class="literal">True</span>。</span><br><span class="line"><span class="keyword">not</span> <span class="keyword">in</span>	    如果在指定的序列中没有找到值返回 <span class="literal">True</span>，否则返回 <span class="literal">False</span>。         	x 不在 y 序列中 , 如果 x 不在 y 序列中返回 <span class="literal">True</span>。</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">10</span></span><br><span class="line">b = <span class="number">20</span></span><br><span class="line">list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a <span class="keyword">in</span> list):</span><br><span class="line">    print(<span class="string">"变量 a  在指定的列表 list 中"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"变量 a  不在指定的列表 list 中"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (b <span class="keyword">not</span> <span class="keyword">in</span> list):</span><br><span class="line">    print(<span class="string">"变量 b 不在指定的列表 list 中"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"变量 b 在指定的列表 list 中"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改变量a 的值</span></span><br><span class="line">a = <span class="number">2</span></span><br><span class="line"><span class="keyword">if</span> (a <span class="keyword">in</span> list):</span><br><span class="line">    print(<span class="string">"变量 a  在指定的列表 list 中"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"变量 a  不在指定的列表 list 中"</span>)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test2.py
变量 a  不在指定的列表 list 中
变量 b 不在指定的列表 list 中
变量 a  在指定的列表 list 中

进程已结束，退出代码 0</code></pre><h2 id="python身份运算符"><a href="#python身份运算符" class="headerlink" title="python身份运算符"></a>python身份运算符</h2><p>身份运算符用于比较两个对象的存储单元</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">运算符	                      描述	                                        实例</span><br><span class="line"><span class="keyword">is</span>	        <span class="keyword">is</span> 是判断两个标识符是不是引用自一个对象	                        x <span class="keyword">is</span> y, 类似 id(x) == id(y) , 如果引用的是同一个对象则返回 <span class="literal">True</span>，否则返回 <span class="literal">False</span></span><br><span class="line"><span class="keyword">is</span> <span class="keyword">not</span>	    <span class="keyword">is</span> <span class="keyword">not</span>  是判断两个标识符是不是引用自不同对象                   	x <span class="keyword">is</span> <span class="keyword">not</span> y ， 类似 id(a) != id(b)。如果引用的不是同一个对象则返回结果 <span class="literal">True</span>，否则返回 <span class="literal">False</span>。</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">20</span></span><br><span class="line">b = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a <span class="keyword">is</span> b):</span><br><span class="line">    print(<span class="string">"a 和 b 有相同的标识"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"a 和 b 没有相同的标识"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a <span class="keyword">is</span> <span class="keyword">not</span> b):</span><br><span class="line">    print( <span class="string">"a 和 b 没有相同的标识"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"a 和 b 有相同的标识"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改变量 b 的值</span></span><br><span class="line">b = <span class="number">30</span></span><br><span class="line"><span class="keyword">if</span> (a <span class="keyword">is</span> b):</span><br><span class="line">    print(<span class="string">"a 和 b 有相同的标识"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"a 和 b 没有相同的标识"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a <span class="keyword">is</span> <span class="keyword">not</span> b):</span><br><span class="line">    print(<span class="string">"a 和 b 没有相同的标识"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"a 和 b 有相同的标识"</span>)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test2.py
a 和 b 有相同的标识
a 和 b 有相同的标识
a 和 b 没有相同的标识
a 和 b 没有相同的标识

进程已结束，退出代码 0</code></pre><h2 id="python运算符优先级"><a href="#python运算符优先级" class="headerlink" title="python运算符优先级"></a>python运算符优先级</h2><p>以下表格列出了从最高到最低优先级的所有运算符：</p>
<p>```python<br>运算符                                    描述<br>**                                   指数 (最高优先级)<br>~ + -                               按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@)</p>
<ul>
<li>/ % //                          乘，除，取模和取整除</li>
</ul>
<ul>
<li><ul>
<li>加法减法<blockquote>
<blockquote>
<p>&lt;&lt;                             右移，左移运算符<br>&amp;                                   位 ‘AND’<br>^ |                               位运算符<br>&lt;= &lt; &gt; &gt;=                           比较运算符<br>&lt;&gt; == !=                           等于运算符<br>= %= /= //= -= += <em>= *</em>=           赋值运算符<br>is is not                         身份运算符<br>in not in                         成员运算符<br>not and or                           逻辑运算符</p>
</blockquote>
</blockquote>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python基础之条件语句</title>
    <url>/2020/06/16/python-8/</url>
    <content><![CDATA[<h2 id="python条件语句"><a href="#python条件语句" class="headerlink" title="python条件语句"></a>python条件语句</h2><p>python条件语句是通过一条或多条语句的执行结果(True或False)来决定的代码块<br><br>Python 编程中 if 语句用于控制程序的执行，基本形式为：<br></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 判断条件:</span><br><span class="line">    执行语句...</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    执行语句...</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 例1：if 基本用法</span></span><br><span class="line"> </span><br><span class="line">flag = <span class="literal">False</span></span><br><span class="line">name = <span class="string">'luren'</span></span><br><span class="line"><span class="keyword">if</span> name == <span class="string">'python'</span>:         <span class="comment"># 判断变量是否为 python </span></span><br><span class="line">    flag = <span class="literal">True</span>              <span class="comment"># 条件成立时设置标志为真</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'welcome boss'</span>     <span class="comment"># 并输出欢迎信息</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">print</span> name               <span class="comment"># 条件不成立时输出变量名称</span></span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test.py
luren

进程已结束，退出代码 0</code></pre><p>if 语句的判断条件可以用&gt;（大于）、&lt;(小于)、==（等于）、&gt;=（大于等于）、&lt;=（小于等于）来表示其关系。当判断条件为多个值时，可以使用以下形式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 判断条件<span class="number">1</span>:</span><br><span class="line">    执行语句<span class="number">1</span>……</span><br><span class="line"><span class="keyword">elif</span> 判断条件<span class="number">2</span>:</span><br><span class="line">    执行语句<span class="number">2</span>……</span><br><span class="line"><span class="keyword">elif</span> 判断条件<span class="number">3</span>:</span><br><span class="line">    执行语句<span class="number">3</span>……</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    执行语句<span class="number">4</span>……</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 例2：elif用法</span></span><br><span class="line">num = <span class="number">5</span></span><br><span class="line"><span class="keyword">if</span> num == <span class="number">3</span>:  <span class="comment"># 判断num的值</span></span><br><span class="line">    print(<span class="string">"boss"</span>)</span><br><span class="line"><span class="keyword">elif</span> num == <span class="number">2</span>:</span><br><span class="line">    print(<span class="string">"user"</span>)</span><br><span class="line"><span class="keyword">elif</span> num == <span class="number">1</span>:</span><br><span class="line">    print(<span class="string">"worker"</span>)</span><br><span class="line"><span class="keyword">elif</span> num &lt; <span class="number">0</span>:  <span class="comment"># 值小于零时输出</span></span><br><span class="line">    print(<span class="string">"error"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"roadman"</span>) <span class="comment"># 条件均不成立时输出</span></span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test.py
roadman

进程已结束，退出代码 0</code></pre><h2 id="判断多个条件可以使用or或者and"><a href="#判断多个条件可以使用or或者and" class="headerlink" title="判断多个条件可以使用or或者and"></a>判断多个条件可以使用or或者and</h2><p>如果判断需要多个条件需同时判断时，可以使用 or （或），表示两个条件有一个成立时判断条件成功；使用 and （与）时，表示只有两个条件同时成立的情况下，判断条件才成功。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 例3：if语句多个条件</span></span><br><span class="line"></span><br><span class="line">num = <span class="number">9</span></span><br><span class="line"><span class="keyword">if</span> num &gt;= <span class="number">0</span> <span class="keyword">and</span> num &lt;= <span class="number">10</span>:       <span class="comment"># 判断值是否在0-10之间</span></span><br><span class="line">    print(<span class="string">"hello"</span>)</span><br><span class="line"></span><br><span class="line">num = <span class="number">10</span></span><br><span class="line"><span class="keyword">if</span> num &lt; <span class="number">0</span> <span class="keyword">or</span> num &gt; <span class="number">10</span>:     <span class="comment"># 判断值师傅小于0或大于10</span></span><br><span class="line">    print(<span class="string">"hello"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"undefined"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">num = <span class="number">8</span></span><br><span class="line"><span class="comment"># 判断值是否在0-5或者10-15之间</span></span><br><span class="line"><span class="keyword">if</span> (num &gt;= <span class="number">0</span> <span class="keyword">and</span> num &lt;= <span class="number">5</span>) <span class="keyword">or</span> (num &gt;= <span class="number">10</span> <span class="keyword">and</span> num &lt;= <span class="number">15</span>):</span><br><span class="line">    print(<span class="string">"hello"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"undefined"</span>)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test.py
hello
undefined
undefined

进程已结束，退出代码 0</code></pre><h2 id="判断练习"><a href="#判断练习" class="headerlink" title="判断练习"></a>判断练习</h2><p>练习1</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">username = input(<span class="string">'username: '</span>)</span><br><span class="line"><span class="comment"># getpass模块中，有一个方法也叫getpass</span></span><br><span class="line">password = input(<span class="string">'password: '</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> username == <span class="string">'bob'</span> <span class="keyword">and</span> password == <span class="string">'123456'</span>:</span><br><span class="line">    print(<span class="string">'Login successful'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'Login incorrect'</span>)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test2.py
username: aa
password: aa
Login incorrect

进程已结束，退出代码 0</code></pre><p>练习2</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">score = int(input(<span class="string">'分数: '</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> score &gt;= <span class="number">60</span> <span class="keyword">and</span> score &lt; <span class="number">70</span>:</span><br><span class="line">    print(<span class="string">'及格'</span>)</span><br><span class="line"><span class="keyword">elif</span> <span class="number">70</span> &lt;= score &lt; <span class="number">80</span>:</span><br><span class="line">    print(<span class="string">'良'</span>)</span><br><span class="line"><span class="keyword">elif</span> <span class="number">80</span> &lt;= score &lt; <span class="number">90</span>:</span><br><span class="line">    print(<span class="string">'好'</span>)</span><br><span class="line"><span class="keyword">elif</span> score &gt;= <span class="number">90</span>:</span><br><span class="line">    print(<span class="string">'优秀'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'你要努力了'</span>)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test2.py
分数: 100
优秀

进程已结束，退出代码 0</code></pre><p>练习3</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line">	</span><br><span class="line">	all_choices = [<span class="string">'石头'</span>, <span class="string">'剪刀'</span>, <span class="string">'布'</span>]</span><br><span class="line">	computer = random.choice(all_choices)</span><br><span class="line">	player = input(<span class="string">'请出拳: '</span>)</span><br><span class="line">	</span><br><span class="line">	<span class="comment"># print('Your choice:', player, "Computer's choice:", computer)</span></span><br><span class="line">	print(<span class="string">"Your choice: %s, Computer's choice: %s"</span> % (player, computer))</span><br><span class="line">	<span class="keyword">if</span> player == <span class="string">'石头'</span>:</span><br><span class="line">	    <span class="keyword">if</span> computer == <span class="string">'石头'</span>:</span><br><span class="line">	        print(<span class="string">'平局'</span>)</span><br><span class="line">	    <span class="keyword">elif</span> computer == <span class="string">'剪刀'</span>:</span><br><span class="line">	        print(<span class="string">'You WIN!!!'</span>)</span><br><span class="line">	    <span class="keyword">else</span>:</span><br><span class="line">	        print(<span class="string">'You LOSE!!!'</span>)</span><br><span class="line">	<span class="keyword">elif</span> player == <span class="string">'剪刀'</span>:</span><br><span class="line">	    <span class="keyword">if</span> computer == <span class="string">'石头'</span>:</span><br><span class="line">	        print(<span class="string">'You LOSE!!!'</span>)</span><br><span class="line">	    <span class="keyword">elif</span> computer == <span class="string">'剪刀'</span>:</span><br><span class="line">	        print(<span class="string">'平局'</span>)</span><br><span class="line">	    <span class="keyword">else</span>:</span><br><span class="line">	        print(<span class="string">'You WIN!!!'</span>)</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">	    <span class="keyword">if</span> computer == <span class="string">'石头'</span>:</span><br><span class="line">	        print(<span class="string">'You WIN!!!'</span>)</span><br><span class="line">	    <span class="keyword">elif</span> computer == <span class="string">'剪刀'</span>:</span><br><span class="line">	        print(<span class="string">'You LOSE!!!'</span>)</span><br><span class="line">	    <span class="keyword">else</span>:</span><br><span class="line">	        print(<span class="string">'平局'</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python基础之变量类型</title>
    <url>/2020/06/16/python-7-n/</url>
    <content><![CDATA[<h2 id="python变量类型"><a href="#python变量类型" class="headerlink" title="python变量类型"></a>python变量类型</h2><p>变量存储在内存中的值,这就意味着在创建变量时会在内存中开辟一个空间。基于变量的数据类型,解释器会分配给指定内存，并决定什么数据可以被存储在内存中,因此,变量可以指定不同的数据类型,这些变量可以存储整数、小数或字符</p>
<h2 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h2><p>python中变量赋值不需要类型声明<br><br>每个变量在内存中创建,都包括变量的标识,名称和数据这些信息<br><br>每个变量在使用前都必须赋值,变量赋值以后该变量才会被创建<br><br>等号(=)用来给变量赋值<br><br>等号(=)运算符左边是一个变量名,等号(=)运算符右边是存储在变量中的值,例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">counter = <span class="number">100</span>  <span class="comment"># 整数</span></span><br><span class="line">miles = <span class="number">1000.00</span>   <span class="comment"># 浮点数</span></span><br><span class="line">name = <span class="string">"john"</span>   <span class="comment"># 字符串</span></span><br><span class="line">print(counter)</span><br><span class="line">print(miles)</span><br><span class="line">print(name)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test.py
100
1000.0
john

进程已结束，退出代码 0</code></pre><h2 id="多个变量赋值"><a href="#多个变量赋值" class="headerlink" title="多个变量赋值"></a>多个变量赋值</h2><p>python允许你同时为多个变量赋值,例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = b = c = <span class="number">1</span></span><br><span class="line"><span class="comment"># 也可以为多个对象指定多个变量</span></span><br><span class="line">o, p , q = <span class="number">100</span>, <span class="number">200</span>, <span class="string">"name"</span></span><br><span class="line">print(a)</span><br><span class="line">print(b)</span><br><span class="line">print(c)</span><br><span class="line">print(o)</span><br><span class="line">print(p)</span><br><span class="line">print(q)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test.py
1
1
1
100
200
name

进程已结束，退出代码 0</code></pre><h2 id="标准数据类型"><a href="#标准数据类型" class="headerlink" title="标准数据类型"></a>标准数据类型</h2><p>在内存中存储的数据可以有多种类型<br><br>例如：一个年龄可以用数字来存储,他的名字可以用字符串来存储<br><br>python定义了一些标准类型,用于存储各种类型的数据<br><br>python有五个标准的数据类型：<br></p>
<pre><code>Numbers(数字)
String(字符串)
List(列表)
Tuple(元祖)
Dictionary(字典)</code></pre>]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python基础之函数</title>
    <url>/2020/06/14/python-7/</url>
    <content><![CDATA[<h2 id="python函数"><a href="#python函数" class="headerlink" title="python函数"></a>python函数</h2><p>函数是组织好的、可重复使用的、用来实现单一或相关联功能的代码段<br><br>函数能提高应用的模块性,和代码的重复利用率。python提供了许多内置函数比如print(),可以自己创建函数,成伟用户自定义函数<br></p>
<h2 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h2><p>你可以定义一个由自己想要功能的函数，以下是简单的规则：</p>
<pre><code>函数代码块以 def 关键词开头，后接函数标识符名称和圆括号()。
任何传入参数和自变量必须放在圆括号中间。圆括号之间可以用于定义参数。
函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。
函数内容以冒号起始，并且缩进。
return [表达式] 结束函数，选择性地返回一个值给调用方。不带表达式的return相当于返回 None。</code></pre><p>语法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">functionname</span><span class="params">( parameters )</span>:</span></span><br><span class="line">   <span class="string">"函数_文档字符串"</span></span><br><span class="line">   function_suite</span><br><span class="line">   <span class="keyword">return</span> [expression]</span><br></pre></td></tr></table></figure>
<p>实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printme</span><span class="params">(str)</span>:</span></span><br><span class="line">   <span class="string">"打印传入的字符串到标准显示设备上"</span></span><br><span class="line">   print(str)</span><br><span class="line">   <span class="keyword">return</span></span><br></pre></td></tr></table></figure>
<h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><p>定义一个函数只给了函数一个名称，指定了函数里包含的参数，和代码块结构。<br><br>这个函数的基本结构完成以后，你可以通过另一个函数调用执行，也可以直接从Python提示符执行。<br><br>如下实例调用了printme（）函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printme</span><span class="params">(str)</span>:</span></span><br><span class="line">    <span class="string">"打印任何传入的字符串"</span></span><br><span class="line">    print(str)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用函数</span></span><br><span class="line">printme(<span class="string">"我要调用用户自定义函数!"</span>)</span><br><span class="line">printme(<span class="string">"再次调用同一函数"</span>)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\python练习\venv\Scripts\python.exe E:/程序代码/hexo/test.py
我要调用用户自定义函数!
再次调用同一函数

进程已结束，退出代码 0</code></pre><h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>在 python 中，类型属于对象，变量是没有类型的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"> </span><br><span class="line">a=<span class="string">"Runoob"</span></span><br></pre></td></tr></table></figure>
<p>以上代码中，[1,2,3] 是 List 类型，”Runoob” 是 String 类型，而变量 a 是没有类型，她仅仅是一个对象的引用（一个指针），可以是 List 类型对象，也可以指向 String 类型对象。</p>
<h2 id="函数案例"><a href="#函数案例" class="headerlink" title="函数案例"></a>函数案例</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(zifu,cishu)</span>:</span></span><br><span class="line">    print(zifu * cishu)</span><br><span class="line">test(<span class="string">"-"</span>,<span class="number">20</span>)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\python练习\venv\Scripts\python.exe E:/程序代码/hexo/test.py
--------------------

进程已结束，退出代码 0</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义name_list字典</span></span><br><span class="line">name_list = [</span><br><span class="line">    &#123;<span class="string">"name"</span> : <span class="string">"小小"</span>,</span><br><span class="line">     <span class="string">"age"</span> : <span class="string">"20"</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"name"</span> : <span class="string">"yy"</span>,</span><br><span class="line">     <span class="string">"age"</span> : <span class="string">"20"</span>&#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义test 函数 循环字典 并且判断如果name == 小小  则修改name</span></span><br><span class="line"><span class="comment"># 修改name的值由find 函数传递</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> all <span class="keyword">in</span> name_list:</span><br><span class="line">        <span class="keyword">if</span> all[<span class="string">"name"</span>] == <span class="string">"小小"</span>:</span><br><span class="line">            all[<span class="string">"name"</span>] = find(all[<span class="string">"name"</span>],<span class="string">"请输入 ："</span>)</span><br><span class="line"></span><br><span class="line">    print(name_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义 find函数  被test函数条用  aa是传递的第一个参数默认为"小小"，nishi为用户输入的函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(aa,nishi)</span>:</span></span><br><span class="line">        re = input(nishi)</span><br><span class="line">        <span class="keyword">if</span> len(re) &gt; <span class="number">0</span>:   <span class="comment"># 判断输入的数据个数是否大于0  大于0 返还输入值给调用方 如果不大于0 则返还原参数给调用方</span></span><br><span class="line">            <span class="keyword">return</span>  re</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> aa</span><br><span class="line">test()</span><br></pre></td></tr></table></figure>
<p>运行结果(传输参数)：</p>
<pre><code>D:\python练习\venv\Scripts\python.exe E:/程序代码/hexo/test.py
请输入 ：鑫龙
[{&apos;name&apos;: &apos;鑫龙&apos;, &apos;age&apos;: &apos;20&apos;}, {&apos;name&apos;: &apos;yy&apos;, &apos;age&apos;: &apos;20&apos;}]

进程已结束，退出代码 0</code></pre><p>运行结果(直接回车)：</p>
<pre><code>D:\python练习\venv\Scripts\python.exe E:/程序代码/hexo/test.py
请输入 ：
[{&apos;name&apos;: &apos;小小&apos;, &apos;age&apos;: &apos;20&apos;}, {&apos;name&apos;: &apos;yy&apos;, &apos;age&apos;: &apos;20&apos;}]

进程已结束，退出代码 0</code></pre><h2 id="使用元祖接受调用函数之后返回的多个值"><a href="#使用元祖接受调用函数之后返回的多个值" class="headerlink" title="使用元祖接受调用函数之后返回的多个值"></a>使用元祖接受调用函数之后返回的多个值</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">measure</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 测量温度和湿度</span></span><br><span class="line">    print(<span class="string">"测量开始..."</span>)</span><br><span class="line">    temp = <span class="number">36</span></span><br><span class="line">    wetness = <span class="number">50</span></span><br><span class="line">    print(<span class="string">"测量结束..."</span>)</span><br><span class="line">    <span class="comment"># 元祖可以包含多个数据，因此可以使用元祖让函数一次返回多个值</span></span><br><span class="line">    <span class="comment"># 如果函数返还的类型是元祖,小括号可以省略</span></span><br><span class="line">    <span class="keyword">return</span> temp,wetness</span><br><span class="line"></span><br><span class="line">result = measure()</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\python练习\venv\Scripts\python.exe E:/程序代码/hexo/test.py
测量开始...
测量结束...
(36, 50)

进程已结束，退出代码 0</code></pre><p>如果需要单独处理温度或者湿度</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">measure</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 测量温度和湿度</span></span><br><span class="line">    print(<span class="string">"测量开始..."</span>)</span><br><span class="line">    temp = <span class="number">36</span></span><br><span class="line">    wetness = <span class="number">50</span></span><br><span class="line">    print(<span class="string">"测量结束..."</span>)</span><br><span class="line">    <span class="comment"># 元祖可以包含多个数据，因此可以使用元祖让函数一次返回多个值</span></span><br><span class="line">    <span class="comment"># 如果函数返还的类型是元祖,小括号可以省略</span></span><br><span class="line">    <span class="keyword">return</span> temp,wetness</span><br><span class="line"></span><br><span class="line">result = measure()</span><br><span class="line">print(<span class="string">"温度为 %s "</span> % result[<span class="number">0</span>])</span><br><span class="line">print(<span class="string">"湿度为 %s "</span> % result[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\python练习\venv\Scripts\python.exe E:/程序代码/hexo/test.py
测量开始...
测量结束...
温度为 36 
湿度为 50 

进程已结束，退出代码 0</code></pre><p>使用多个变量一次接受函数返回结果<br><br>如果函数返回的类型是元祖,希望单独处理元祖中的元素,可以使用多个变量一次接受函数的返回结果<br><br>注意：使用多个遍历接收结果时,变量的个数和元祖中的元素个数保持一致</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">measure</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 测量温度和湿度</span></span><br><span class="line">    print(<span class="string">"测量开始..."</span>)</span><br><span class="line">    temp = <span class="number">36</span></span><br><span class="line">    wetness = <span class="number">50</span></span><br><span class="line">    print(<span class="string">"测量结束..."</span>)</span><br><span class="line">    <span class="keyword">return</span>  temp,wetness</span><br><span class="line">gl_wen,gl_shi = measure()</span><br><span class="line">print(<span class="string">"温度为 %d"</span> % gl_wen)</span><br><span class="line">print(<span class="string">"湿度为 %d"</span> % gl_shi)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test2.py
测量开始...
测量结束...
温度为 36
湿度为 50

进程已结束，退出代码 0</code></pre><p>在函数内部,针对参数使用赋值语句,不会修改到外部的实参变量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo</span><span class="params">(num,num_list)</span>:</span></span><br><span class="line">    print(<span class="string">"函数内部的代码"</span>)</span><br><span class="line">    num = <span class="number">100</span></span><br><span class="line">    num_list= [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">    print(num)</span><br><span class="line">    print(num_list)</span><br><span class="line">    print(<span class="string">"函数执行完成"</span>)</span><br><span class="line"></span><br><span class="line">gl_num = <span class="number">99</span></span><br><span class="line">gl_list = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">demo(gl_num,gl_list)</span><br><span class="line">print(gl_num)</span><br><span class="line">print(gl_list)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test2.py
函数内部的代码
100
[1, 2, 3]
函数执行完成
99
[4, 5, 6]

进程已结束，退出代码 0</code></pre><p>使用方法修改数据内容,会影响到外部的数据 (此修改不是重新定义变量,而是直接修改append或者是remove)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo</span><span class="params">(num_list)</span>:</span></span><br><span class="line">    print(<span class="string">"函数内部的代码"</span>)</span><br><span class="line">    gl_list.append(<span class="string">"999"</span>)</span><br><span class="line">    <span class="comment"># 在列表中新增999</span></span><br><span class="line">    <span class="comment"># 使用方法修改了数据的内容,会影响到外部的数据</span></span><br><span class="line"></span><br><span class="line">    print(num_list)</span><br><span class="line">    print(<span class="string">"函数执行完成"</span>)</span><br><span class="line"></span><br><span class="line">gl_list = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">print(gl_list)</span><br><span class="line">demo(gl_list)</span><br><span class="line">print(gl_list)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test2.py
[4, 5, 6]
函数内部的代码
[4, 5, 6, &apos;999&apos;]
函数执行完成
[4, 5, 6, &apos;999&apos;]

进程已结束，退出代码 0</code></pre><p>列表变量使用 + 不会做相加在赋值的操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo</span><span class="params">(num,num_list)</span>:</span></span><br><span class="line">    print(<span class="string">"函数开始"</span>)</span><br><span class="line">    <span class="comment"># num += num  就是 num = num + num 数字先相加在赋值</span></span><br><span class="line">    num += num</span><br><span class="line"></span><br><span class="line">    <span class="comment"># num_list = num_list + num_list</span></span><br><span class="line">    <span class="comment"># 列表变量使用 + 不会做相加在赋值的操作</span></span><br><span class="line">    <span class="comment"># 本质是在调用列表的extend方法(增加另一个列表内容到此列表中  list.extend(list))</span></span><br><span class="line">    <span class="comment"># num_list += num_list 这样相当于调用extend方法会修改外部变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#  num_list = num_list + num_list  这样只是赋值  不会修改</span></span><br><span class="line">    num_list = num_list + num_list</span><br><span class="line">    print(num)</span><br><span class="line">    print(num_list)</span><br><span class="line">    print(<span class="string">"函数完成"</span>)</span><br><span class="line"></span><br><span class="line">gl_num = <span class="number">9</span></span><br><span class="line">gl_list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">demo(gl_num,gl_list)</span><br><span class="line">print(gl_num)</span><br><span class="line">print(gl_list)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test2.py
函数开始
18
[1, 2, 3, 1, 2, 3]
函数完成
9
[1, 2, 3]

进程已结束，退出代码 0</code></pre><h2 id="缺省参数"><a href="#缺省参数" class="headerlink" title="缺省参数"></a>缺省参数</h2><p>缺省参数,就是讲常见的值设为参数的缺省值,从而简化函数的调用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">gl_list = [<span class="number">6</span>,<span class="number">3</span>,<span class="number">9</span>]</span><br><span class="line"><span class="comment">#默认按照升序排序</span></span><br><span class="line">gl_list.sort()</span><br><span class="line">print(gl_list)</span><br><span class="line"><span class="comment">##如果需要降序排序，需要执行reverse参数</span></span><br><span class="line">gl_list.sort(reverse=<span class="literal">True</span>)</span><br><span class="line">print(gl_list)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test2.py
[3, 6, 9]
[9, 6, 3]

进程已结束，退出代码 0</code></pre><p>定义函数指定缺省参数,需要在末尾指定,不然后面无法写参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_info</span><span class="params">(name,gender=True)</span>:</span></span><br><span class="line">    <span class="comment"># :param name：同学姓名</span></span><br><span class="line">    <span class="comment"># :param gender：True 男生 False 女生</span></span><br><span class="line">    <span class="comment"># :return</span></span><br><span class="line">    gender_test = <span class="string">"男生"</span>  <span class="comment"># 默认参数为男生</span></span><br><span class="line">    print(gender)</span><br><span class="line">    <span class="comment"># if gender != True:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> gender:    <span class="comment"># 如果gender 不等于True  则赋值 gender_test = 女生</span></span><br><span class="line">        gender_test = <span class="string">"女生"</span></span><br><span class="line">    print(<span class="string">"%s 是 %s "</span> % (name,gender_test))</span><br><span class="line"></span><br><span class="line"><span class="comment">#提示：在指定缺省参数的默认值时，应该使用最常见的值作为默认值</span></span><br><span class="line">print_info(<span class="string">"小明"</span>)</span><br><span class="line">print_info(<span class="string">"小红"</span>,<span class="string">"女"</span>)</span><br><span class="line">print_info(<span class="string">"小明"</span>)</span><br><span class="line">print_info(<span class="string">"老王"</span>)</span><br><span class="line">print_info(<span class="string">"小美"</span>,<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test2.py
True
小明 是 男生 
女
小红 是 男生 
True
小明 是 男生 
True
老王 是 男生 
False
小美 是 女生 

进程已结束，退出代码 0</code></pre><h2 id="多值参数"><a href="#多值参数" class="headerlink" title="多值参数"></a>多值参数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo</span><span class="params">(num,*nums,**person)</span>:</span></span><br><span class="line">    print(num)</span><br><span class="line">    print(nums)</span><br><span class="line">    print(person)</span><br><span class="line"></span><br><span class="line">demo(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,name = <span class="string">"小明"</span>,age = <span class="number">18</span>)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test2.py
2
(3, 4, 5)
{&apos;name&apos;: &apos;小明&apos;, &apos;age&apos;: 18}

进程已结束，退出代码 0</code></pre><p>多值参数–数字累加<br><em>args:args中保存的是没有利用的所有多余参数，保存方式为元组，*</em>args即输入多余参数有变量名，就保存在**args中保存，保存方式为字典</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_numbers</span><span class="params">(*args)</span>:</span>    <span class="comment"># 传递一个元祖</span></span><br><span class="line">    num = <span class="number">0</span>      <span class="comment"># 定义 num = 0</span></span><br><span class="line">    print(args)</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span>  args:     <span class="comment"># 循环相加</span></span><br><span class="line">        num += n</span><br><span class="line">    <span class="keyword">return</span> num          <span class="comment"># 返还相加后的数</span></span><br><span class="line">result = sum_numbers(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)   <span class="comment"># 调用函数传递元祖 赋值给result</span></span><br><span class="line">print(result)    <span class="comment">#  打印结果</span></span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test2.py
(1, 2, 3, 4, 5)
15

进程已结束，退出代码 0</code></pre><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>递归就是函数内部调用自己的函数被称之为递归</p>
<pre><code>1、必须有一个明确的结束条件
2、每次进入更深一层递归时，问题规模(计算量)相比上次递归都应有所减少
3、递归效率不高，递归层次过多会导致栈溢出（在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。
    由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出
python默认的层次是1000(传递的数大于1000就会报错)    centos系统是根据limit决定</code></pre><p>递归还有两个名词用来概括递归实现的过程：</p>
<pre><code>递推：像上边递归实现所拆解，递归每一次都是基于上一次进行下一次的执行，这叫递推

回溯：则是在遇到终止条件，则从最后往回返一级一级的把值返回来，这叫回溯</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_numbers</span><span class="params">(num)</span>:</span></span><br><span class="line">    print(num)</span><br><span class="line">    <span class="comment">#递归的出口，当参数满足某个条件，不在执行参数</span></span><br><span class="line">    <span class="keyword">if</span> num == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment">#递归的特点就是自己调用自己</span></span><br><span class="line">    sum_numbers(num - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">sum_numbers(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test2.py
3
2
1

进程已结束，退出代码 0</code></pre><p>递归是一个编程技巧,在处理不确定的循环条件时是格外有用,例如：遍历整个文件目录的结构：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_numbers</span><span class="params">(num)</span>:</span></span><br><span class="line">    <span class="comment"># 1、定义出口</span></span><br><span class="line">    <span class="comment">#递归的出口，当参数满足某个条件，不在执行参数</span></span><br><span class="line">    <span class="keyword">if</span> num == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="comment"># 2、数字累加 num + (1...num -1)</span></span><br><span class="line">    <span class="comment"># 假设sum_numbers 能够正确的处理 1...num -1</span></span><br><span class="line">    temp = sum_numbers(num - <span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 两个数字相加</span></span><br><span class="line">    <span class="keyword">return</span> num + temp</span><br><span class="line"></span><br><span class="line">result = sum_numbers(<span class="number">100</span>)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test2.py
5050

进程已结束，退出代码 0</code></pre><p>示例1：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1！+2！+3！+4！+5！+...+n!</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="string">''' n表示要求的数的阶乘 '''</span></span><br><span class="line">    <span class="keyword">if</span> n==<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> n <span class="comment"># 阶乘为1的时候，结果为1,返回结果并退出</span></span><br><span class="line">    n = n*factorial(n<span class="number">-1</span>) <span class="comment"># n! = n*(n-1)!</span></span><br><span class="line">    <span class="keyword">return</span> n  <span class="comment"># 返回结果并退出</span></span><br><span class="line">res = factorial(<span class="number">5</span>) <span class="comment">#调用函数，并将返回的结果赋给res</span></span><br><span class="line">print(res) <span class="comment"># 打印结果</span></span><br></pre></td></tr></table></figure>
<p>示例2：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1，1，2，3，5，8，13，21，34，55，试判断数列第十五个数是哪个？</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fabonacci</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="string">''' n为斐波那契数列 '''</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">2</span>:</span><br><span class="line">        <span class="string">''' 数列前两个数都是1 '''</span></span><br><span class="line">        v = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> v <span class="comment"># 返回结果，并结束函数</span></span><br><span class="line">    v = fabonacci(n<span class="number">-1</span>)+fabonacci(n<span class="number">-2</span>) <span class="comment"># 由数据的规律可知，第三个数的结果都是前两个数之和，所以进行递归叠加</span></span><br><span class="line">    <span class="keyword">return</span> v  <span class="comment"># 返回结果，并结束函数</span></span><br><span class="line">print(fabonacci(<span class="number">15</span>)) <span class="comment"># 610    调用函数并打印结果</span></span><br></pre></td></tr></table></figure>
<p>示例3：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">13</span>,<span class="number">56</span>,<span class="number">123</span>,<span class="number">345</span>,<span class="number">1024</span>,<span class="number">3223</span>,<span class="number">6688</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dichotomy</span><span class="params">(min,max,d,n)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    min表示有序列表头部索引</span></span><br><span class="line"><span class="string">    max表示有序列表尾部索引</span></span><br><span class="line"><span class="string">    d表示有序列表</span></span><br><span class="line"><span class="string">    n表示需要寻找的元素</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    mid = (min+max)//<span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> mid==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'None'</span></span><br><span class="line">    <span class="keyword">elif</span> d[mid]&lt;n:</span><br><span class="line">        print(<span class="string">'向右侧找！'</span>)</span><br><span class="line">        <span class="keyword">return</span> dichotomy(mid,max,d,n)</span><br><span class="line">    <span class="keyword">elif</span> d[mid]&gt;n:</span><br><span class="line">        print(<span class="string">'向左侧找！'</span>)</span><br><span class="line">        <span class="keyword">return</span> dichotomy(min,mid,d,n)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'找到了%s'</span>%d[mid])</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">res = dichotomy(<span class="number">0</span>,len(data),data,<span class="number">222</span>)</span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python基础之变量</title>
    <url>/2020/06/14/python-6/</url>
    <content><![CDATA[<p>在函数中定义的变量,不能在其他地方引用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo</span><span class="params">()</span>:</span></span><br><span class="line">    num = <span class="number">21</span></span><br><span class="line">    print(num)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ ==  <span class="string">"__main__"</span>:</span><br><span class="line">    demo()</span><br><span class="line"><span class="comment"># 在函数外面引用报错</span></span><br><span class="line">print(num)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\python练习\venv\Scripts\python.exe E:/程序代码/hexo/test.py
21
Traceback (most recent call last):
  File &quot;E:/程序代码/hexo/test.py&quot;, line 9, in &lt;module&gt;
    print(num)
NameError: name &apos;num&apos; is not defined

进程已结束，退出代码 1</code></pre><h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num = <span class="number">100</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"demo1 ==&gt; %d"</span> % num)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo2</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"demo2 ==&gt; %d"</span> % num)</span><br><span class="line"></span><br><span class="line">demo1()</span><br><span class="line">demo2()</span><br><span class="line">print(<span class="string">"直接调用的输出为 %d"</span> % num)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\python练习\venv\Scripts\python.exe E:/程序代码/hexo/test.py
demo1 ==&gt; 100
demo2 ==&gt; 100
直接调用的输出为 100

进程已结束，退出代码 0</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num = <span class="number">100</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"demo1 ==&gt; %d"</span> % num)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo2</span><span class="params">()</span>:</span></span><br><span class="line">    num = <span class="number">20</span></span><br><span class="line">    print(<span class="string">"demo2 ==&gt; %d"</span> % num)</span><br><span class="line">demo1()</span><br><span class="line">demo2()</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\python练习\venv\Scripts\python.exe E:/程序代码/hexo/test.py
demo1 ==&gt; 100
demo2 ==&gt; 20

进程已结束，退出代码 0</code></pre>]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python基础之字典</title>
    <url>/2020/06/14/python-5/</url>
    <content><![CDATA[<h2 id="字典是一个无序的数据集合"><a href="#字典是一个无序的数据集合" class="headerlink" title="字典是一个无序的数据集合"></a>字典是一个无序的数据集合</h2><p>使用print函数打印字典的时候顺序会和定义的有差别</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">xinlong = &#123;<span class="string">"name"</span> : <span class="string">"xinlong"</span>,</span><br><span class="line">           <span class="string">"age"</span> : <span class="number">22</span>,</span><br><span class="line">           <span class="string">"xingbie"</span> : <span class="string">"True"</span>,</span><br><span class="line">           <span class="string">"height"</span> : <span class="string">"180"</span>,</span><br><span class="line">           <span class="string">"weight"</span> : <span class="string">"130"</span></span><br><span class="line">&#125;</span><br><span class="line">print(xinlong)</span><br><span class="line"><span class="comment"># 打印weight</span></span><br><span class="line">print(xinlong[<span class="string">"weight"</span>])</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\python练习\venv\Scripts\python.exe E:/程序代码/hexo/test.py
{&apos;name&apos;: &apos;xinlong&apos;, &apos;age&apos;: 22, &apos;xingbie&apos;: &apos;True&apos;, &apos;height&apos;: &apos;180&apos;, &apos;weight&apos;: &apos;130&apos;}
130

进程已结束，退出代码 0</code></pre><h2 id="字典的基本使用-增加"><a href="#字典的基本使用-增加" class="headerlink" title="字典的基本使用-增加"></a>字典的基本使用-增加</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">xinlong = &#123;<span class="string">"name"</span> : <span class="string">"xin"</span>&#125;</span><br><span class="line">print(xinlong)</span><br><span class="line">xinlong[<span class="string">"age"</span>]=<span class="string">"22"</span></span><br><span class="line">print(xinlong)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\python练习\venv\Scripts\python.exe E:/程序代码/hexo/test.py
{&apos;name&apos;: &apos;xin&apos;}
{&apos;name&apos;: &apos;xin&apos;, &apos;age&apos;: &apos;22&apos;}

进程已结束，退出代码 0</code></pre><h2 id="字典的基本使用-修改"><a href="#字典的基本使用-修改" class="headerlink" title="字典的基本使用-修改"></a>字典的基本使用-修改</h2><p>如果key不存在 就会增加一个键值对  如果存在就会修改已存在的键值对</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">xinlong = &#123;<span class="string">"name"</span> : <span class="string">"xin"</span>&#125;</span><br><span class="line">print(xinlong)</span><br><span class="line">xinlong[<span class="string">"name"</span>]=<span class="string">"xiaoxiao"</span></span><br><span class="line">print(xinlong)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\python练习\venv\Scripts\python.exe E:/程序代码/hexo/test.py
{&apos;name&apos;: &apos;xin&apos;}
{&apos;name&apos;: &apos;xiaoxiao&apos;}

进程已结束，退出代码 0</code></pre><h2 id="字典的基本使用-删除"><a href="#字典的基本使用-删除" class="headerlink" title="字典的基本使用-删除"></a>字典的基本使用-删除</h2><p>再删除指定键值对的时候如果不存在则报错</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">xinlong = &#123;<span class="string">"name"</span> : <span class="string">"xin"</span>,</span><br><span class="line">           <span class="string">"age"</span> : <span class="number">22</span>&#125;</span><br><span class="line">print(xinlong)</span><br><span class="line">xinlong.pop(<span class="string">"age"</span>)</span><br><span class="line">print(xinlong)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\python练习\venv\Scripts\python.exe E:/程序代码/hexo/test.py
{&apos;name&apos;: &apos;xin&apos;, &apos;age&apos;: 22}
{&apos;name&apos;: &apos;xin&apos;}

进程已结束，退出代码 0</code></pre><h2 id="统计键值对数量"><a href="#统计键值对数量" class="headerlink" title="统计键值对数量"></a>统计键值对数量</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">xinlong = &#123;<span class="string">"name"</span> : <span class="string">"xin"</span>,</span><br><span class="line">           <span class="string">"age"</span> : <span class="number">22</span>&#125;</span><br><span class="line">lens = len(xinlong)</span><br><span class="line">print(lens)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\python练习\venv\Scripts\python.exe E:/程序代码/hexo/test.py
2

进程已结束，退出代码 0</code></pre><h2 id="合并字典"><a href="#合并字典" class="headerlink" title="合并字典"></a>合并字典</h2><p>如果被合并的字典中包含已存在的键值对,会覆盖原有的键值对</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">xinlong = &#123;<span class="string">"name"</span> : <span class="string">"xin"</span>,</span><br><span class="line">           <span class="string">"age"</span> : <span class="number">22</span>&#125;</span><br><span class="line">mihua = &#123;<span class="string">"server"</span> : <span class="number">1</span>,</span><br><span class="line">         <span class="string">"name"</span> : <span class="string">"kingdom"</span>,</span><br><span class="line">         <span class="string">"start"</span> : <span class="string">"num"</span>&#125;</span><br><span class="line">xinlong.update(mihua)</span><br><span class="line">print(xinlong)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\python练习\venv\Scripts\python.exe E:/程序代码/hexo/test.py
{&apos;name&apos;: &apos;kingdom&apos;, &apos;age&apos;: 22, &apos;server&apos;: 1, &apos;start&apos;: &apos;num&apos;}

进程已结束，退出代码 0</code></pre><h2 id="清空字典"><a href="#清空字典" class="headerlink" title="清空字典"></a>清空字典</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mihua = &#123;<span class="string">"server"</span> : <span class="number">1</span>,</span><br><span class="line">         <span class="string">"name"</span> : <span class="string">"kingdom"</span>,</span><br><span class="line">         <span class="string">"start"</span> : <span class="string">"num"</span>&#125;</span><br><span class="line"></span><br><span class="line">mihua.clear()</span><br><span class="line">print(mihua)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\python练习\venv\Scripts\python.exe E:/程序代码/hexo/test.py
{}

进程已结束，退出代码 0</code></pre><h2 id="字典的循环遍历"><a href="#字典的循环遍历" class="headerlink" title="字典的循环遍历"></a>字典的循环遍历</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mihua = &#123;<span class="string">"server"</span> : <span class="number">1</span>,</span><br><span class="line">         <span class="string">"name"</span> : <span class="string">"kingdom"</span>,</span><br><span class="line">         <span class="string">"start"</span> : <span class="string">"num"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span>  mihua:</span><br><span class="line">    print(<span class="string">"%s - %s"</span> % (k,mihua[k]))</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\python练习\venv\Scripts\python.exe E:/程序代码/hexo/test.py
server - 1
name - kingdom
start - num

进程已结束，退出代码 0</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list = [</span><br><span class="line">    &#123;<span class="string">"name"</span> : <span class="string">"xin"</span>,</span><br><span class="line">           <span class="string">"age"</span> : <span class="number">22</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;<span class="string">"name"</span> : <span class="string">"long"</span>,</span><br><span class="line">           <span class="string">"age"</span> : <span class="number">21</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>  list_info  <span class="keyword">in</span>  list:</span><br><span class="line">    print(list_info)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\python练习\venv\Scripts\python.exe E:/程序代码/hexo/test.py
{&apos;name&apos;: &apos;xin&apos;, &apos;age&apos;: 22}
{&apos;name&apos;: &apos;long&apos;, &apos;age&apos;: 21}

进程已结束，退出代码 0</code></pre>]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础之元祖</title>
    <url>/2020/06/14/python-4/</url>
    <content><![CDATA[<h2 id="定义元祖"><a href="#定义元祖" class="headerlink" title="定义元祖"></a>定义元祖</h2><p>快速查看元祖提供哪些操作   定义一个元祖   然后元祖变量名+.  例如  info = ()        info.  然后TABLE补全</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">info_tuple = (<span class="string">"zhangsan"</span>,<span class="number">18</span>,<span class="number">180</span>)</span><br><span class="line"><span class="comment">##打印元祖中的第二个数据</span></span><br><span class="line">print(info_tuple[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\python练习\venv\Scripts\python.exe E:/程序代码/hexo/test.py
18

进程已结束，退出代码 0</code></pre><h2 id="定义一个空元祖"><a href="#定义一个空元祖" class="headerlink" title="定义一个空元祖"></a>定义一个空元祖</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sing_tuple = ()</span><br></pre></td></tr></table></figure>

<p>定义一个只有一个元素的元祖(元素后面需要加”,” 不然会识别为int型)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i_tuple = (<span class="number">12</span>)</span><br><span class="line">set_tuple = (<span class="number">12</span>,)</span><br><span class="line">itype = type(i_tuple)</span><br><span class="line">set_type = type(set_tuple)</span><br><span class="line">print(<span class="string">"此时元祖i_tuple 的类型是 %s"</span> % itype)</span><br><span class="line">print(<span class="string">"此时元祖set_tuple 的类型是 %s"</span> % set_type)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\python练习\venv\Scripts\python.exe E:/程序代码/hexo/test.py
此时元祖i_tuple 的类型是 &lt;class &apos;int&apos;&gt;
此时元祖set_tuple 的类型是 &lt;class &apos;tuple&apos;&gt;

进程已结束，退出代码 0</code></pre><h2 id="元祖的基本操作"><a href="#元祖的基本操作" class="headerlink" title="元祖的基本操作"></a>元祖的基本操作</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">table = (<span class="string">"zhang"</span>,<span class="string">"liang"</span>,<span class="number">180</span>,<span class="number">18</span>,<span class="string">"liang"</span>)</span><br><span class="line"><span class="comment"># 取值</span></span><br><span class="line">print(table[<span class="number">1</span>])</span><br><span class="line"><span class="comment"># 已知数据内容取出数据在元祖中的索引(从前往后取)</span></span><br><span class="line">print(table.index(<span class="string">"liang"</span>))</span><br><span class="line"><span class="comment"># 统计数据个数</span></span><br><span class="line">print(table.count(<span class="string">"liang"</span>))</span><br><span class="line"><span class="comment"># 统计元祖中包含元素的个数</span></span><br><span class="line">lens = len(table)</span><br><span class="line">print(<span class="string">"当前元祖包含 %d "</span> % lens)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\python练习\venv\Scripts\python.exe E:/程序代码/hexo/test.py
liang
1
2
当前元祖包含 5 

进程已结束，退出代码 0</code></pre><h2 id="格式化字符串后面的”-”本身就是元祖"><a href="#格式化字符串后面的”-”本身就是元祖" class="headerlink" title="格式化字符串后面的”()”本身就是元祖"></a>格式化字符串后面的”()”本身就是元祖</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str = (<span class="string">"bad"</span>,<span class="number">21</span>,<span class="number">1.85</span>)</span><br><span class="line">print(<span class="string">"%s 的年龄是 %d 身高是%.2f"</span> % (<span class="string">"bad"</span>,<span class="number">21</span>,<span class="number">1.85</span>))</span><br><span class="line">print(<span class="string">"%s 的年龄是 %d 身高是%.2f"</span> % str)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\python练习\venv\Scripts\python.exe E:/程序代码/hexo/test.py
bad 的年龄是 21 身高是1.85
bad 的年龄是 21 身高是1.85

进程已结束，退出代码 0</code></pre><h2 id="列表和元祖之前的转换"><a href="#列表和元祖之前的转换" class="headerlink" title="列表和元祖之前的转换"></a>列表和元祖之前的转换</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name_list = [<span class="string">"xinlong"</span>,<span class="string">"long"</span>,<span class="string">"hello"</span>]</span><br><span class="line"><span class="comment">#当前name_list是个列表如果不希望别人修改列表可以转换成元祖，使用tuple这个函数</span></span><br><span class="line">print(type(name_list))</span><br><span class="line"><span class="comment"># name_list 列表转换为元祖后，需要重新定义一个变量名</span></span><br><span class="line">modiy = tuple(name_list)</span><br><span class="line"><span class="comment"># 打印转换后的类型</span></span><br><span class="line">print(type(modiy))</span><br><span class="line">print(modiy)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\python练习\venv\Scripts\python.exe E:/程序代码/hexo/test.py
&lt;class &apos;list&apos;&gt;
&lt;class &apos;tuple&apos;&gt;
(&apos;xinlong&apos;, &apos;long&apos;, &apos;hello&apos;)

进程已结束，退出代码 0</code></pre><h2 id="修改元祖数据的内容"><a href="#修改元祖数据的内容" class="headerlink" title="修改元祖数据的内容"></a>修改元祖数据的内容</h2><p>如果想要修改元组数据的内容 使用list函数转为列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name_list = (<span class="string">"xinlong"</span>,<span class="string">"long"</span>,<span class="string">"hello"</span>)</span><br><span class="line">print(type(name_list))</span><br><span class="line"><span class="comment"># 元祖转换为列表</span></span><br><span class="line">remod = list(name_list)</span><br><span class="line">print(type(remod))</span><br><span class="line"><span class="comment"># 修改列表内容</span></span><br><span class="line">remod.append(<span class="string">"test"</span>)</span><br><span class="line">print(remod)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\python练习\venv\Scripts\python.exe E:/程序代码/hexo/test.py
&lt;class &apos;tuple&apos;&gt;
&lt;class &apos;list&apos;&gt;
[&apos;xinlong&apos;, &apos;long&apos;, &apos;hello&apos;, &apos;test&apos;]

进程已结束，退出代码 0</code></pre><h2 id="互换变量值"><a href="#互换变量值" class="headerlink" title="互换变量值"></a>互换变量值</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">6</span></span><br><span class="line">b = <span class="number">100</span></span><br><span class="line"><span class="comment"># 解法1：使用变量</span></span><br><span class="line">c = a</span><br><span class="line">a = b</span><br><span class="line">b = c</span><br><span class="line"><span class="comment"># 解法2：不使用其他变量</span></span><br><span class="line">a = a + b</span><br><span class="line">b = a - b</span><br><span class="line">a = a - b</span><br><span class="line"><span class="comment"># 解法3：python专有写法  a 结束b的元素  b接受a的元素</span></span><br><span class="line">a,b = (b,a)</span><br><span class="line"><span class="comment"># 提示等号右边是一个元祖，只是把小括号省略了</span></span><br><span class="line"><span class="comment"># a,b = b,a</span></span><br><span class="line">print(a)</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\python练习\venv\Scripts\python.exe E:/程序代码/hexo/test.py
100
6

进程已结束，退出代码 0</code></pre>]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>docker安装部署以及Dockerfile</title>
    <url>/2020/06/11/install-docker/</url>
    <content><![CDATA[<h2 id="docker安装准备"><a href="#docker安装准备" class="headerlink" title="docker安装准备"></a>docker安装准备</h2><p>关闭防火墙和selinux<br><br>centos6<br></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo  service  iptables  stop</span><br><span class="line">sudo  service  ip6tables  stop</span><br></pre></td></tr></table></figure>
<p>centos7</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo  systemctl stop  firewalld</span><br></pre></td></tr></table></figure>
<p>关闭开启自启动</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo  chkconfig  iptables  off   </span><br><span class="line">sudo  chkconfig  ip6tables  off</span><br></pre></td></tr></table></figure>
<p>临时关闭selinux</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo  setenforce 0</span><br></pre></td></tr></table></figure>
<p>永久关闭selinux</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo  vim  /etc/selinux/config</span><br><span class="line">        SELINUX=disabled</span><br></pre></td></tr></table></figure>
<p>重启生效</p>
<p>Docker 要求 CentOS 系统的内核版本高于 3.10，查看本页面的前提条件来验证你的CentOS 版本是否支持 Docker</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[sgsm@localhost ~]$ uname -r</span><br><span class="line">3.10.0-514.21.2.el7.x86_64</span><br><span class="line">[sgsm@localhost ~]$</span><br></pre></td></tr></table></figure>
<p>如果版本较低需要升级内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 更新yum库</span></span><br><span class="line">yum update   </span><br><span class="line"><span class="comment"># 升级内核版本（包含aufs）</span></span><br><span class="line"><span class="built_in">cd</span> /etc/yum.repos.d</span><br><span class="line">wget http://www.hop5.in/yum/el6/hop5.repo</span><br><span class="line">yum install kernel-ml-aufs kernel-ml-aufs-devel -y</span><br></pre></td></tr></table></figure>
<p>更新后需要修改配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo  vi /etc/grub.conf</span><br><span class="line">    <span class="comment"># 把默认的引导文件设置为0。因为升级内核之后，新的内核在第一个（0）位置</span></span><br><span class="line">    default=0</span><br></pre></td></tr></table></figure>
<p>最后重启系统,再次查看就是3.10版本了</p>
<h2 id="docker安装部署"><a href="#docker安装部署" class="headerlink" title="docker安装部署"></a>docker安装部署</h2><p>因为epel源中就有docker所以直接用epel源安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo  yum install  epel-release   -y</span><br><span class="line">sudo  yum install  docker-io   -y</span><br><span class="line">sudo  yum install docker-ce -y</span><br></pre></td></tr></table></figure>
<p>启动docker</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo  systemctl start  docker</span><br></pre></td></tr></table></figure>

<h2 id="docker-镜像"><a href="#docker-镜像" class="headerlink" title="docker 镜像"></a>docker 镜像</h2><p>搜寻镜像 $docker search 关键字</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[sgsm@localhost ~]$ sudo docker  search  centos7.2  </span><br><span class="line">INDEX       NAME                                             DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED</span><br><span class="line">docker.io   docker.io/kecikeci/centos7.2-tools               centos7.2+阿里云yum源+ssh密码登录+常用软件 基于官方centos7...   3                    </span><br><span class="line">docker.io   docker.io/13652604711/centos7.2-ssh                                                              2                    </span><br><span class="line">docker.io   docker.io/hasonl/centos7.2                       Centos7.2   System                              1                    </span><br><span class="line">docker.io   docker.io/sssllc/centos7.2-jdk1.8                centos-release-7-2.1511.el7.centos.2.10.x8...   1                    </span><br><span class="line">docker.io   docker.io/yasanbee/centos7.2-systemd             CentOS 7.2 Base Image Dockerfile with syst...   1                    [OK]</span><br><span class="line">docker.io   docker.io/10sr/centos7.2-python2.7               centos7.2-python2.7                             0                    [OK]</span><br><span class="line">docker.io   docker.io/692383247/centos7.2                    centos7.2                                       0                    </span><br><span class="line">docker.io   docker.io/92docker/centos7.2                                                                     0                    </span><br><span class="line">docker.io   docker.io/ailyfeng/centos7.2.1511                centos7.2.1511基础配置                              0                    </span><br><span class="line">docker.io   docker.io/chaoduoli/centos7.2-ssh                账号和密码都为root                                     0                    </span><br><span class="line">docker.io   docker.io/coxy/centos7.2-vagrant                 CentOS 7.2 <span class="keyword">for</span> Vagrant use. Contains SSH, ...   0                    </span><br><span class="line">docker.io   docker.io/daisuke310vvv/centos7.2-java1.7.0                                                      0                    </span><br><span class="line">docker.io   docker.io/dock2box/centos7.2.1511                                                                0                    </span><br><span class="line">docker.io   docker.io/ekzm/centos7.2.1511                                                                    0                    </span><br><span class="line">docker.io   docker.io/elain/centos7.2                        centos7.2 基础镜像                                  0                    </span><br><span class="line">docker.io   docker.io/gengyanping/centos7.2                                                                  0                    </span><br><span class="line">docker.io   docker.io/hizhangsir/centos7.2-jdk1.8            base                                            0                    </span><br><span class="line">docker.io   docker.io/jiezhiz/centos7.2                      base image from centos7.2                       0                    </span><br><span class="line">docker.io   docker.io/pangyu/centos7.2_java                                                                  0                    </span><br><span class="line">docker.io   docker.io/plsicloud/centos7.2-iperf3                                                             0                    </span><br><span class="line">docker.io   docker.io/plsicloud/centos7.2-openmpi2.0.1                                                       0                    </span><br><span class="line">docker.io   docker.io/plsicloud/centos7.2-openmpi2.0.2-hpl                                                   0                    </span><br><span class="line">docker.io   docker.io/qxp2181/centos7.2_mono_jexus           centos7.2_mono_jexus                            0                    </span><br><span class="line">docker.io   docker.io/sibylai/centos7.2-ssh                                                                  0                    </span><br><span class="line">docker.io   docker.io/wodrow/centos7.2                                                                       0                    </span><br><span class="line">[sgsm@localhost ~]$</span><br></pre></td></tr></table></figure>
<p>下载镜像 $ docker pull 镜像名</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[sgsm@localhost ~]$ sudo docker  pull alpine         </span><br><span class="line">Using default tag: latest</span><br><span class="line">Trying to pull repository docker.io/library/alpine ... </span><br><span class="line">latest: Pulling from docker.io/library/alpine</span><br><span class="line">df20fa9351a1: Pull complete </span><br><span class="line">Digest: sha256:185518070891758909c9f839cf4ca393ee977ac378609f700f60a771a2dfe321</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> docker.io/alpine:latest</span><br><span class="line">[sgsm@localhost ~]$</span><br></pre></td></tr></table></figure>
<p>dokcer run hello-world<br><br>pull镜像测试  如果pull失败   需要更改镜像源<br></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo  vim /etc/docker/daemon.json</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="string">"registry-mirrors"</span>: [<span class="string">"https://alzgoonw.mirror.aliyuncs.com"</span>]</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>重启docker</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl restart  docker</span><br></pre></td></tr></table></figure>
<p>默认docker pull的镜像都是最新版本   指定版本需要 docker pull centos:centos7    更精确为 docker pull centos:centos7.2.1511<br><br>例如：<br></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo  docker pull centos:centos7.2.1511</span><br></pre></td></tr></table></figure>
<p>查看docker 镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY                                                           TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">web                                                                  v1.1                84f2139ad784        6 weeks ago         285 MB</span><br><span class="line">docker.io/alpine                                                     latest              f70734b6a266        2 months ago        5.61 MB</span><br><span class="line">docker.io/nginx                                                      latest              602e111c06b6        2 months ago        127 MB</span><br><span class="line">docker.io/centos                                                     latest              470671670cac        5 months ago        237 MB</span><br><span class="line">docker.io/centos                                                     centos7             5e35e350aded        7 months ago        203 MB</span><br><span class="line">docker.io/centos                                                     centos7.2.1511      9aec5c5fe4ba        15 months ago       195 MB</span><br><span class="line">k8s.gcr.io/kube-apiserver                                            v1.13.0             f1ff9b7e3d6e        18 months ago       181 MB</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/kube-apiserver   v1.13.0             f1ff9b7e3d6e        18 months ago       181 MB</span><br><span class="line">[root@localhost ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>参数解释：</p>
<pre><code>REPOSITORY：仓库名称
TAG：标签名，一个仓库可以有若干个标签对应不同的镜像，默认都是latest
IMAGE ID：镜像ID
CREATED：创建时间，注意不是本地的pull时间
SIZE：镜像大小</code></pre><p>删除镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在删除docker镜像前需先删除所有使用此镜像的所有容器才可删除镜像</span></span><br><span class="line">docker rmi &lt;image id&gt;</span><br></pre></td></tr></table></figure>

<h2 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h2><p>创建容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -it  --privileged=<span class="literal">true</span>  -v /bak:/soft  --name web   -d  centos:centos7.2.1511 /usr/sbin/init </span><br><span class="line">    <span class="comment"># 选项</span></span><br><span class="line">     --privileged=<span class="literal">true</span>  赋予root权限,此root不是系统用户root,而是docker容器内的root权限, 不指定在容器内无法启动服务</span><br><span class="line">     -v /bak:/soft    挂载   -v 宿主机目录:容器内目录   </span><br><span class="line">     --name    容器名字</span><br><span class="line">     -d   后台运行</span><br><span class="line">     centos:centos7.2.1511    指定创建容器所使用的的镜像</span><br><span class="line">     /usr/sbin/init        不指定在容器内无法启动服务 报错：Fai led to get D-BuS connect ion: operation not permitted</span><br></pre></td></tr></table></figure>
<p>查看所有容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker ps -a</span></span><br><span class="line">CONTAINER ID        IMAGE                   COMMAND             CREATED             STATUS                                PORTS                            NAMES</span><br><span class="line">56da5506c5a1        centos:centos7.2.1511   <span class="string">"/usr/sbin/init"</span>    6 weeks ago         Exited (137) Less than a second ago                                    web</span><br></pre></td></tr></table></figure>
<p>查看正在运行的容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker ps</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                            NAMES</span><br><span class="line">ccc0f0ca5334        84f2139ad784        <span class="string">"/usr/sbin/init"</span>    6 weeks ago         Up 6 weeks          9001/tcp, 0.0.0.0:9090-&gt;80/tcp   <span class="built_in">test</span></span><br><span class="line">[root@localhost ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>选项</p>
<pre><code>-a：查看所有容器，含停止运行的
-l：查看刚启动的容器
-q：只显示容器ID
-s:显示容器大小
-n=4: 列出最近创建的4个容器</code></pre><p>查看在容器里做过的操作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker  diff  容器id</span><br></pre></td></tr></table></figure>
<p>查看容器运行信息docker stats<br>   <br> docker stats 可以查看到运行状态容器的CPU，内存及网络使用率<br></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker stats  ccc0f0ca5334</span></span><br><span class="line">CONTAINER           CPU %               MEM USAGE / LIMIT      MEM %               NET I/O             BLOCK I/O           PIDS</span><br><span class="line">ccc0f0ca5334        0.01%               1000 KiB / 7.605 GiB   0.01%               7.3 kB / 4.76 kB    531 MB / 179 MB     12</span><br><span class="line">CONTAINER           CPU %               MEM USAGE / LIMIT      MEM %               NET I/O             BLOCK I/O           PIDS</span><br><span class="line">ccc0f0ca5334        0.01%               1000 KiB / 7.605 GiB   0.01%               7.3 kB / 4.76 kB    531 MB / 179 MB     12</span><br><span class="line">CONTAINER           CPU %               MEM USAGE / LIMIT      MEM %               NET I/O             BLOCK I/O           PIDS</span><br><span class="line">ccc0f0ca5334        0.08%               1000 KiB / 7.605 GiB   0.01%               7.3 kB / 4.76 kB    531 MB / 179 MB     12</span><br><span class="line">CONTAINER           CPU %               MEM USAGE / LIMIT      MEM %               NET I/O             BLOCK I/O           PIDS</span><br><span class="line">ccc0f0ca5334        0.08%               1000 KiB / 7.605 GiB   0.01%               7.3 kB / 4.76 kB    531 MB / 179 MB     12</span><br><span class="line">CONTAINER           CPU %               MEM USAGE / LIMIT      MEM %               NET I/O             BLOCK I/O           PIDS</span><br><span class="line">ccc0f0ca5334        0.00%               1000 KiB / 7.605 GiB   0.01%               7.3 kB / 4.76 kB    531 MB / 179 MB     12</span><br><span class="line">CONTAINER           CPU %               MEM USAGE / LIMIT      MEM %               NET I/O             BLOCK I/O           PIDS</span><br><span class="line">ccc0f0ca5334        0.00%               1000 KiB / 7.605 GiB   0.01%               7.3 kB / 4.76 kB    531 MB / 179 MB     12</span><br><span class="line">^C</span><br><span class="line">[root@localhost ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>查看 Docker 容器或镜像的一些内部信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker inspect  ccc0f0ca5334</span><br></pre></td></tr></table></figure>
<p>进入容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it  web  /bin/bash</span><br></pre></td></tr></table></figure>
<p>退出容器不结束容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">使用 ctrl+p + ctrl+q    或者   ctrl+a  + ctrl+d</span><br></pre></td></tr></table></figure>
<p>容器的删除</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除已停止中的容器：</span></span><br><span class="line">docker rm  容器id</span><br><span class="line"><span class="comment"># 删除正常运行的容器：</span></span><br><span class="line">docker rm -f  容器id</span><br></pre></td></tr></table></figure>
<p>关闭容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker  stop  容器id或者容器name</span><br></pre></td></tr></table></figure>

<h2 id="容器内操作"><a href="#容器内操作" class="headerlink" title="容器内操作"></a>容器内操作</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install epel-release -y</span><br><span class="line">yum install net-tools   httpd  vim  elinks    passwd openssl openssh-server     openssl-client  -y</span><br><span class="line"> /usr/sbin/sshd -D &amp;  <span class="comment"># 启动sshd  方便之后的ansible</span></span><br><span class="line">然后配置yum源为宿主机的ip     <span class="comment"># 宿主机上需要开服httpd    并且在访问站点目录解压sgsm.zip包</span></span><br><span class="line"></span><br><span class="line">配置好yum源安装nodejs-4.4-*</span><br><span class="line"> yum install  subversion    nodejs-4.4*  -y   <span class="comment"># 因为测试环境需要svn检出代码 所以需要安装subversion</span></span><br><span class="line"></span><br><span class="line"> svn  co  代码路径</span><br><span class="line"></span><br><span class="line"><span class="comment">##  如果有报错 字符集有问题需要调整  </span></span><br><span class="line">  <span class="built_in">export</span> LC_CTYPE=<span class="string">"zh_CN.UTF-8"</span></span><br><span class="line">  <span class="built_in">export</span> LANG=<span class="string">"zh_CN.UTF-8"</span></span><br><span class="line">  <span class="built_in">export</span> LC_CTYPE=<span class="string">"zh_CN.GB2312"</span></span><br><span class="line">  然后在svn co</span><br><span class="line">  如果还不行    使用下面的方法</span><br><span class="line">	vim   /etc/profile </span><br><span class="line">		在最后插入</span><br><span class="line">			<span class="built_in">export</span> LC_ALL=en_US.UTF-8</span><br><span class="line">			<span class="built_in">export</span> LANG=en_US.UTF-8</span><br><span class="line">			<span class="built_in">export</span> LANGUAGE=en_US.UTF-8</span><br><span class="line">		保存退出</span><br><span class="line">	<span class="built_in">source</span>  /etc/profile    <span class="comment">#  source 立即生效</span></span><br></pre></td></tr></table></figure>






<h2 id="容器启动后端口映射"><a href="#容器启动后端口映射" class="headerlink" title="容器启动后端口映射"></a>容器启动后端口映射</h2><p>首先停止容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker stop <span class="built_in">test</span></span><br></pre></td></tr></table></figure>
<p>然后停止服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl stop docker</span><br><span class="line">```	</span><br><span class="line"></span><br><span class="line">修改配置文件&amp;emsp;&amp;emsp; ( [hash_of_the_container] 为容器id)</span><br></pre></td></tr></table></figure>
<p>vim /var/lib/docker/containers/[hash_of_the_container]/hostconfig.json<br>在 hostconfig.json 里有 “PortBindings”:{} 这个配置项，可以改成 “PortBindings”:{“9001/tcp”:[{“HostIp”:””,”HostPort”:”900”}]}<br>                                                                                前者为容器端口，后者为宿主机端口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">修改config.v2.json	&amp;emsp;	&amp;emsp;	(## 如果容器内端口从没有暴露 需要修改这个文件)</span><br><span class="line">&#96;&#96;&#96;bash</span><br><span class="line">vim &#x2F;var&#x2F;lib&#x2F;docker&#x2F;containers&#x2F;[hash_of_the_container]&#x2F;config.v2.json</span><br><span class="line">在 config.v2.json 里面添加一个配置项 &quot;ExposedPorts&quot;:&#123;&quot;80&#x2F;tcp&quot;:&#123;&#125;&#125; , ## 必须将这个配置项添加到 &quot;Tty&quot;: true, 前面</span><br></pre></td></tr></table></figure>
<p>最后重启 docker的守护进程 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl restart  docker</span><br></pre></td></tr></table></figure>
<p>然后需要启动容器id </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker start  <span class="built_in">test</span></span><br></pre></td></tr></table></figure>
<p>查看配置项已经修改成功</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker ps </span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                            NAMES</span><br><span class="line">ccc0f0ca5334        84f2139ad784        <span class="string">"/usr/sbin/init"</span>    6 weeks ago         Up 6 weeks          9001/tcp, 0.0.0.0:9090-&gt;80/tcp   <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><p>docker指令<br><br>指令：FROM <br></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">功能描述：设置基础镜像 </span><br><span class="line">语法：FROM &lt; image&gt;[:&lt; tag&gt; | @&lt; digest&gt;] </span><br><span class="line">提示：镜像都是从一个基础镜像（操作系统或其他镜像）生成，可以在一个Dockerfile中添加多条FROM指令，一次生成多个镜像 </span><br><span class="line">注意：如果忽略tag选项，会使用latest镜像</span><br></pre></td></tr></table></figure>
<p>指令：MAINTAINER </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">功能描述：设置镜像作者 </span><br><span class="line">语法：MAINTAINER &lt; name&gt;</span><br></pre></td></tr></table></figure>
<p>指令：RUN </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">功能描述： </span><br><span class="line">语法：RUN &lt; <span class="built_in">command</span>&gt; </span><br><span class="line">          RUN [“executable”,”param1”,”param2”] </span><br><span class="line">提示：RUN指令会生成容器，在容器中执行脚本，容器使用当前镜像，脚本指令完成后，Docker Daemon会将该容器提交为一个中间镜像，供后面的指令使用 </span><br><span class="line">补充：RUN指令第一种方式为shell方式，使用/bin/sh -c &lt; <span class="built_in">command</span>&gt;运行脚本，可以在其中使用\将脚本分为多行 </span><br><span class="line">          RUN指令第二种方式为<span class="built_in">exec</span>方式，镜像中没有/bin/sh或者要使用其他shell时使用该方式，其不会调用shell命令 </span><br><span class="line">例子：RUN <span class="built_in">source</span> <span class="variable">$HOME</span>/.bashrc;\ </span><br><span class="line">          <span class="built_in">echo</span> <span class="variable">$HOME</span></span><br><span class="line"></span><br><span class="line">          RUN [“/bin/bash”,”-c”,”<span class="built_in">echo</span> hello”]</span><br><span class="line"></span><br><span class="line">          RUN [“sh”,”-c”,”<span class="built_in">echo</span>”,”<span class="variable">$HOME</span>”] 使用第二种方式调用shell读取环境变量</span><br></pre></td></tr></table></figure>
<p>指令：CMD </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">功能描述：设置容器的启动命令 </span><br><span class="line">语法：CMD [“executable”,”param1”,”param2”] </span><br><span class="line">          CMD [“param1”,”param2”] </span><br><span class="line">          CMD &lt; <span class="built_in">command</span>&gt; </span><br><span class="line">提示：CMD第一种、第三种方式和RUN类似，第二种方式为ENTRYPOINT参数方式，为entrypoint提供参数列表 </span><br><span class="line">注意：Dockerfile中只能有一条CMD命令，如果写了多条则最后一条生效</span><br></pre></td></tr></table></figure>
<p>指令：LABEL </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">功能描述：设置镜像的标签 </span><br><span class="line">延伸：镜像标签可以通过docker inspect查看 </span><br><span class="line">格式：LABEL &lt; key&gt;=&lt; value&gt; &lt; key&gt;=&lt; value&gt; … </span><br><span class="line">提示：不同标签之间通过空格隔开 </span><br><span class="line">注意：每条指令都会生成一个镜像层，Docker中镜像最多只能有127层，如果超出Docker Daemon就会报错，如LABEL ..=.. &lt;假装这里有个换行&gt; LABEL ..=..合在一起用空格分隔就可以减少镜像层数量，同样，可以使用连接符\将脚本分为多行 </span><br><span class="line">          镜像会继承基础镜像中的标签，如果存在同名标签则会覆盖</span><br></pre></td></tr></table></figure>
<p>指令：EXPOSE </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">功能描述：设置镜像暴露端口，记录容器启动时监听哪些端口 </span><br><span class="line">语法：EXPOSE &lt; port&gt; &lt; port&gt; … </span><br><span class="line">延伸：镜像暴露端口可以通过docker inspect查看 </span><br><span class="line">提示：容器启动时，Docker Daemon会扫描镜像中暴露的端口，如果加入-P参数，Docker Daemon会把镜像中所有暴露端口导出，并为每个暴露端口分配一个随机的主机端口（暴露端口是容器监听端口，主机端口为外部访问容器的端口） </span><br><span class="line">注意：EXPOSE只设置暴露端口并不导出端口，只有启动容器时使用-P/-p才导出端口，这个时候才能通过外部访问容器提供的服务</span><br></pre></td></tr></table></figure>
<p>指令：ENV </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">功能描述：设置镜像中的环境变量 </span><br><span class="line">语法：ENV &lt; key&gt;=&lt; value&gt;…|&lt; key&gt; &lt; value&gt; </span><br><span class="line">注意：环境变量在整个编译周期都有效，第一种方式可设置多个环境变量，第二种方式只设置一个环境变量 </span><br><span class="line">提示：通过<span class="variable">$&#123;变量名&#125;</span>或者 $变量名使用变量，使用方式<span class="variable">$&#123;变量名&#125;</span>时可以用<span class="variable">$&#123;变量名:-default&#125;</span> <span class="variable">$&#123;变量名:+cover&#125;</span>设定默认值或者覆盖值 </span><br><span class="line">          ENV设置的变量值在整个编译过程中总是保持不变的</span><br></pre></td></tr></table></figure>
<p>指令：ADD </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">功能描述：复制文件到镜像中 </span><br><span class="line">语法：ADD &lt; src&gt;… &lt; dest&gt;|[“&lt; src&gt;”,… “&lt; dest&gt;”] </span><br><span class="line">注意：当路径中有空格时，需要使用第二种方式 </span><br><span class="line">          当src为文件或目录时，Docker Daemon会从编译目录寻找这些文件或目录，而dest为镜像中的绝对路径或者相对于WORKDIR的路径 </span><br><span class="line">提示：src为目录时，复制目录中所有内容，包括文件系统的元数据，但不包括目录本身 </span><br><span class="line">          src为压缩文件，并且压缩方式为gzip,bzip2或xz时，指令会将其解压为目录 </span><br><span class="line">          如果src为文件，则复制文件和元数据 </span><br><span class="line">          如果dest不存在，指令会自动创建dest和缺失的上级目录</span><br></pre></td></tr></table></figure>
<p>指令：COPY </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">功能描述：复制文件到镜像中 </span><br><span class="line">语法：COPY &lt; src&gt;… &lt; dest&gt;|[“&lt; src&gt;”,… “&lt; dest&gt;”] </span><br><span class="line">提示：指令逻辑和ADD十分相似，同样Docker Daemon会从编译目录寻找文件或目录，dest为镜像中的绝对路径或者相对于WORKDIR的路径</span><br></pre></td></tr></table></figure>
<p>指令：ENTRYPOINT</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">功能描述：设置容器的入口程序 </span><br><span class="line">语法：ENTRYPOINT [“executable”,”param1”,”param2”] </span><br><span class="line">          ENTRYPOINT <span class="built_in">command</span> param1 param2（shell方式） </span><br><span class="line">提示：入口程序是容器启动时执行的程序，docker run中最后的命令将作为参数传递给入口程序 </span><br><span class="line">          入口程序有两种格式：<span class="built_in">exec</span>、shell，其中shell使用/bin/sh -c运行入口程序，此时入口程序不能接收信号量 </span><br><span class="line">          当Dockerfile有多条ENTRYPOINT时只有最后的ENTRYPOINT指令生效 </span><br><span class="line">          如果使用脚本作为入口程序，需要保证脚本的最后一个程序能够接收信号量，可以在脚本最后使用<span class="built_in">exec</span>或gosu启动传入脚本的命令 </span><br><span class="line">注意：通过shell方式启动入口程序时，会忽略CMD指令和docker run中的参数 </span><br><span class="line">          为了保证容器能够接受docker stop发送的信号量，需要通过<span class="built_in">exec</span>启动程序；如果没有加入<span class="built_in">exec</span>命令，则在启动容器时容器会出现两个进程，并且使用docker stop命令容器无法正常退出（无法接受SIGTERM信号），超时后docker stop发送SIGKILL，强制停止容器 </span><br><span class="line">例子：FROM ubuntu &lt;换行&gt; ENTRYPOINT <span class="built_in">exec</span> top -b</span><br></pre></td></tr></table></figure>
<p>指令：VOLUME </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">功能描述：设置容器的挂载点 </span><br><span class="line">语法：VOLUME [“/data”] </span><br><span class="line">          VOLUME /data1 /data2 </span><br><span class="line">提示：启动容器时，Docker Daemon会新建挂载点，并用镜像中的数据初始化挂载点，可以将主机目录或数据卷容器挂载到这些挂载点</span><br></pre></td></tr></table></figure>
<p>指令：USER </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">功能描述：设置RUN CMD ENTRYPOINT的用户名或UID </span><br><span class="line">语法：USER &lt; name&gt;</span><br></pre></td></tr></table></figure>
<p>指令：WORKDIR </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">功能描述：设置RUN CMD ENTRYPOINT ADD COPY指令的工作目录 </span><br><span class="line">语法：WORKDIR &lt; Path&gt; </span><br><span class="line">提示：如果工作目录不存在，则Docker Daemon会自动创建 </span><br><span class="line">          Dockerfile中多个地方都可以调用WORKDIR，如果后面跟的是相对位置，则会跟在上条WORKDIR指定路径后（如WORKDIR /A   WORKDIR B   WORKDIR C，最终路径为/A/B/C）</span><br></pre></td></tr></table></figure>
<p>指令：ARG </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">功能描述：设置编译变量 </span><br><span class="line">语法：ARG &lt; name&gt;[=&lt; defaultValue&gt;] </span><br><span class="line">注意：ARG从定义它的地方开始生效而不是调用的地方，在ARG之前调用编译变量总为空，在编译镜像时，可以通过docker build –build-arg &lt; var&gt;=&lt; value&gt;设置变量，如果var没有通过ARG定义则Daemon会报错 </span><br><span class="line">          可以使用ENV或ARG设置RUN使用的变量，如果同名则ENV定义的值会覆盖ARG定义的值，与ENV不同，ARG的变量值在编译过程中是可变的，会对比使用编译缓存造成影响（ARG值不同则编译过程也不同） </span><br><span class="line">例子：ARG CONT_IMAG_VER &lt;换行&gt; RUN <span class="built_in">echo</span> <span class="variable">$CONT_IMG_VER</span> </span><br><span class="line">          ARG CONT_IMAG_VER &lt;换行&gt; RUN <span class="built_in">echo</span> hello </span><br><span class="line">          当编译时给ARG变量赋值hello，则两个Dockerfile可以使用相同的中间镜像，如果不为hello，则不能使用同一个中间镜像</span><br></pre></td></tr></table></figure>
<p>指令：ONBUILD </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">功能描述：设置自径想的编译钩子指令 </span><br><span class="line">语法：ONBUILD [INSTRUCTION] </span><br><span class="line">提示：从该镜像生成子镜像，在子镜像的编译过程中，首先会执行父镜像中的ONBUILD指令，所有编译指令都可以成为钩子指令</span><br></pre></td></tr></table></figure>
<p>指令：STOPSIGNAL </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">功能描述：设置容器退出时，Docker Daemon向容器发送的信号量 </span><br><span class="line">语法：STOPSIGNAL signal </span><br><span class="line">提示：信号量可以是数字或者信号量的名字，如9或者SIGKILL，信号量的数字说明在Linux系统管理中有简单介绍</span><br></pre></td></tr></table></figure>

<p>写好Dockerfile后放到一个目录中      &emsp;    &emsp; –Dockerfile里所需要copy 或者add的文件要在同目录下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build   -t  web:v1.1 .      --  -t指定名称 和 版本    . 代表上下级目录</span><br></pre></td></tr></table></figure>
<p>启动docker</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -it  --privileged=<span class="literal">true</span>  --name <span class="built_in">test</span>   -p 9090:80  -d   84f2139ad784   /usr/sbin/init    </span><br><span class="line"><span class="comment">#  --privileged=true 可以在容器中有权限启动服务     -p 端口映射 9090宿主机端口  80 容器端口</span></span><br><span class="line">``` </span><br><span class="line">```bash</span><br><span class="line"><span class="comment">##多个端口映射</span></span><br><span class="line">docker run -it  --privileged=<span class="literal">true</span>  --name lin   -p 90:80  -p 1111:9001 -p 2222:20001  -d   9aec5c5fe4ba   /usr/sbin/init</span><br></pre></td></tr></table></figure>

<p>dockerfile案例</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Base images 基础镜像</span></span><br><span class="line">FROM centos:centos7.2.1511</span><br><span class="line"></span><br><span class="line"><span class="comment">#MAINTAINER 维护者信息</span></span><br><span class="line">MAINTAINER xinlong </span><br><span class="line"></span><br><span class="line"><span class="comment">#ADD  文件放在当前目录下，拷过去会自动解压</span></span><br><span class="line">ADD node.repo.bak   /etc/yum.repos.d/</span><br><span class="line"></span><br><span class="line"><span class="comment">#RUN 执行以下命令 </span></span><br><span class="line">RUN yum clean all \</span><br><span class="line">        &amp;&amp; yum install    httpd    -y </span><br><span class="line"></span><br><span class="line"><span class="comment">#WORKDIR 相当于cd</span></span><br><span class="line">WORKDIR /var/www/html</span><br><span class="line"></span><br><span class="line">RUN <span class="built_in">echo</span> <span class="string">"dockerfile test"</span>  &gt;  index.html</span><br><span class="line"></span><br><span class="line"><span class="comment">#EXPOSE 映射端口</span></span><br><span class="line">EXPOSE 9001</span><br><span class="line">EXPOSE 20001</span><br><span class="line"></span><br><span class="line">CMD systemctl start httpd</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Base images 基础镜像</span></span><br><span class="line">FROM centos7.2.1511</span><br><span class="line"></span><br><span class="line"><span class="comment">#MAINTAINER 维护者信息</span></span><br><span class="line">MAINTAINER xinlong </span><br><span class="line"></span><br><span class="line"><span class="comment">#ADD  文件放在当前目录下，如果是压缩文件拷过去会自动解压</span></span><br><span class="line">ADD node.repo   /etc/yum.repos.d/</span><br><span class="line"></span><br><span class="line"><span class="comment">#RUN 执行以下命令 </span></span><br><span class="line">RUN yum clean all   \</span><br><span class="line">	&amp;&amp; yum install epel-release -y	\</span><br><span class="line">	&amp;&amp; yum install net-tools   httpd  vim  elinks    passwd openssl openssh-server     openssl-client  -y	\</span><br><span class="line">	&amp;&amp; /usr/sbin/sshd -D &amp;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">RUN /data/sgsm/1/web/trunk</span><br><span class="line">RUN mkdir /data/sgsm/   -p \</span><br><span class="line">	mkdir /data/sgsm/1/	\</span><br><span class="line">	mkdir         /data/sgsm/1/&#123;boss_pvp,chart_pvp,chat_pvp,city_pvp,consume_pvp,convey_pvp,five_pvp,login,ore_pvp,pay,pvp,recharge_pvp,secret_pvp,server,servers_pvp,sky,team_pvp,video,web,wusheng_pvp&#125;   \</span><br><span class="line">	mkdir /data/sgsm/1/web/&#123;logs,trunk&#125; </span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"><span class="comment">#WORKDIR 相当于cd</span></span><br><span class="line">WORKDIR /data/sgsm/1/web/trunk</span><br><span class="line">	svn co http://192.168.1.161/program/program/server/</span><br><span class="line"></span><br><span class="line"><span class="comment">#EXPOSE 映射端口  创建容器的时候还需要指定</span></span><br><span class="line">EXPOSE 9001</span><br><span class="line"></span><br><span class="line">CMD systemctl start httpd</span><br></pre></td></tr></table></figure>

<h2 id="导入导出容器"><a href="#导入导出容器" class="headerlink" title="导入导出容器"></a>导入导出容器</h2><p>导出容器–docker export 容器id &gt; /指定目录/名字.tar</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker  <span class="built_in">export</span>  ID  &gt; file.tar</span><br></pre></td></tr></table></figure>
<p>scp发送至有docker环境的服务器</p>
<p>导入容器（可以先docker images查看一下）–cat 名字.tar | docker import - 镜像名</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat  file.tar  | docker  import  - NAME</span><br></pre></td></tr></table></figure>

<h2 id="镜像导入导出和更新"><a href="#镜像导入导出和更新" class="headerlink" title="镜像导入导出和更新"></a>镜像导入导出和更新</h2><p>镜像导出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker save 镜像 xxx.tar</span><br><span class="line">```  </span><br><span class="line">镜像导入：</span><br><span class="line">```bash</span><br><span class="line">docker load -i xxx.tar</span><br></pre></td></tr></table></figure>
<p>镜像的更新：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker commit -m 提交的描述 -a 提交作者 -p 更新时暂停此容器 新镜像名</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>centos下生成多份密钥对</title>
    <url>/2020/06/11/ssh/</url>
    <content><![CDATA[<p>常用选项</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-t  指定秘钥类型(默认rsa)</span><br><span class="line">-f  指定秘钥文件路径(默认用户家目录.ssh下)</span><br><span class="line">-P  指定密码(可不设置)</span><br><span class="line">-c  注释内容一般填写邮件(可不指定)</span><br></pre></td></tr></table></figure>

<p>常用语法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen  -t rsa  -f ~/.ssh/xxx   -P xxx</span><br></pre></td></tr></table></figure>

<p>-f 选项的好处就是一台机器可以生成多份秘钥,因为默认的秘钥名为id_rsa和id_rsa.pub,在使用ssh-keygen生成就会覆盖</p>
<p>使用 -f 选项</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[sgsm@iZ2ze53g8gh7cdxahhcv95Z .ssh]$ ssh-keygen  -t rsa  -f ~/.ssh/mihua   -P xxx</span><br><span class="line">[sgsm@iZ2ze53g8gh7cdxahhcv95Z .ssh]$ ll</span><br><span class="line">total 32</span><br><span class="line">-rw------- 1 sgsm sgsm  2047 May 16 11:06 authorized_keys</span><br><span class="line">-rw------- 1 sgsm users  816 May 16 11:03 authorized_keys.bak</span><br><span class="line">-rw------- 1 sgsm users 1675 Apr  8 17:45 id_rsa</span><br><span class="line">-rw-r--r-- 1 sgsm users  410 Apr  8 17:45 id_rsa.pub</span><br><span class="line">-rw-r--r-- 1 sgsm users 4728 Apr 17 14:44 known_hosts</span><br><span class="line">-rw------- 1 sgsm users 1766 Jun 11 09:42 mihua</span><br><span class="line">-rw-r--r-- 1 sgsm users  410 Jun 11 09:42 mihua.pub</span><br></pre></td></tr></table></figure>
<p>现在把mihua.pub 导入需要免密登录的机器中就可以实现免密登录</p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title>git基础操作</title>
    <url>/2020/06/09/git/</url>
    <content><![CDATA[<h2 id="Git安装"><a href="#Git安装" class="headerlink" title="Git安装"></a>Git安装</h2><p>yum安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install git -y</span><br></pre></td></tr></table></figure>
<p>源码安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载源码包</span></span><br><span class="line"><span class="built_in">cd</span> /opt/</span><br><span class="line">sudo wget https://github.com/git/git/archive/v2.14.1.zip</span><br><span class="line">unzip v2.14.1.zip</span><br><span class="line"><span class="comment"># 安装依赖包</span></span><br><span class="line"> sudo  yum  install curl-devel expat-devel gettext-devel openssl-devel zlib-devel gcc perl-ExtUtils-MakeMaker   -y </span><br><span class="line"><span class="comment"># 进入git-2.3.0，</span></span><br><span class="line"><span class="built_in">cd</span> git-2.14.1</span><br><span class="line"><span class="comment">#配置参数</span></span><br><span class="line">sudo make prefix=/usr/<span class="built_in">local</span>/ all</span><br><span class="line">sudo make prefix=/usr/<span class="built_in">local</span>/ install</span><br><span class="line"><span class="comment"># 等待一切安装完成，用git --version查看版本号，能看到即可</span></span><br><span class="line">git  --version</span><br></pre></td></tr></table></figure>
<h2 id="Git工作流程"><a href="#Git工作流程" class="headerlink" title="Git工作流程"></a>Git工作流程</h2><p>一般工作流程如下：</p>
<pre><code>克隆 Git 资源作为工作目录。
在克隆的资源上添加或修改文件。
如果其他人修改了，你可以更新资源。
在提交前查看修改。
提交修改。
在修改完成后，如果发现错误，可以撤回提交并再次修改并提交。</code></pre><p>当执行提交操作（git commit）时，暂存区的目录树写到版本库（对象库）中，master 分支会做相应的更新。即 master 指向的目录树就是提交时暂存区的目录树。</p>
<p>当执行 “git reset HEAD” 命令时，暂存区的目录树会被重写，被 master 分支指向的目录树所替换，但是工作区不受影响。</p>
<p>当执行 “git rm –cached <file>“ 命令时，会直接从暂存区删除文件，工作区则不做出改变。</file></p>
<p>当执行 “git checkout .” 或者 “git checkout – <file>“ 命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区的改动。</file></p>
<p>当执行 “git checkout HEAD .” 或者 “git checkout HEAD <file>“ 命令时，会用 HEAD 指向的 master 分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。 </file></p>
<h2 id="Git创建仓库"><a href="#Git创建仓库" class="headerlink" title="Git创建仓库"></a>Git创建仓库</h2><p>git init</p>
<p>Git 使用 git init 命令来初始化一个 Git 仓库，Git 的很多命令都需要在 Git 的仓库中运行，所以 git init 是使用 Git 的第一个命令。<br>在执行完成 git init 命令后，Git 仓库会生成一个 .git 目录，该目录包含了资源的所有元数据，其他的项目目录保持不变（不像 SVN 会在每个子目录生成 .svn 目录，Git 只在仓库的根目录生成 .git 目录）。</p>
<p>使用当前目录作为Git仓库，我们只需使它初始化。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>
<p>如果当前目录下有几个文件想要纳入版本控制，需要先用 git add 命令告诉 Git 开始对这些文件进行跟踪，然后提交： </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git add *.c</span><br><span class="line">$ git add README</span><br><span class="line">$ git commit -m <span class="string">'初始化项目版本'</span></span><br></pre></td></tr></table></figure>
<p>以上命令将目录下以 .c 结尾及 README 文件提交到仓库中。</p>
<p>git clone<br><br>我们使用 git clone 从现有 Git 仓库中拷贝项目（类似 svn checkout）<br></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> &lt;repo&gt;</span><br></pre></td></tr></table></figure>
<p>如果我们需要克隆到指定的目录，可以使用以下命令格式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> &lt;repo&gt; &lt;directory&gt;</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<pre><code>repo:Git 仓库。
directory:本地目录</code></pre><p>执行该命令后，会在当前目录下创建一个名为grit的目录，其中包含一个 .git 的目录，用于保存下载下来的所有版本记录。</p>
<p>如果要自己定义要新建的项目目录名称，可以在上面的命令末尾指定新的名字：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git://github.com/schacon/grit.git mygrit</span><br></pre></td></tr></table></figure>

<h2 id="Git基本操作"><a href="#Git基本操作" class="headerlink" title="Git基本操作"></a>Git基本操作</h2><p>创建仓库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[sgsm@centos git]$ mkdir git</span><br><span class="line">[sgsm@centos git]$ <span class="built_in">cd</span>  git</span><br><span class="line">[sgsm@centos git]$ git  init</span><br><span class="line">Initialized empty Git repository <span class="keyword">in</span> /root/git/.git/</span><br></pre></td></tr></table></figure>
<p>现在你可以看到在你的项目中生成了 .git 这个子目录。 这就是你的 Git 仓库了，所有有关你的此项目的快照数据都存放在这里</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[sgsm@centos git]$ ll -a</span><br><span class="line">total 12</span><br><span class="line">drwxr-xr-x   3 sgsm sgsm 4096 Jun 12 13:50 .</span><br><span class="line">dr-xr-x---. 11 sgsm sgsm 4096 Jun 12 13:31 ..</span><br><span class="line">drwxr-xr-x   7 sgsm sgsm 4096 Jun 12 13:50 .git</span><br></pre></td></tr></table></figure>

<p>克隆仓库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git  <span class="built_in">clone</span>  https://github.com/xinlongOB/python.github.io.git</span><br></pre></td></tr></table></figure>

<p>git add </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 创建文件</span><br><span class="line">touch  test.py</span><br><span class="line"># 添加暂存区    . 代表当前目录   也可以指定文件名</span><br><span class="line">git add  .</span><br><span class="line"># 提交并添加注释</span><br><span class="line">git commit -m &quot; add  test.py&quot;</span><br></pre></td></tr></table></figure>
<p>报错：</p>
<pre><code>*** Please tell me who you are.

Run

  git config --global user.email &quot;you@example.com&quot;
  git config --global user.name &quot;Your Name&quot;

to set your account&apos;s default identity.
Omit --global to set the identity only in this repository.

fatal: unable to auto-detect email address (got &apos;root@suyuerunCentos.(none)&apos;)</code></pre><p>因为没有添加账号密码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加邮箱和账号</span></span><br><span class="line">git config --global user.email <span class="string">"942868591@qq.com"</span></span><br><span class="line">git config --global user.name <span class="string">"long"</span></span><br></pre></td></tr></table></figure>
<p>再次提交</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[sgsm@centos python.github.io]$ git commit -m <span class="string">" add  test.py"</span>                    </span><br><span class="line">[master 49151ac]  add  test.py</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 test.py</span><br></pre></td></tr></table></figure>
<p>使用 git log 查看提交记录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@centos python.github.io]$ git <span class="built_in">log</span></span><br><span class="line">commit 49151ac5859a2227e660c25cc5d3df07b2964974 (HEAD -&gt; master)</span><br><span class="line">Author: long &lt;942868591@qq.com&gt;</span><br><span class="line">Date:   Fri Jun 12 14:05:48 2020 +0800</span><br><span class="line"></span><br><span class="line">     add  test.py</span><br></pre></td></tr></table></figure>
<p>git status<br><br>git status 以查看在你上次提交之后是否有修改<br></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@centos python.github.io]$ touch import.py   <span class="comment"># 创建文件</span></span><br><span class="line">[root@centos python.github.io]$ git status  -s   <span class="comment"># 查看是否有修改</span></span><br><span class="line">?? import.py          <span class="comment"># ? 代表不明状态  就是没有添加到暂存区</span></span><br><span class="line">[root@centos python.github.io]$ git add .     <span class="comment"># 提交</span></span><br><span class="line">[root@centos python.github.io]$ git status  -s    <span class="comment"># 查看是否有修改</span></span><br><span class="line">A  import.py          <span class="comment"># A  表示add   新增</span></span><br></pre></td></tr></table></figure>

<p>git commit</p>
<p>使用 git add 命令将想要快照的内容写入缓存区， 而执行 git commit 将缓存区内容添加到仓库中。<br><br>Git 为你的每一个提交都记录你的名字与电子邮箱地址，所以第一步需要配置用户名和邮箱地址。<br></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加邮箱和账号</span></span><br><span class="line">git config --global user.email <span class="string">"942868591@qq.com"</span></span><br><span class="line">git config --global user.name <span class="string">"long"</span></span><br></pre></td></tr></table></figure>

<p>git reset HEAD</p>
<p>git reset HEAD 命令用于取消已缓存的内容。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[sgsm@centos python.github.io]$ <span class="built_in">echo</span>  <span class="string">"print("</span><span class="built_in">test</span><span class="string">")"</span> &gt; test.py </span><br><span class="line">[sgsm@centos python.github.io]$ <span class="built_in">echo</span>  <span class="string">"print("</span>import<span class="string">")"</span> &gt; import.py            </span><br><span class="line">[sgsm@centos python.github.io]$ git add .</span><br><span class="line">[sgsm@centos python.github.io]$ git status -s                        </span><br><span class="line">A  import.py</span><br><span class="line">M  test.py</span><br><span class="line">[sgsm@centos python.github.io]$ git reset HEAD   test.py </span><br><span class="line">Unstaged changes after reset:</span><br><span class="line">M       test.py</span><br><span class="line">[sgsm@centos python.github.io]$ git status -s            </span><br><span class="line">A  import.py</span><br><span class="line"> M test.py</span><br><span class="line">[sgsm@centos python.github.io]$ git config --global user.email <span class="string">"942868591@qq.com"</span></span><br><span class="line">[sgsm@centos python.github.io]$ git config --global user.name <span class="string">"long"</span></span><br><span class="line">[sgsm@centos python.github.io]$ git commit -m <span class="string">"update"</span>                           </span><br><span class="line">[master cbd780e] update</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 import.py</span><br><span class="line"><span class="comment"># 提交日志显示只提交了一个文件 说明撤销成功了</span></span><br></pre></td></tr></table></figure>

<p>git rm</p>
<p>如果只是简单地从工作目录中手工删除文件，运行 git status 时就会在 Changes not staged for commit 的提示。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除，然后提交。可以用以下命令完成此项工作</span></span><br><span class="line">git rm &lt;file&gt; </span><br><span class="line"><span class="comment"># 如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 -f</span></span><br><span class="line">git rm -f &lt;file&gt;</span><br><span class="line"><span class="comment"># 如果把文件从暂存区域移除，但仍然希望保留在当前工作目录中，换句话说，仅是从跟踪清单中删除，使用 --cached 选项即可</span></span><br><span class="line">git rm --cached &lt;file&gt;</span><br><span class="line"><span class="comment">#  例如删除已提交的文件：</span></span><br><span class="line">[sgsm@centos python.github.io]$ git rm  -f test.py  </span><br><span class="line">rm <span class="string">'test.py'</span></span><br><span class="line">[sgsm@centos python.github.io]$ ll</span><br><span class="line">total 24</span><br><span class="line">-rw-r--r-- 1 sgsm sgsm   14 Jun 12 14:23 import.py</span><br><span class="line">-rw-r--r-- 1 sgsm sgsm 3744 Jun 12 13:53 plane_main.py</span><br><span class="line">-rw-r--r-- 1 sgsm sgsm 5113 Jun 12 13:53 plane_sprites.py</span><br><span class="line">-rw-r--r-- 1 sgsm sgsm  188 Jun 12 13:53 README.md</span><br><span class="line">drwxr-xr-x 2 sgsm sgsm 4096 Jun 12 13:53 图片</span><br><span class="line">[sgsm@centos python.github.io]$</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 例如从暂存区移除，但保留在当前工作目录</span></span><br><span class="line">[sgsm@centos python.github.io]$ <span class="built_in">echo</span>  <span class="string">"test"</span>  &gt; test.py </span><br><span class="line">[sgsm@centos python.github.io]$ git add  .    </span><br><span class="line">[sgsm@centos python.github.io]$ git status -s </span><br><span class="line">M  test.py</span><br><span class="line">[sgsm@centos python.github.io]$ ll</span><br><span class="line">total 28</span><br><span class="line">-rw-r--r-- 1 sgsm sgsm    14 Jun 12 14:23 import.py</span><br><span class="line">-rw-r--r-- 1 sgsm sgsm  3744 Jun 12 13:53 plane_main.py</span><br><span class="line">-rw-r--r-- 1 sgsm sgsm  5113 Jun 12 13:53 plane_sprites.py</span><br><span class="line">-rw-r--r-- 1 sgsm sgsm   188 Jun 12 13:53 README.md</span><br><span class="line">-rw-r--r-- 1 sgsm users    5 Jun 12 14:36 test.py</span><br><span class="line">drwxr-xr-x 2 sgsm sgsm  4096 Jun 12 13:53 图片</span><br><span class="line">[sgsm@centos python.github.io]$ git rm --cached test.py </span><br><span class="line">rm <span class="string">'test.py'</span></span><br><span class="line">[sgsm@centos python.github.io]$ ll</span><br><span class="line">total 28</span><br><span class="line">-rw-r--r-- 1 sgsm sgsm    14 Jun 12 14:23 import.py</span><br><span class="line">-rw-r--r-- 1 sgsm sgsm  3744 Jun 12 13:53 plane_main.py</span><br><span class="line">-rw-r--r-- 1 sgsm sgsm  5113 Jun 12 13:53 plane_sprites.py</span><br><span class="line">-rw-r--r-- 1 sgsm sgsm   188 Jun 12 13:53 README.md</span><br><span class="line">-rw-r--r-- 1 sgsm users    5 Jun 12 14:36 test.py</span><br><span class="line">drwxr-xr-x 2 sgsm sgsm  4096 Jun 12 13:53 图片</span><br><span class="line">[sgsm@centos python.github.io]$ git status -s </span><br><span class="line">D  test.py</span><br><span class="line">?? test.py</span><br><span class="line">[sgsm@centos python.github.io]$</span><br></pre></td></tr></table></figure>

<p> git mv</p>
<p>git mv 命令用于移动或重命名一个文件、目录、软连接</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[sgsm@centos python.github.io]$ ll</span><br><span class="line">total 24</span><br><span class="line">-rw-r--r-- 1 sgsm sgsm   14 Jun 12 14:23 import.py</span><br><span class="line">-rw-r--r-- 1 sgsm sgsm 3744 Jun 12 13:53 plane_main.py</span><br><span class="line">-rw-r--r-- 1 sgsm sgsm 5113 Jun 12 13:53 plane_sprites.py</span><br><span class="line">-rw-r--r-- 1 sgsm sgsm  188 Jun 12 13:53 README.md</span><br><span class="line">drwxr-xr-x 2 sgsm sgsm 4096 Jun 12 13:53 图片</span><br><span class="line">[sgsm@centos python.github.io]$ git status -s</span><br><span class="line">[sgsm@centos python.github.io]$ git mv  import.py   print.py</span><br><span class="line">[sgsm@centos python.github.io]$ ll</span><br><span class="line">total 24</span><br><span class="line">-rw-r--r-- 1 sgsm sgsm 3744 Jun 12 13:53 plane_main.py</span><br><span class="line">-rw-r--r-- 1 sgsm sgsm 5113 Jun 12 13:53 plane_sprites.py</span><br><span class="line">-rw-r--r-- 1 sgsm sgsm   14 Jun 12 14:23 print.py</span><br><span class="line">-rw-r--r-- 1 sgsm sgsm  188 Jun 12 13:53 README.md</span><br><span class="line">drwxr-xr-x 2 sgsm sgsm 4096 Jun 12 13:53 图片</span><br><span class="line">[sgsm@centos python.github.io]$</span><br></pre></td></tr></table></figure>

<h2 id="Git分支管理"><a href="#Git分支管理" class="headerlink" title="Git分支管理"></a>Git分支管理</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建分支</span></span><br><span class="line">[sgsm@centos python.github.io]$ git branch  python</span><br><span class="line"><span class="comment">#  切换分支</span></span><br><span class="line">[sgsm@centos python.github.io]$ git checkout  python</span><br></pre></td></tr></table></figure>
<p>查看分支(默认不加参数会列出你在本地的分支)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[sgsm@centos python.github.io]$ git branch</span><br><span class="line">* master</span><br><span class="line">  python</span><br><span class="line">[sgsm@centos python.github.io]$</span><br></pre></td></tr></table></figure>
<p>主线和分支验证</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[sgsm@centos sgsm]$ git checkout  master</span><br><span class="line">Switched to branch <span class="string">'master'</span></span><br><span class="line">[sgsm@centos sgsm]$ ll</span><br><span class="line">total 0</span><br><span class="line">-rw-r--r-- 1 sgsm users 0 Jun 12 14:56 <span class="built_in">test</span></span><br><span class="line">[sgsm@centos sgsm]$ </span><br><span class="line">[sgsm@centos sgsm]$ touch mihua                 <span class="comment"># 在master上创建一个文件</span></span><br><span class="line">[sgsm@centos sgsm]$ git add . </span><br><span class="line">[sgsm@centos sgsm]$ git  commit -m <span class="string">"mihua"</span>    <span class="comment"># 提交</span></span><br><span class="line">[master a56e6c2] mihua</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 mihua</span><br><span class="line">[sgsm@centos sgsm]$ ll                        <span class="comment"># 在master可以看到</span></span><br><span class="line">total 0</span><br><span class="line">-rw-r--r-- 1 sgsm users 0 Jun 12 14:57 mihua</span><br><span class="line">-rw-r--r-- 1 sgsm users 0 Jun 12 14:56 <span class="built_in">test</span></span><br><span class="line">[sgsm@centos sgsm]$ </span><br><span class="line">[sgsm@centos sgsm]$ git checkout  trunk         <span class="comment"># 切换到分支</span></span><br><span class="line">Switched to branch <span class="string">'trunk'</span></span><br><span class="line">[sgsm@centos sgsm]$ ll                          <span class="comment"># 没有那个文件了</span></span><br><span class="line">total 0</span><br><span class="line">-rw-r--r-- 1 sgsm users 0 Jun 12 14:56 <span class="built_in">test</span> </span><br><span class="line">[sgsm@centos sgsm]$  git checkout  master          <span class="comment"># 切换到master 就可以看到</span></span><br><span class="line">Switched to branch <span class="string">'master'</span></span><br><span class="line">[sgsm@centos sgsm]$ ll</span><br><span class="line">total 0</span><br><span class="line">-rw-r--r-- 1 sgsm users 0 Jun 12 15:00 mihua</span><br><span class="line">-rw-r--r-- 1 sgsm users 0 Jun 12 14:56 <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<p> git checkout -b (branchname) 命令来创建新分支并立即切换到该分支下，从而在该分支中操作<br> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">略</span><br></pre></td></tr></table></figure><br>删除分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -d (branchname)</span><br></pre></td></tr></table></figure>
<p>例如我们要删除v0.6.10分支：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[sgsm@centos sgsm]$ git branch</span><br><span class="line">* master</span><br><span class="line">  trunk</span><br><span class="line">  v0.6.10</span><br><span class="line">[sgsm@centos sgsm]$ </span><br><span class="line">[sgsm@centos sgsm]$ git branch -d  v0.6.10</span><br><span class="line">Deleted branch v0.6.10 (was a56e6c2).</span><br><span class="line">[sgsm@centos sgsm]$ git branch</span><br><span class="line">* master</span><br><span class="line">  trunk</span><br><span class="line">[sgsm@centos sgsm]$</span><br></pre></td></tr></table></figure>
<p>合并分支<br><br>一旦某分支有了独立内容，你终究会希望将它合并回到你的主分支。 你可以使用以下命令将任何分支合并到当前分支中去：<br></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git merge</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[sgsm@centos sgsm]$ ll            <span class="comment"># 新增finddelete.js   haha文件</span></span><br><span class="line">total 4</span><br><span class="line">-rw-r--r-- 1 sgsm users 66 Jun 12 15:58 finddelete.js</span><br><span class="line">-rw-r--r-- 1 sgsm users  0 Jun 12 14:58 haha</span><br><span class="line">-rw-r--r-- 1 sgsm users  0 Jun 12 14:56 <span class="built_in">test</span></span><br><span class="line">[sgsm@centos sgsm]$ git  add . </span><br><span class="line">[sgsm@centos sgsm]$ git commit -m <span class="string">"add  finddelete.js"</span>     <span class="comment"># 提交 </span></span><br><span class="line">[trunk c45f7e4] add  finddelete.js</span><br><span class="line"> 2 files changed, 6 insertions(+)</span><br><span class="line"> create mode 100644 finddelete.js</span><br><span class="line"> create mode 100644 haha</span><br><span class="line">[sgsm@centos sgsm]$ git checkout master         <span class="comment">#  切换到master   没有分支新提交的文件</span></span><br><span class="line">Switched to branch <span class="string">'master'</span></span><br><span class="line">[sgsm@centos sgsm]$ ll</span><br><span class="line">total 0</span><br><span class="line">-rw-r--r-- 1 sgsm users 0 Jun 12 15:59 mihua</span><br><span class="line">-rw-r--r-- 1 sgsm users 0 Jun 12 14:56 <span class="built_in">test</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[sgsm@centos sgsm]$ git merge  trunk    <span class="comment"># 把分支内容合并到主线</span></span><br><span class="line">Merge branch <span class="string">'trunk'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Please enter a commit message to explain why this merge is necessary,</span></span><br><span class="line"><span class="comment"># especially if it merges an updated upstream into a topic branch.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Lines starting with '#' will be ignored, and an empty message aborts</span></span><br><span class="line"><span class="comment"># the commit.</span></span><br><span class="line">Merge made by the <span class="string">'recursive'</span> strategy.</span><br><span class="line"> finddelete.js | 6 ++++++</span><br><span class="line"> haha          | 0</span><br><span class="line"> 2 files changed, 6 insertions(+)</span><br><span class="line"> create mode 100644 finddelete.js</span><br><span class="line"> create mode 100644 haha</span><br><span class="line">[sgsm@centos sgsm]$ ll</span><br><span class="line">total 4</span><br><span class="line">-rw-r--r-- 1 sgsm users 66 Jun 12 16:00 finddelete.js</span><br><span class="line">-rw-r--r-- 1 sgsm users  0 Jun 12 16:00 haha</span><br><span class="line">-rw-r--r-- 1 sgsm users  0 Jun 12 15:59 mihua</span><br><span class="line">-rw-r--r-- 1 sgsm users  0 Jun 12 14:56 <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<h2 id="Git查看提交历史"><a href="#Git查看提交历史" class="headerlink" title="Git查看提交历史"></a>Git查看提交历史</h2><p>git log 命令查看提交历史：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[sgsm@centos sgsm]$ git <span class="built_in">log</span></span><br><span class="line">commit 8c42560ed5c96cfa519b263a2ebd2eb8a85769a5 (HEAD -&gt; master)</span><br><span class="line">Merge: a56e6c2 c45f7e4</span><br><span class="line">Author: long &lt;942868591@qq.com&gt;</span><br><span class="line">Date:   Fri Jun 12 16:00:55 2020 +0800</span><br><span class="line"></span><br><span class="line">    Merge branch <span class="string">'trunk'</span></span><br><span class="line"></span><br><span class="line">commit c45f7e446a702b3d267498d69d5b41b818a9aa85 (trunk)</span><br><span class="line">Author: long &lt;942868591@qq.com&gt;</span><br><span class="line">Date:   Fri Jun 12 15:58:38 2020 +0800</span><br><span class="line"></span><br><span class="line">    add  finddelete.js</span><br><span class="line"></span><br><span class="line">commit a56e6c2758dcdc6101a4b3d0b9c48fb2c8cedc07</span><br><span class="line">Author: long &lt;942868591@qq.com&gt;</span><br><span class="line">Date:   Fri Jun 12 14:58:00 2020 +0800</span><br><span class="line"></span><br><span class="line">    mihua</span><br><span class="line"></span><br><span class="line">commit 9831cb0d222df1f1ea18a32754001afa02036b79</span><br><span class="line">Author: long &lt;942868591@qq.com&gt;</span><br><span class="line">Date:   Fri Jun 12 14:57:06 2020 +0800</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test</span></span><br><span class="line">[sgsm@centos sgsm]$</span><br></pre></td></tr></table></figure>
<p>–oneline 选项来查看历史记录的简洁的版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[sgsm@centos sgsm]$  git <span class="built_in">log</span> --oneline</span><br><span class="line">8c42560 (HEAD -&gt; master) Merge branch <span class="string">'trunk'</span></span><br><span class="line">c45f7e4 (trunk) add  finddelete.js</span><br><span class="line">a56e6c2 mihua</span><br><span class="line">9831cb0 <span class="built_in">test</span></span><br><span class="line">[sgsm@centos sgsm]$</span><br></pre></td></tr></table></figure>
<p>–graph 选项，查看历史中什么时候出现了分支、合并。以下为相同的命令，开启了拓扑图选项：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[sgsm@centos sgsm]$  git <span class="built_in">log</span>  --graph </span><br><span class="line">*   commit 8c42560ed5c96cfa519b263a2ebd2eb8a85769a5 (HEAD -&gt; master)</span><br><span class="line">|\  Merge: a56e6c2 c45f7e4</span><br><span class="line">| | Author: long &lt;942868591@qq.com&gt;</span><br><span class="line">| | Date:   Fri Jun 12 16:00:55 2020 +0800</span><br><span class="line">| | </span><br><span class="line">| |     Merge branch <span class="string">'trunk'</span></span><br><span class="line">| | </span><br><span class="line">| * commit c45f7e446a702b3d267498d69d5b41b818a9aa85 (trunk)</span><br><span class="line">| | Author: long &lt;942868591@qq.com&gt;</span><br><span class="line">| | Date:   Fri Jun 12 15:58:38 2020 +0800</span><br><span class="line">| | </span><br><span class="line">| |     add  finddelete.js</span><br><span class="line">| | </span><br><span class="line">* | commit a56e6c2758dcdc6101a4b3d0b9c48fb2c8cedc07</span><br><span class="line">|/  Author: long &lt;942868591@qq.com&gt;</span><br><span class="line">|   Date:   Fri Jun 12 14:58:00 2020 +0800</span><br><span class="line">|   </span><br><span class="line">|       mihua</span><br><span class="line">| </span><br><span class="line">* commit 9831cb0d222df1f1ea18a32754001afa02036b79</span><br><span class="line">  Author: long &lt;942868591@qq.com&gt;</span><br><span class="line">  Date:   Fri Jun 12 14:57:06 2020 +0800</span><br><span class="line">  </span><br><span class="line">      <span class="built_in">test</span></span><br><span class="line">[sgsm@centos sgsm]$</span><br></pre></td></tr></table></figure>

<p> –reverse 参数来逆向显示所有日志<br> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> [sgsm@centos sgsm]$  git <span class="built_in">log</span>   --reverse    <span class="comment"># 从第一次提交 --&gt;最后一次提交</span></span><br><span class="line">commit 9831cb0d222df1f1ea18a32754001afa02036b79</span><br><span class="line">Author: long &lt;942868591@qq.com&gt;</span><br><span class="line">Date:   Fri Jun 12 14:57:06 2020 +0800</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line">commit a56e6c2758dcdc6101a4b3d0b9c48fb2c8cedc07</span><br><span class="line">Author: long &lt;942868591@qq.com&gt;</span><br><span class="line">Date:   Fri Jun 12 14:58:00 2020 +0800</span><br><span class="line"></span><br><span class="line">    mihua</span><br><span class="line"></span><br><span class="line">commit c45f7e446a702b3d267498d69d5b41b818a9aa85 (trunk)</span><br><span class="line">Author: long &lt;942868591@qq.com&gt;</span><br><span class="line">Date:   Fri Jun 12 15:58:38 2020 +0800</span><br><span class="line"></span><br><span class="line">    add  finddelete.js</span><br><span class="line"></span><br><span class="line">commit 8c42560ed5c96cfa519b263a2ebd2eb8a85769a5 (HEAD -&gt; master)</span><br><span class="line">Merge: a56e6c2 c45f7e4</span><br><span class="line">Author: long &lt;942868591@qq.com&gt;</span><br><span class="line">Date:   Fri Jun 12 16:00:55 2020 +0800</span><br><span class="line"></span><br><span class="line">    Merge branch <span class="string">'trunk'</span></span><br><span class="line">[sgsm@centos sgsm]$</span><br></pre></td></tr></table></figure><br> –author 查找指定用户的提交日志<br> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> [sgsm@centos sgsm]$ git <span class="built_in">log</span> --author=long --oneline -5     </span><br><span class="line">8c42560 (HEAD -&gt; master) Merge branch <span class="string">'trunk'</span></span><br><span class="line">c45f7e4 (trunk) add  finddelete.js</span><br><span class="line">a56e6c2 mihua</span><br><span class="line">9831cb0 <span class="built_in">test</span></span><br><span class="line">[sgsm@centos sgsm]$</span><br></pre></td></tr></table></figure><br>–since 和 –before 查看指定日期的日志 (–no-merges 选项以隐藏合并提交)<br><br>例如，如果我要看 Git 项目中三周前且在四月十八日之后的所有提交<br></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> --oneline --before=&#123;3.weeks.ago&#125; --after=&#123;2010-04-18&#125; --no-merges</span><br></pre></td></tr></table></figure>

<h2 id="Git远程仓库-Github"><a href="#Git远程仓库-Github" class="headerlink" title="Git远程仓库(Github)"></a>Git远程仓库(Github)</h2><p>Git 并不像 SVN 那样有个中心服务器。<br><br>目前我们使用到的 Git 命令都是在本地执行，如果你想通过 Git 分享你的代码或者与其他开发人员合作。 你就需要将数据放到一台其他开发人员能够连接的服务器上。<br></p>
<p>添加远程库<br><br>要添加一个新的远程仓库，可以指定一个简单的名字，以便将来引用,命令格式如下：<br></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add [shortname] [url]</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建秘钥       -t  指定秘钥类型(默认就是rsa)  -P 可以指定密码   更详细的文档点击[]</span></span><br><span class="line">[sgsm@centos sgsm]$ ssh-keygen</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看秘钥并且把秘钥加到github的权限中</span></span><br><span class="line">[sgsm@centos sgsm]$ cat  ~/.ssh/id_rsa.pub </span><br><span class="line">ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEA22A+usIGhnk0rhH7bcPTf6SptnuS70kmIWvqloFFhI8kK1srQTSAPR9EeR5O6VEXk/qJmbBNmr/0WoqmRRIVNGnttZwt8LUySTDBntu0peo9LX4WureKaptmZAIp/VXn2cYYkpdf1H1OYDFJ9rARmmBas3tSp/FlcdSxfgcofAq19VHtXnoJjcJSnh45GTsihtgp2nihHPBtScTqo3zf+xw2A4RWF11qCEm4Dmvvg4LPuMUSQHEhDMQG/VHmNBqlbFrUJieEcO99SL2/BIfqsqmxFsl6zDrNUj3Y2jB69Wcu4UT6DpY0mjw9rSY/KhyXk8SCwWetdt8AQDycCKzGuQ== sgsm@centos</span><br></pre></td></tr></table></figure>
<p>github添加秘钥<br><br><img src="/2020/06/09/git/1.png" alt><br><br><img src="/2020/06/09/git/2.png" alt></p>
<p>为了验证是否成功，输入以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[sgsm@centos github]$ ssh -T git@github.com                         </span><br><span class="line">The authenticity of host <span class="string">'github.com (52.74.223.119)'</span> can<span class="string">'t be established.</span></span><br><span class="line"><span class="string">RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.</span></span><br><span class="line"><span class="string">Are you sure you want to continue connecting (yes/no)? yes</span></span><br><span class="line"><span class="string">Warning: Permanently added '</span>github.com,52.74.223.119<span class="string">' (RSA) to the list of known hosts.</span></span><br><span class="line"><span class="string">Hi xinlongOB/python.github.io! You'</span>ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure>



<p>克隆仓库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[sgsm@centos github]$ git <span class="built_in">clone</span>    https://github.com/xinlongOB/python.github.io.git</span><br><span class="line">Cloning into <span class="string">'python.github.io'</span>...</span><br><span class="line">remote: Enumerating objects: 46, <span class="keyword">done</span>.</span><br><span class="line">remote: Counting objects: 100% (46/46), <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (44/44), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 46 (delta 7), reused 0 (delta 0), pack-reused 0</span><br><span class="line">Unpacking objects: 100% (46/46), <span class="keyword">done</span>.</span><br><span class="line">[sgsm@centos github]$</span><br></pre></td></tr></table></figure>
<p>创建文件并且提交</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[sgsm@centos python.github.io]$ <span class="built_in">echo</span> <span class="string">"print("</span>hello world<span class="string">")"</span> &gt; print.py</span><br><span class="line">[sgsm@centos python.github.io]$ </span><br><span class="line">[sgsm@centos python.github.io]$ git add . </span><br><span class="line">[sgsm@centos python.github.io]$ git commit  -m <span class="string">"add print.py"</span></span><br><span class="line">[master 23b3cd1] add print.py</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 print.py</span><br><span class="line">[sgsm@centos python.github.io]$ </span><br><span class="line"><span class="comment"># 提交到 Github     因为这个github上面已经有origin   所以报错已存在  正常来说需要执行这一步</span></span><br><span class="line">[sgsm@centos python.github.io]$ git remote add origin   https://github.com/xinlongOB/python.github.io.git</span><br><span class="line">fatal: remote origin already exists.</span><br><span class="line"><span class="comment"># 推送到远程仓库</span></span><br><span class="line">[sgsm@centos python.github.io]$ git push  origin master</span><br><span class="line">Username <span class="keyword">for</span> <span class="string">'https://github.com'</span>: xinlongOB     <span class="comment"># 第一次需要输入账号</span></span><br><span class="line">Password <span class="keyword">for</span> <span class="string">'https://xinlongOB@github.com'</span>:      <span class="comment">#  密码</span></span><br><span class="line">Counting objects: 3, <span class="keyword">done</span>.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (2/2), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (3/3), 284 bytes | 284.00 KiB/s, <span class="keyword">done</span>.</span><br><span class="line">Total 3 (delta 1), reused 0 (delta 0)</span><br><span class="line">remote: Resolving deltas: 100% (1/1), completed with 1 <span class="built_in">local</span> object.</span><br><span class="line">To https://github.com/xinlongOB/python.github.io.git</span><br><span class="line">   e4e3a59..23b3cd1  master -&gt; master</span><br><span class="line">[sgsm@centos python.github.io]$ </span><br><span class="line"></span><br><span class="line">删除远程仓库</span><br><span class="line">```bash</span><br><span class="line">git remote rm [别名]</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote rm  origin</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>TortoiseSVN使用</title>
    <url>/2020/06/08/TortoiseSVN/</url>
    <content><![CDATA[<h2 id="部署subversion服务器"><a href="#部署subversion服务器" class="headerlink" title="部署subversion服务器"></a>部署subversion服务器</h2><p><a href="https://xinlong.youare.ink/2019/12/03/test/#4" target="_blank" rel="noopener">subversion安装部署</a></p>
<h2 id="TortoiseSVN-安装"><a href="#TortoiseSVN-安装" class="headerlink" title="TortoiseSVN 安装"></a>TortoiseSVN 安装</h2><p>下载地址：<a href="https://tortoisesvn.net/downloads.html" target="_blank" rel="noopener">https://tortoisesvn.net/downloads.html</a>, 页面里有语言包补丁的下载链接。</p>
<h2 id="TortoiseSVN检出代码"><a href="#TortoiseSVN检出代码" class="headerlink" title="TortoiseSVN检出代码"></a>TortoiseSVN检出代码</h2><p><br><img src="/2020/06/08/TortoiseSVN/5.png" alt><br><br><img src="/2020/06/08/TortoiseSVN/6.png" alt></p>
<h2 id="更新代码"><a href="#更新代码" class="headerlink" title="更新代码"></a>更新代码</h2><p><br><img src="/2020/06/08/TortoiseSVN/7.png" alt><br></p>
<h2 id="提交代码"><a href="#提交代码" class="headerlink" title="提交代码"></a>提交代码</h2><p><br><img src="/2020/06/08/TortoiseSVN/8.png" alt><br><br><img src="/2020/06/08/TortoiseSVN/9.png" alt></p>
<h2 id="切新分支"><a href="#切新分支" class="headerlink" title="切新分支"></a>切新分支</h2><p><br><img src="/2020/06/08/TortoiseSVN/10.png" alt><br><br><img src="/2020/06/08/TortoiseSVN/14.png" alt><br><br>切出后查看内容<br><br><img src="/2020/06/08/TortoiseSVN/15.png" alt><br><br>主线内容<br><br><img src="/2020/06/08/TortoiseSVN/16.png" alt></p>
<h2 id="查看提交记录"><a href="#查看提交记录" class="headerlink" title="查看提交记录"></a>查看提交记录</h2><p><br><img src="/2020/06/08/TortoiseSVN/18.png" alt><br><br><img src="/2020/06/08/TortoiseSVN/19.png" alt><br><br><img src="/2020/06/08/TortoiseSVN/20.png" alt><br><br><img src="/2020/06/08/TortoiseSVN/21.png" alt><br><br><img src="/2020/06/08/TortoiseSVN/22.png" alt><br></p>
<h2 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h2><p>一般公司都是在分支开发合并到主线，因为版本比较多所以我们公司是在主线开发合并到各个版本的分支<br><br>合并分支案例<br><br><img src="/2020/06/08/TortoiseSVN/33.png" alt><br><br><img src="/2020/06/08/TortoiseSVN/34.png" alt><br><br><img src="/2020/06/08/TortoiseSVN/35.png" alt><br><br><img src="/2020/06/08/TortoiseSVN/36.png" alt><br><br><img src="/2020/06/08/TortoiseSVN/37.png" alt><br><br><img src="/2020/06/08/TortoiseSVN/38.png" alt><br><br><img src="/2020/06/08/TortoiseSVN/39.png" alt><br><br><img src="/2020/06/08/TortoiseSVN/40.png" alt><br><br><img src="/2020/06/08/TortoiseSVN/41.png" alt><br><br><img src="/2020/06/08/TortoiseSVN/42.png" alt><br><br><img src="/2020/06/08/TortoiseSVN/43.png" alt><br><br><img src="/2020/06/08/TortoiseSVN/44.png" alt><br><br><img src="/2020/06/08/TortoiseSVN/45.png" alt></p>
<h2 id="报错解决："><a href="#报错解决：" class="headerlink" title="报错解决："></a>报错解决：</h2><p>提交报错：could not begin a transaction<br><br><img src="/2020/06/08/TortoiseSVN/1.png" alt><br><br>解决办法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span>  /data/svn/program</span><br><span class="line">sudo chown -R apache:apache  ./</span><br></pre></td></tr></table></figure>
<p>修改之前：<br><br><img src="/2020/06/08/TortoiseSVN/2.png" alt><br><br>修改之后：<br><br><img src="/2020/06/08/TortoiseSVN/3.png" alt><br><br>再次提交：<br><br><img src="/2020/06/08/TortoiseSVN/4.png" alt><br></p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>subversion</tag>
      </tags>
  </entry>
  <entry>
    <title>redis基础配置-运维篇</title>
    <url>/2020/06/06/redis/</url>
    <content><![CDATA[<h2 id="Redis-必知"><a href="#Redis-必知" class="headerlink" title="Redis 必知"></a>Redis 必知</h2><p><br>redis基本的数据结构<br><br>最最最重要的并且是最基础的知识–记不住千万别说了解redis,本人有被羞辱的案例</p>
<pre><code>string：字符串
hash：散列
list：列表
set：集合
sorted set：有序集合</code></pre><h2 id="Redis-简介"><a href="#Redis-简介" class="headerlink" title="Redis 简介"></a>Redis 简介</h2><p> Redis 是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库。<br><br> Redis 与其他 key - value 缓存产品有以下三个特点：<br></p>
<pre><code>Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。
Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。
Redis支持数据的备份，即master-slave模式的数据备份。 </code></pre><h2 id="Redis-优势"><a href="#Redis-优势" class="headerlink" title="Redis 优势"></a>Redis 优势</h2><p>性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。<br><br>丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。<br><br>原子 – Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。<br><br>丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性<br></p>
<h2 id="Linux-下安装redis"><a href="#Linux-下安装redis" class="headerlink" title="Linux 下安装redis"></a>Linux 下安装redis</h2><p><br>下载地址：<a href="http://redis.io/download，下载最新稳定版本。" target="_blank" rel="noopener">http://redis.io/download，下载最新稳定版本。</a><br></p>
<pre><code>$ wget http://download.redis.io/releases/redis-2.8.17.tar.gz
$ tar xzf redis-2.8.17.tar.gz
$ cd redis-2.8.17
$ make</code></pre><p> make完后 redis-2.8.17目录下会出现编译后的redis服务程序redis-server,还有用于测试的客户端程序redis-cli,两个程序位于安装目录 src 目录下：</p>
<p>下面启动redis服务</p>
<pre><code>$ cd src
$ ./redis-server</code></pre><p>注意这种方式启动redis 使用的是默认配置。也可以通过启动参数告诉redis使用指定配置文件使用下面命令启动。 </p>
<pre><code>$ cd src
$ ./redis-server ../redis.conf</code></pre><p> redis.conf 是一个默认的配置文件。我们可以根据需要使用自己的配置文件。<br><br>启动redis服务进程后，就可以使用测试客户端程序redis-cli和redis服务交互了。 比如：<br></p>
<pre><code>$ redis-cli -h  192.168.1.163
192.168.1.163:6379&gt; AUTH mima
OK
192.168.1.163:6379&gt; keys *</code></pre><h2 id="Redis-配置文件"><a href="#Redis-配置文件" class="headerlink" title="Redis 配置文件"></a>Redis 配置文件</h2><p>主要用到的配置项</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 绑定的IP     redis-cli 的时候需要 加-h 选项 指定ip</span></span><br><span class="line"><span class="built_in">bind</span> 192.168.1.163  </span><br><span class="line"></span><br><span class="line"><span class="comment"># redis监听的端口号</span></span><br><span class="line">port 6379        </span><br><span class="line"></span><br><span class="line"><span class="comment"># 此参数确定了TCP连接中已完成队列(完成三次握手之后)的长度， 当然此值必须不大于Linux系统定义的/proc/sys/net/core/somaxconn值，默认是511，而Linux的默认参数值是128。当系统并发量大并且客户端速度缓慢的时候，可以将这二个参数一起参考设定。该内核参数默认值一般是128，对于负载很大的服务程序来说大大的不够。一般会将它修改为2048或者更大。在/etc/sysctl.conf中添加:net.core.somaxconn = 2048，然后在终端中执行sysctl -p</span></span><br><span class="line">tcp-backlog 511</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此参数为设置客户端空闲超过timeout，服务端会断开连接，为0则服务端不会主动断开连接，不能小于0</span></span><br><span class="line">timeout 300</span><br><span class="line"></span><br><span class="line"><span class="comment"># tcp keepalive参数。如果设置不为0，就使用配置tcp的SO_KEEPALIVE值，使用keepalive有两个好处:检测挂掉的对端。降低中间设备出问题而导致网络看似连接却已经与对端端口的问题。在Linux内核中，设置了keepalive，redis会定时给对端发送ack。检测到对端关闭需要两倍的设置值</span></span><br><span class="line">tcp-keepalive 300</span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否在后台执行，yes：后台运行；no：不是后台运行</span></span><br><span class="line">daemonize yes</span><br><span class="line"></span><br><span class="line"><span class="comment"># redis进程文件路径</span></span><br><span class="line">pidfile /var/run/redis.pid</span><br><span class="line"></span><br><span class="line"><span class="comment"># 日志等级</span></span><br><span class="line">loglevel notice</span><br><span class="line"></span><br><span class="line"><span class="comment"># 日志路径</span></span><br><span class="line">logfile /data/<span class="built_in">log</span>/redis/redis-server.log</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置db库数量，默认16个库</span></span><br><span class="line">databases 16</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在900 秒内有一个键内容发生更改触发快照机制</span></span><br><span class="line">save 900 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在300 秒内有10个键内容发生更改触发快照机制</span></span><br><span class="line">save 300 10</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在10000 秒内有60个键内容发生更改触发快照机制</span></span><br><span class="line">save 60 10000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 久化到 RDB 文件时，是否压缩，"yes" 为压缩，“no” 则反之</span></span><br><span class="line">rdbcompression yes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否开启RC64校验，默认是开启</span></span><br><span class="line">rdbchecksum yes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 快照文件名</span></span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 快照文件路径</span></span><br><span class="line">dir /data/lib/redis</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果slave-serve-stale-data设置为yes(默认设置)，从库会继续响应客户端的请求。2) 如果slave-serve-stale-data设置为no，INFO,replicaOF, AUTH, PING, SHUTDOWN, REPLCONF, ROLE, CONFIG,SUBSCRIBE, UNSUBSCRIBE,PSUBSCRIBE, PUNSUBSCRIBE, PUBLISH, PUBSUB,COMMAND, POST, HOST: and LATENCY命令之外的任何请求都会返回一个错误”SYNC with master in progress”。</span></span><br><span class="line">slave-serve-stale-data yes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置Redis的Slave实例是否接受写操作，即Slave是否为只读Redis。默认值为yes</span></span><br><span class="line">slave-read-only yes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主从数据复制是否使用无硬盘复制功能。默认值为no。</span></span><br><span class="line">repl-diskless-sync no</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当启用无硬盘备份，服务器等待一段时间后才会通过套接字向从站传送RDB文件，这个等待时间是可配置的。  这一点很重要，因为一旦传送开始，就不可能再为一个新到达的从站服务。从站则要排队等待下一次RDB传送。因此服务器等待一段  时间以期更多的从站到达。延迟时间以秒为单位，默认为5秒。要关掉这一功能，只需将它设置为0秒，传送会立即启动。默认值为5</span></span><br><span class="line">repl-diskless-sync-delay 5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同步之后是否禁用从站上的TCP_NODELAY 如果你选择yes，redis会使用较少量的TCP包和带宽向从站发送数据。但这会导致在从站增加一点数据的延时。  Linux内核默认配置情况下最多40毫秒的延时。如果选择no，从站的数据延时不会那么多，但备份需要的带宽相对较多。默认情况下我们将潜在因素优化，但在高负载情况下或者在主从站都跳的情况下，把它切换为yes是个好主意。默认值为no。</span></span><br><span class="line">repl-disable-tcp-nodelay no</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当 master 不可用，Sentinel 会根据 slave 的优先级选举一个 master 。最低的优先级的 slave ，当选 master 。而配置成 0，永远不会被选举</span></span><br><span class="line">slave-priority 100</span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否开启 AOF 日志 记录 默认 redis使用的是 rdb 方式持久化，这种方式在许多应用中已经足够用了。但是 redis 如果中途宕机，会导致可能有几分钟的数据丢失</span></span><br><span class="line">appendonly no</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定本地数据库文件名，默认值为 appendonly.aof</span></span><br><span class="line">appendfilename <span class="string">"appendonly.aof"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># aof 持久化策略的配置 no 表示不执行 fsync 由操作系统保证数据同步到磁盘 ,always 表示每次写入都执行 fsync ，以保证数据同步到磁盘 ,everysec 表示每秒执行一次 fsync ，可能会导致丢失这 1s 数据。</span></span><br><span class="line">appendfsync everysec</span><br><span class="line"></span><br><span class="line"><span class="comment"># （推荐为yes） 在 aof rewrite 期间 是否对 aof 新记录的 append 暂缓使用文件同步策略 主要考虑磁盘 IO 开支和请求阻塞时间。默认为 no, 表示不暂缓新的 aof 记录仍然会被立即同步Linux 的默认fsync策略是30 秒，如果为 yes 可能丢失 30 秒数据 ，但由于yes性能较好,而且会避免出现阻塞, 因此比较推荐</span></span><br><span class="line">no-appendfsync-on-rewrite yes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当 Aof log增长超过指定百分比例时，重写 logfile设置为0表示不自动重写 Aof 日志，重写是为了使 aof 体积保持最小，而确保保存最完整的数据</span></span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line"></span><br><span class="line"><span class="comment"># # 触发 aof rewrite 的最小文件大小</span></span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line"></span><br><span class="line"><span class="comment"># aof文件可能在尾部是不完整的，当redis启动的时候，aof文件的数据被载入内存。重启可能发生在redis所在的主机操作系统宕机后，尤其在ext4文件系统没有加上data=ordered选项（redis宕机或者异常终止不会造成尾部不完整现象。）出现这种现象，可以选择让redis退出，或者导入尽可能多的数据。如果选择的是yes，当截断的aof文件被导入的时候，会自动发布一个log给客户端然后load。如果是no，用户必须手动redis-check-aof修复AOF文件才可以</span></span><br><span class="line">aof-load-truncated yes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一个lua脚本执行的最大时间，单位为ms。默认值为5000</span></span><br><span class="line">lua-time-limit 5000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只记录大于等于下边设置的值的操作。0的话，就是关闭监视。默认延迟监控功能是关闭的，如果你需要打开，也可以通过CONFIG SET命令动态设置</span></span><br><span class="line">latency-monitor-threshold 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据量小于等于hash-max-ziplist-entries的用ziplist，大于hash-max-ziplist-entries用hash</span></span><br><span class="line"><span class="built_in">hash</span>-max-ziplist-entries 512</span><br><span class="line"></span><br><span class="line"><span class="comment"># value大小小于等于hash-max-ziplist-value的用ziplist，大于hash-max-ziplist-value用hash</span></span><br><span class="line"><span class="built_in">hash</span>-max-ziplist-value 64</span><br><span class="line"></span><br><span class="line"><span class="comment">#-5:最大大小：64 KB&lt;--不建议用于正常工作负载</span></span><br><span class="line"><span class="comment">#-4:最大大小：32 KB&lt;--不推荐</span></span><br><span class="line"><span class="comment">#-3:最大大小：16 KB&lt;--可能不推荐</span></span><br><span class="line"><span class="comment">#-2:最大大小：8kb&lt;--良好</span></span><br><span class="line"><span class="comment">#-1:最大大小：4kb&lt;--良好</span></span><br><span class="line">list-max-ziplist-size -2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据量小于等于set-max-intset-entries用iniset，大于set-max-intset-entries用set</span></span><br><span class="line"><span class="built_in">set</span>-max-intset-entries 512</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据量小于等于zset-max-ziplist-entries用ziplist，大于zset-max-ziplist-entries用zset</span></span><br><span class="line">zset-max-ziplist-entries 128</span><br><span class="line"></span><br><span class="line"><span class="comment"># value大小小于等于zset-max-ziplist-value用ziplist，大于zset-max-ziplist-value用zset</span></span><br><span class="line">zset-max-ziplist-value 64</span><br><span class="line"></span><br><span class="line"><span class="comment"># rename-command：命令重命名，对于一些危险命令例如  FLUSHDB（清空数据库）　FLUSHALL（清空所有记录） CONFIG（客户端连接后可配置服务器）  EVAL (Eval 命令使用 Lua 解释器执行脚本)</span></span><br><span class="line">rename-command FLUSHALL <span class="string">""</span></span><br><span class="line">rename-command FLUSHDB <span class="string">""</span></span><br><span class="line">rename-command CONFIG <span class="string">""</span></span><br><span class="line">rename-command EVAL <span class="string">""</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># redis 认证密码</span></span><br><span class="line">requirepass GwJMMSdSHezfeMRMP34fQ0F0F</span><br></pre></td></tr></table></figure>
<h2 id="Redis-语法"><a href="#Redis-语法" class="headerlink" title="Redis 语法"></a>Redis 语法</h2><p>连接redis</p>
<pre><code>redis-cli -h host -p port -a password</code></pre><p>查看所有的键值对–一般大公司是禁止使用keys *</p>
<pre><code>192.168.1.163:6379&gt; keys *</code></pre><p>正则表达式匹配键值对</p>
<pre><code>192.168.1.163:6379&gt; keys *info*water*
1) &quot;info:&quot;
2) &quot;info:hero&quot;
3) &quot;info:serverInfo&quot;</code></pre><p>查看hash值</p>
<pre><code>192.168.1.163:6379&gt; HGETALL &quot;xxxxxx&quot;
1) &quot;1001&quot;
2) &quot;\&quot;{\\\&quot;roleInfoList\\\&quot;: xxxxx}\&quot;&quot;</code></pre><p>查看有序集合</p>
<pre><code>192.168.1.163:6379&gt; ZREVRANGE &quot;xxxxxxxx&quot; 0 10      # 0表示第一个      
1) &quot;id&quot;
192.168.1.163:6379&gt; ZREVRANGE &quot;xxxxxxxx&quot; 0 10  WITHSCORES   #  加上WITHSCORES可以打印积分
1) &quot;id&quot;
2) &quot;integral&quot;</code></pre><p>删除有序集合成员</p>
<pre><code>ZREM  key  value</code></pre><p>删除键值</p>
<pre><code>del  key</code></pre><p>修改集合</p>
<pre><code>hset keys   更改后的内容</code></pre><p>备份</p>
<pre><code>redis 192.168.1.163:6379&gt; SAVE 
OK</code></pre><h2 id="Redis迁移"><a href="#Redis迁移" class="headerlink" title="Redis迁移"></a>Redis迁移</h2><p>先备份</p>
<pre><code>[root@izm5ea99qngm2vazfs49svz ~]# redis-cli 
127.0.0.1:6379&gt;  AUTH mima      #  认证
OK
127.0.0.1:6379&gt;  SAVE         # 保存数据
OK
127.0.0.1:6379&gt;  CONFIG GET dir       # 查看保存数据位置
1) &quot;dir&quot;
2) &quot;/var/lib/redis&quot;</code></pre><p>需要先把远程服务器的redis停止  然后备份一下当前的快照 不然直接scp过去 会有问题</p>
<pre><code>cd  /var/lib/redis
mv   dump.rdb  dump.rdb.bak</code></pre><p>把快照文件发送到远程服务器</p>
<pre><code>cd  /var/lib/redis  
scp    dump.rdb   user@IP:/var/lib/redis</code></pre><p>启动redis</p>
<pre><code>sudo  redis-server   /etc/redis/redis.conf</code></pre><p>进去redis查看是否迁移成功</p>
<pre><code>[root@test ~]# redis-cli 
127.0.0.1:6379&gt;  AUTH mima  
OK
127.0.0.1:6379&gt;  keys *
1) &quot;info:&quot;
2) &quot;info:hero&quot;
3) &quot;info:serverInfo&quot;</code></pre><p>命令行执行redis语句</p>
<pre><code>redis-cli  -h  127.0.0.1  -p 6379  -a &quot;mima&quot;  del  

echo  &apos;set aaa aaaa&apos; |redis-cli -h   127.0.0.1  -a mima</code></pre><p>附一个redis批量操作的脚本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server=<span class="variable">$1</span>     <span class="comment"># 传入的第一个参数定义为server</span></span><br><span class="line">host=<span class="variable">$2</span>     <span class="comment"># 传入的第二个参数定义为host</span></span><br><span class="line"><span class="built_in">echo</span>   <span class="string">"AUTH mima  </span></span><br><span class="line"><span class="string">ZREVRANGE  chart:newbox@<span class="variable">$server</span>:6  0 -1 "</span> &gt; <span class="variable">$1</span>.txt        <span class="comment"># echo 密码和 语句到$1.txt文件</span></span><br><span class="line">cat  <span class="variable">$1</span>.txt |   redis-cli  -h  <span class="variable">$host</span>    &gt;  <span class="variable">$1_linshi</span>.txt    命令行执行redis语句   语句内容就是<span class="variable">$1</span>.txt文件中的内容   执行结果重定向到  <span class="variable">$1_linshi</span>.txt </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cat <span class="variable">$1_linshi</span>.txt   |sed  1d  &gt;  <span class="variable">$1_redis</span>.txt     <span class="comment"># 删除 $1_linshi.txt  文件的第一行</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span>   <span class="string">"AUTH mima"</span>  &gt; insert.txt      <span class="comment"># echo 密码到insert.txt文件</span></span><br><span class="line"><span class="keyword">for</span> role <span class="keyword">in</span>  `cat  <span class="variable">$1_redis</span>.txt`</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  </span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"ZADD  chart:newbox@<span class="variable">$server</span>:6  0  <span class="variable">$role</span> "</span>  &gt;&gt; insert.txt</span><br><span class="line">  </span><br><span class="line"><span class="keyword">done</span>            <span class="comment"># for循环 $1_linshi.txt 文件   添加0 到每个键值对中</span></span><br><span class="line">cat  insert.txt |   redis-cli  -h  <span class="variable">$host</span>     执行redis语句</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>kubernetes服务原理</title>
    <url>/2020/06/06/kubernetesyuanli/</url>
    <content><![CDATA[<h2 id="容器编排系统的具体任务"><a href="#容器编排系统的具体任务" class="headerlink" title="容器编排系统的具体任务"></a>容器编排系统的具体任务</h2><pre><code>服务注册和服务发现
负载均衡
配置和存储管理
健康状态监测
自动扩容、缩容、重启
0宕机部署</code></pre><h2 id="容器编排系统工具"><a href="#容器编排系统工具" class="headerlink" title="容器编排系统工具"></a>容器编排系统工具</h2><pre><code>kubernetes
docker swarm
apache mesos and marathon</code></pre><h2 id="此篇文档主要介绍kubernetes"><a href="#此篇文档主要介绍kubernetes" class="headerlink" title="此篇文档主要介绍kubernetes"></a>此篇文档主要介绍kubernetes</h2><p><br>kubernetes是一个开源的平台、自动部署伸缩、自动运维容器化应用平台，支持跨主机的集群多节点。<br></p>
<p>kubernetes集群节点由master和node以及插件组成<br><br>多个master是为了冗余<br><br>而node节点就是工作节点</p>
<h2 id="master组成部分"><a href="#master组成部分" class="headerlink" title="master组成部分"></a>master组成部分</h2><p>  API server api入口 是一个数据  负责接受用户的请求 语法没问题 放到etcd<br>  scheduler    调度器  查看那台服务器适合执行node 会一直watch apiserver上是否有新建资源<br>  <br>  controller    控制器（一直循环 也成控制循环器）  负责让调度器调用镜像启动容器，确保容器正常运行，自动重启 重启失败直接干掉  controller 会一直watch apiserver上的资源变动 如果有变动  会立即执行用户的请求 <br><br>  还有个额外的etcd  会存储各种k v 规范数据   规范是apisever定义的</p>
<h2 id="node组成部分"><a href="#node组成部分" class="headerlink" title="node组成部分"></a>node组成部分</h2><p>  kubelet 一直watch apiserver  如果需要创建容器 会去调用docker docker去调用region（镜像仓库）<br>   <br>  docker 容器  <br><br>  pod   容器外壳，一个pod中可以存在多个容器<br>   <br>  proxy  <br> </p>
<p>kubernetes 运行的核心基本单元是pod(原子单元)而不是容器</p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>docker容器是利用内核的六种名称空间技术 来实现程序运行环境的隔离<br><br>pid  网络  文件系统  ipc  user uts（域名和主机名）<br></p>
<p>docker的四种网络模型  </p>
<pre><code>封闭网络   closed
桥接网络   bridge
联盟网络 joined（两个宿主机共享network 和 ipc uts） 
共享宿主机  host</code></pre><h2 id="kubernetes常用的资源类型"><a href="#kubernetes常用的资源类型" class="headerlink" title="kubernetes常用的资源类型"></a>kubernetes常用的资源类型</h2><p><br>pod  service（服务）  namespace（名称空间） volume（存储卷）<br></p>
<h2 id="kubernetes的各种IP"><a href="#kubernetes的各种IP" class="headerlink" title="kubernetes的各种IP"></a>kubernetes的各种IP</h2><p>service（服务）  客户端访问的不是pod_ip 而是访问的service_ip 这样pod宕机后被移除，新添加的pod的ip会是新分配的<br><br>pod_ip  每一个pod都有一个虚拟ip<br><br>service_ip  通过标签选择来管理pod_ip<br><br>DNS  主要管理service_ip 如果 service被意外删除 或者其他情况无法使用  调度器会立即创建新的service_ip  dns动态获取A记录<br><br>node_ip  是节点网卡的ip</p>
<p>访问流程</p>
<pre><code>客户端访问  需要先访问service_ip  然后service_ip 访问pod组件 而pod组件是pod的管理器创建的
例如：客户端访问nginx    会先访问service_ip 然后service_ip转到nginx的pod       nginx_pod 是由pod控制器的管理创建的   
    nginx在访问tomcat的service_ip    tomcat的service_ip 在转到tomcat tomcat_pod也有一个控制器</code></pre><p>kubernetes有三种网络：</p>
<pre><code>节点网络
pod网络  每个pod都是想通的
service网络</code></pre><p>部署</p>
<p>  测试环境</p>
<pre><code>可以使用单点master节点，单etcd实例，node节点按需而定，nfs或者glusterfs等存储系统</code></pre><p>  生产环境</p>
<pre><code>高可用etcd，建立3、5或者7个节点
高可用master
    kube-apiserver 无状态，可多实例
              借助keepalived进行vip流动实现多实例冗余
              或在多实例前端通过haproxy或者nginx反代，并借助于keepalived对代理服务器进行冗余
    kubu-scheduler及kube-controller-manager各自只能有一个活动实例，但可以有多个备用
              各自自带leader选举的功能，并且默认处于启动状态
  多node主机，数量越多，冗余能力越强
  ceph，glusterfs，iscsi， fc san及各种云存储等</code></pre><p>  常用的部署环境</p>
<pre><code>iaas公有云环境：aws，gce，azure等
iaas私有云或者公有云环境，OpenStack和vsphere等
物理服务器或者独立的虚拟机等</code></pre><p>  常用的部署工具</p>
<pre><code>kubeadm(官方工具)
kops(aws专用工具)
kubespray
kontena Pharos</code></pre><p>  其他二次封装的常用发行版</p>
<pre><code>Rancher
Tectonic
Openshift(redhat公司k8s发行版)</code></pre><h2 id="安装文档"><a href="#安装文档" class="headerlink" title="安装文档"></a>安装文档</h2><p><a href="https://xinlong.youare.ink/2020/05/22/kubeadm/" target="_blank" rel="noopener">使用kubeadm安装kubernetes</a></p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>nodejs之fs模块</title>
    <url>/2020/06/03/nodejs7/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><br>nodejs中的fs模块提供了一个API，用于以接近标准POSTX函数的方式与文件系统进行交互<br><br>导入文件系统模块的语法如下：</p>
<pre><code>var fs = require(&quot;fs&quot;);</code></pre><p>所有文件系统操作都具有同步和异步的形式，异步方法中回调函数的第一个参数总是留给异常参数(execption)，如果方法成功完成，那么这个参数为null 或者 undefined</p>
<p> 在nodejs中绝大部分需要在服务器运行期反复执行业务逻辑的代码，必须使用异步代码。否则，同步代码在执行时期，服务器将停止响应，因为nodejs是单线程</p>
<p> 服务器启动时如果需要读取配置文件，或者结束时需要写入到状态文件时，可以使用同步代码。因为这些代码只在启动和结束时执行一次，不影响服务器正常运行时的异步执行</p>
<p> 异步打开文件的语法格式为：</p>
<pre><code>fs.open(path,flags[,mode],callback);</code></pre><p>  参数说明：</p>
<pre><code>path：文件的路径
flags：文件打开的行为
mode：设置文件模式(权限)，文件创建默认权限为0666(可读写)，
      mode设置文件模式(权限和粘滞位)，但仅限于创建文件的情况，在windows上只能操作写权限
callback：回调函数，带有两个参数如：callback(err.fd)</code></pre><p>  flags参数可以是以下值：</p>
<pre><code>a&apos; - 打开文件用于追加。如果文件不存在，则创建该文件。
&apos;ax&apos; - 与 &apos;a&apos; 相似，但如果路径存在则失败。
&apos;a+&apos; - 打开文件用于读取和追加。如果文件不存在，则创建该文件。
&apos;ax+&apos; - 与 &apos;a+&apos; 相似，但如果路径存在则失败。
&apos;as&apos; - 以同步模式打开文件用于追加。如果文件不存在，则创建该文件。
&apos;as+&apos; - 以同步模式打开文件用于读取和追加。如果文件不存在，则创建该文件。
&apos;r&apos; - 打开文件用于读取。如果文件不存在，则会发生异常。
&apos;r+&apos; - 打开文件用于读取和写入。如果文件不存在，则会发生异常。
&apos;rs+&apos; - 以同步模式打开文件用于读取和写入。指示操作系统绕开本地文件系统缓存。这对于在 NFS 挂载上打开文件非常有用，因为它允许跳过可能过时的本地缓存。它对 I/O 性能有非常实际的影响，因此除非需要，否则不建议使用此标志。这不会将 fs.open() 或 fsPromises.open() 转换为同步的阻塞调用。如果需要同步操作，则应使用 fs.openSync() 之类的操作。
&apos;w&apos; - 打开文件用于写入。创建文件（如果它不存在）或截断文件（如果存在）。
&apos;wx&apos; - 与 &apos;w&apos; 相似，但如果路径存在则失败。
&apos;w+&apos; - 打开文件用于读取和写入。创建文件（如果它不存在）或截断文件（如果存在）。
&apos;wx+&apos; - 与 &apos;w+&apos; 相似，但如果路径存在则失败。</code></pre><p>例如：<br><br>新建一个input.txt文件，不写任何内容，然后创建file.js文件打开input.txt文件进行读写，代码如下<br></p>
<pre><code>// 引入 fs 模块
var fs = require(&quot;fs&quot;)
// 异步打开文件
fs.open(&quot;input.txt&quot;,&quot;r+&quot;,function(err,fd){
    if (err){
        return console.error(err);
    }
    console.log(&quot;文件打开成功&quot;);
})</code></pre><p>运行结果：</p>
<pre><code>silly dog@LAPTOP-OEVDT7RG MINGW64 /e/程序代码/nodejs
$ node  fs.js
文件打开成功</code></pre><p>同步打开文件的语法格式为：</p>
<pre><code>fs.openSync(path, flags[, mode])</code></pre><p>异步关闭文件的语法格式为：</p>
<pre><code>fs.close(fd,callback);</code></pre><p>参数说明：</p>
<p>  fd：通过fs.open()方法返回的文件描述符<br>  callback：回调函数，除了可能的异常，完成回调没有其他参数</p>
<p>例如：</p>
<pre><code>// 引入 fs 模块
var fs = require(&quot;fs&quot;)
// 异步打开文件
fs.open(&quot;input.txt&quot;,&quot;r+&quot;,function(err,fd){
    if (err){
        return console.error(err);
    }
    console.log(&quot;文件打开成功&quot;);


    fs.close(fd,function (err){
        if (err){
            console.log(err);
        }
        console.log(&quot;文件关闭成功&quot;);
    });
});</code></pre><p>运行结果：</p>
<pre><code>silly dog@LAPTOP-OEVDT7RG MINGW64 /e/程序代码/nodejs
$ node  fs.js
文件打开成功
文件关闭成功</code></pre><p>使用fs.read()和fs.write()读写文件需要使用fs.open()打开文件和fs.close()关闭文件</p>
<p>使用fs.read读取文件</p>
<p>异步读取文件的语法格式为：</p>
<pre><code>fs.read(fd, buffer, offset, length, position, callback);</code></pre><p>参数说明：</p>
<pre><code>fd：通过 fs.open() 方法返回的文件描述符。
buffer：是数据写入的缓冲区。
offset：是缓冲区中开始写入的偏移量。一般它的值我们写为 0。
length：是一个整数，指定要读取的字节数。
position：指定从文件中开始读取的位置。如果 position 为 null，则从当前文件位置读取数据，并更新文件位置。
callback：回调函数，有三个参数 (err, bytesRead, buffer)。err 为错误信息，bytesRead 表示读取的字节数，buffer 为缓冲区对象。</code></pre><p>例如：<br><br>新建一个test.txt文件写入：hello world。在新建一个read.js文件，写上如下代码：<br></p>
<pre><code>// 引入 fs 模块
var fs = require(&quot;fs&quot;);
// 打开文件
fs.open(&quot;test.txt&quot;,&quot;r+&quot;,function (err,fd){
    if (err){
        return console.error(err);
    }
    console.log(&quot;文件打开成功&quot;);


// 读取文件内容
    var buf = Buffer.alloc(1024);
fs.read(fd,buf,0,buf.length,0, function(err,bytesRead,buffer){
    if (err){
        return console.error(err);
    }
    console.log(bytesRead + &quot; 字节被读取&quot;);
    if (bytesRead &gt; 0){
        console.log(buffer.slice(0,bytesRead).toString());
    }


// 关闭文件
fs.close(fd,function(err,fd){
    if (err){
        return console.error(err);
    }
    console.log(&quot;文件关闭成功&quot;);
    });
  });
});</code></pre>]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>nodejs之http模块</title>
    <url>/2020/06/02/nodejs6/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><br>nodejs提供了http模块，http模块主要用于搭建HTTP服务端和客户端，要使用HTTP服务器和客户端功能必须调用http模块<br><br>代码如下：</p>
<pre><code>// 引入http 模块
var http = require(&quot;http&quot;);</code></pre><p>创建http server<br><br>例如：<br></p>
<pre><code>// 加载 http 模块
var http = require(&quot;http&quot;);

// 创建服务器
http
  .createServer(function (request, response) {
    // 发送 HTTP 头部
    // HTTP 状态值: 200 : OK
    // 内容类型: text/plain
    response.writeHead(200, { &quot;Content-Type&quot;: &quot;text/plain&quot; });

    // 发送响应数据 &quot;Hello World&quot;
    response.end(&quot;Hello World\n&quot;);
  })
  .listen(8080);

// 终端打印如下信息
console.log(&quot;Server running at http://127.0.0.1:8080/&quot;);</code></pre><p>下面介绍下每个步骤：<br><br>创建服务器<br><br>创建服务器使用如下代码：</p>
<pre><code>http.createServer([requestListener]);</code></pre><p>该方法属于http模块，所以我们要先引入http模块，requestListener是一个请求函数，也就是我们上面所写的：</p>
<pre><code>function (request,response){
  // 函数内容
}</code></pre><p>requestListener 请求函数是一个自动添加到 request 事件的函数（request 事件每次有请求时都会触发，初期学习我们清楚有这个东西就行，不过多的去追究）。函数传递有两个参数：request 请求对象 和 response 响应对象。我们调用 request 请求对象的属性和方法就可以拿到所有 HTTP 请求的信息，我们操作 response 响应对象的方法，就可以把 HTTP 响应返回给浏览器。</p>
<p>response 对象常用的方法有：</p>
<p>  1、response.writeHead(statusCode[;statusMessage][,headers])。表示向请求发送响应头。</p>
<pre><code>参数说明：
  statusCode：状态码，是一个 3 位 HTTP 状态码，如 404 表示网页未找到，200 表示正常
  statusMessage：可选的，可以将用户可读的 statusMessage 作为第二个参数
  headers：响应头。也就是设置 Content-Type 的值，用于定义网络文件的类型和网页的编码，决定浏览器将以什么形式、什么编码读取这个文件。常用值有：（1）text/html：HTML 格式（2）text/plain：纯文本格式（3）application/x-www-form-urlencoded：数据被编码为名称/值对，这是标准的编码格式。其余的可以自行百度了解，比如 Content-Type 对照表。</code></pre><p>  比如：</p>
<pre><code>response.writeHead(200, { &quot;Content-Type&quot;: &quot;text/plain;charset=UTF-8&quot; });</code></pre><p>  注：</p>
<pre><code>注：此方法只能在消息上调用一次，并且必须在调用 `response.end()` 之前调用它。</code></pre><p>  2、response.write() 发送一块响应主体，也就是说用来给客户端发送响应数据。可以直接写文本信息，也可以写我们的 html 代码，注意要设置 Content-Type 的值。write 可以使用多次，但是最后一定要使用 end 来结束响应，否则客户端会一直等待</p>
<p>  3、response.end() 此方法向服务器发出信号，表示已发送所有响应头和主体，该服务器应该视为此消息完成。必须在每个响应上调用方法 response.end()。</p>
<p>例如：</p>
<pre><code>// 加载 http 模块
var http = require(&quot;http&quot;)

// 创建服务器

http
    .createServer(function (request,response){
        // 发送 HTTP 头部
        // HTTP 状态值：200：OK
        // 内容类型：test/html
        response.writeHead(200,{&quot;Content-Type&quot;:&quot;test/html;charset=UTF-8&quot;})

        // 发送响应数据 &apos;hello world&apos;
        response.write(&quot;ni hao&quot;);
        // 发送数据 hello world 并且字体为 h1 格式
        response.write(&quot;&lt;h1&gt;hello  world&lt;/h1&gt;&quot;);
        // 结束
        response.end();
        // 上面的三行代码也可以直接写成 response.end(&apos;hello syl &lt;h1&gt;hello world&lt;/h1&gt;&apos;);
    })
    .listen(8080);

    // 终端打印如下信息
    console.log(&quot;Server running ai http://127.0.0.1:8080/&quot;)</code></pre><p>运行结果：</p>
<pre><code>[sgsm@iZ2ze53g8gh7cdxahhcv95Z ~]$ elinks  http://127.0.0.1:8080
                                                                                                                  http://127.0.0.1:8080/ 
Hello World     </code></pre><p>request对象：</p>
<p>  1、request.url 获取请求路径，获取到的是端口号之后的那一部分路径，也就是说url都是以/开头的，判断路径处理响应<br> <br> 2、request.socket.localAddress 获取 ip 地址<br><br>  3、quest.socket.remotePort 获取源端口</p>
<p>例如：</p>
<pre><code>// 1. 创建 Server
var server = http.createServer();

// 2. 监听 request 请求事件，设置请求处理函数
server.on(&quot;request&quot;, function (req, res) {
  console.log(&quot;收到请求了，请求路径是：&quot; + req.url);
  console.log(
    &quot;请求我的客户端的地址是：&quot;,
    req.socket.remoteAddress,
    req.socket.remotePort
  );
  var url = req.url;
  res.writeHead(200, { &quot;Content-Type&quot;: &quot;text/html;charset=UTF-8&quot; });
  if (url === &quot;/&quot;) {
    res.end(&quot;&lt;h1&gt;Index page&lt;/h1&gt;&quot;);
  } else if (url === &quot;/login&quot;) {
    res.end(&quot;&lt;h1&gt;Login page&lt;/h1&gt;&quot;);
  } else {
    res.end(&quot;404 Not Found.&quot;);
  }
});

// 3. 绑定端口号，启动服务
server.listen(8080, function () {
  console.log(&quot;服务器启动成功，可以访问了。。。&quot;);
});</code></pre><p>运行结果：</p>
]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>jenkins报错--秘钥认证失败</title>
    <url>/2020/06/01/jenkinsbaocuo/</url>
    <content><![CDATA[<p>测试服更换机器后，新服务器把旧服务器ip顶替，但是秘钥不同。构建的时候报错</p>
<p>报错日志：</p>
<pre><code>Pseudo-terminal will not be allocated because stdin is not a terminal.
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!
Someone could be eavesdropping on you right now (man-in-the-middle attack)!
It is also possible that a host key has just been changed.
The fingerprint for the RSA key sent by the remote host is
SHA256:y0IuKOX1vqISQPtpFZ3zbC+DtBqRMQfd1dXj8foo3Fs.
Please contact your system administrator.
Add correct host key in /var/lib/jenkins/.ssh/known_hosts to get rid of this message.
Offending ECDSA key in /var/lib/jenkins/.ssh/known_hosts:7
Password authentication is disabled to avoid man-in-the-middle attacks.
Keyboard-interactive authentication is disabled to avoid man-in-the-middle attacks.
Permission denied (publickey,gssapi-keyex,gssapi-with-mic,password).
Build step &apos;Execute shell&apos; marked build as failure
Finished: FAILURE</code></pre><p>解决办法：</p>
<pre><code>vim  /var/lib/jenkins/.ssh/known_hosts</code></pre><p>找到对应的IP数据删除整行的秘钥</p>
<p>重新执行构建就ok了</p>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>nodejs之事件监听</title>
    <url>/2020/05/30/nodejs5/</url>
    <content><![CDATA[<h2 id="事件概述"><a href="#事件概述" class="headerlink" title="事件概述"></a>事件概述</h2><p>大多数 Node.js 核心 API 构建于惯用的异步事件驱动架构，其中某些类型的对象（又称触发器，Emitter）会触发命名事件来调用函数（又称监听器，Listener）。比如：fs.readStream 打开文件时会发出一个事件。可以通过 require(“events”); 获得 event 模块。通常，事件名采用“小驼峰式”（即第一个单词全小写，后面的单词首字母大写，其它字母小写）命名方式。</p>
<p>所有能触发事件的对象都是EventEmitter类的实例，这些对象有一个eventEmitter.on()函数，用于将一个或多个函数绑定到命名事件上。当EventEmitter对象触发一个事件时，所有绑定在该事件上的函数都会被同步地调用</p>
<p>EventEmitter类获取</p>
<pre><code>// 引入 events模块
var events = require(&quot;events&quot;)
// 创建 eventEmitter对象
var eventEmitter = new events.EventEmitter();</code></pre><h2 id="添加监听器"><a href="#添加监听器" class="headerlink" title="添加监听器"></a>添加监听器</h2><p>emitter.on(eventName,listener)<br><br>使用emitter.on(eventName,listener)方法为指定事件注册一个监听器，添加listener函数到名为eventname的事件的监听器数组的末尾，不会检查listener是否已被添加。多次调用并传入相同的eventname 与 listener会导致listener会被添加多次<br></p>
<p>  参数说明：</p>
<pre><code>eventName：事件名称，string类型。
listener：回调函数</code></pre><p>例子：</p>
<pre><code>// 引入events模块
var events = require(&quot;events&quot;);
// 创建emitter 对象
var emitter = new events.EventEmitter();
// 为 connection 事件注册一个监听器
emitter.on(&quot;connection&quot;,function(){
    console.log(&quot;已连接&quot;);
});

// 一秒后调用监视器
setTimeout(function(){
    emitter.emit(&quot;connection&quot;);
},1000)</code></pre><p>运行结果：</p>
<pre><code>$ node listener.js
已连接    // 一秒后打印已连接</code></pre><p>默认情况下，事件监听器会按照添加的顺序依次调用。emitter.prependListener() 方法可用于将事件监听器添加到监听器数组的开头。比如：</p>
<pre><code>// 引入events模块
var events = require(&quot;events&quot;);
// 创建emitter 对象
var emitter = new events.EventEmitter();
// 为 connection 事件注册一个监听器
emitter.on(&quot;connection&quot;,function(){
    console.log(&quot;我是a&quot;);
});

emitter.prependListener(&quot;connection&quot;,function(){
    console.log(&quot;我是b&quot;);
});


// 一秒后调用监视器
setTimeout(function(){
    emitter.emit(&quot;connection&quot;);
},1000)</code></pre><p>运行结果：</p>
<pre><code>$ node listener.js
我是b
我是a</code></pre><p>注：emitter.addListener(eventName, listener) 是 emitter.on(eventName, listener) 的别名。</p>
<h2 id="调用监听器"><a href="#调用监听器" class="headerlink" title="调用监听器"></a>调用监听器</h2><p><br>使用emitter.emit(eventName[, …args])按照监听器注册的顺序，同步地调用每个注册到名为eventName的事件监听器，并传入提供的参数。如果事件有注册监听返回True，否则返回false<br></p>
<p>  参数说明：</p>
<pre><code>eventName：事件名称
args：传递的参数，多个，类型为任意</code></pre><p>例如：</p>
<pre><code>// 引入event模块
var events = require(&quot;events&quot;);
// 创建emitter 对象
var emitter = new events.EventEmitter();
// 定义一个回调函数
var callback1 = function(arg1,arg2){
    console.log(&quot;print&quot;,arg1,arg2);
};

var callback2 = function(arg3,arg4){
    console.log(&quot;echo &quot;,arg3,arg4);
};

// 为 connection 事件注册监听器
emitter.on(&quot;connection&quot;,callback1)
emitter.on(&quot;connection&quot;,callback2)

// 调用监听器
emitter.emit(&quot;connection&quot;,&quot;愿你&quot;,&quot;安好&quot;)</code></pre><p>运行结果：</p>
<pre><code>$ node emit.js
print 愿你 安好
echo 愿你 安好</code></pre><h2 id="只执行一次的监听器"><a href="#只执行一次的监听器" class="headerlink" title="只执行一次的监听器"></a>只执行一次的监听器</h2><p><br>当时用eventEmitter.on(eventName,listener)注册监听器时，监听器会在每次触发命名事件时被调用。比如：<br></p>
<pre><code>// 引入 events模块
var  events = require(&quot;events&quot;);
// 创建emitter对象
var emitter = new events.EventEmitter();
// 为 connectio 事件注册一个监听器
var n = 0;
emitter.on(&quot;connection&quot;,function(){
    ++n;
    console.log(&quot;调用第&quot; + n + &quot;次&quot;);
})

// 调用监听器
emitter.emit(&quot;connection&quot;)
emitter.emit(&quot;connection&quot;)
emitter.emit(&quot;connection&quot;)
emitter.emit(&quot;connection&quot;)</code></pre><p>运行结果：</p>
<pre><code>$ node while.js
调用第1次
调用第2次
调用第3次
调用第4次</code></pre><p>使用 eventEmitter.once(eventName, listener) 可以注册最多可调用一次的监听器。当事件被触发时，监听器会被注销，然后再调用。比如：</p>
<pre><code>// 引入 events模块
var  events = require(&quot;events&quot;);
// 创建emitter对象
var emitter = new events.EventEmitter();
// 为 connectio 事件注册一个监听器
var n = 0;
emitter.once(&quot;connection&quot;,function(){    // 把emitter.on  换为 emitter.once
    ++n;
    console.log(&quot;调用第&quot; + n + &quot;次&quot;);
})

// 调用监听器
emitter.emit(&quot;connection&quot;)
emitter.emit(&quot;connection&quot;)
emitter.emit(&quot;connection&quot;)
emitter.emit(&quot;connection&quot;)</code></pre><p>运行结果：</p>
<pre><code>$ node while.js
调用第1次</code></pre><p>默认情况下，事件监听器会按照添加的顺序依次调用。emitter.prependOnceListener() 方法可用于将事件监听器添加到监听器数组的开头。用法与我们前面所学的 emitter.prependListener() 方法一致，区别在于这个方法注册的监听器最多只能调用一次</p>
<h2 id="移除监听器"><a href="#移除监听器" class="headerlink" title="移除监听器"></a>移除监听器</h2><p><br>使用emitter.removeListener(eventName.listener)移除监听器<br><br>参数说明：</p>
<pre><code>eventName：事件名称
listener：监听器也就是回调函数名称</code></pre><p>例如：</p>
<pre><code>// 引入 events 模块
var events = require(&quot;events&quot;);
// 创建 emitter 对象
var emitter = new events.EventEmitter();
// 定义一个回调函数
var callback = function () {
  console.log(&quot;syl&quot;);
};
// 为 connection 事件注册一个监听器
emitter.on(&quot;connection&quot;, callback);
// 为 connection 事件移除监听器
emitter.removeListener(&quot;connection&quot;, callback);
// 调用监听器
emitter.emit(&quot;connection&quot;);</code></pre><p>运行结果</p>
<pre><code>Administrator@WF-20180726HPZY MINGW64 /e/coding/nodejs
$ node emit.js

Administrator@WF-20180726HPZY MINGW64 /e/coding/nodejs</code></pre><p>注：removeListener() 最多只会从监听器数组中移除一个监听器。我们可以多次调用 removeListener() 的方式来一个个的移除我们需要移除掉的监听器。</p>
<p>一旦事件被触发，所有绑定到该事件的监听器都会按顺序依次调用。也就是说在事件触发之后、且最后一个监听器执行完成之前，removeListener() 或 removeAllListeners() 不会从 emit() 中移除它们。</p>
<p>例如：</p>
<pre><code>// 引入 events 模块
var events = require(&quot;events&quot;);
// 创建 emitter 对象
var emitter = new events.EventEmitter();
// 定义回调函数
var callback1 = function () {
  console.log(&quot;我是1&quot;);
  emitter.removeListener(&quot;connection&quot;, callback2);
};
var callback2 = function () {
  console.log(&quot;我是2&quot;);
};
// 为 connection 事件注册监听器
emitter.on(&quot;connection&quot;, callback1);
emitter.on(&quot;connection&quot;, callback2);
// 第一次调用监听器，callback1 移除了监听器 callback2，但它依然会被调用。触发时内部的监听器数组为 [callback1, callback2]
emitter.emit(&quot;connection&quot;);
// 第二次调用监听器，此时 callback2 已经被移除了。内部的监听器数组为 [callback1]
emitter.emit(&quot;connection&quot;);</code></pre><p>运行结果：</p>
<pre><code>$ node emit.js
我是1
我是2
我是1</code></pre><h2 id="emitter-off-eventName-listener"><a href="#emitter-off-eventName-listener" class="headerlink" title="emitter.off(eventName, listener)"></a>emitter.off(eventName, listener)</h2><p>emitter.off(eventName, listener) 是 emitter.removeListener() 的别名</p>
<h2 id="emitter-removeAllListeners-eventName"><a href="#emitter-removeAllListeners-eventName" class="headerlink" title="emitter.removeAllListeners([eventName])"></a>emitter.removeAllListeners([eventName])</h2><p>使用 emitter.removeAllListeners([eventName]) 移除全部监听器或指定的 eventName 事件的监听器<br><br>例如：<br></p>
<pre><code>// 引入events模块
var events = require(&quot;events&quot;)
// 创建emitter对象
var emitter = new  events.EventEmitter();
// 定义回调函数
var callback1 = function(){
    console.log(&quot;我是1&quot;);
};

var callback2 = function(){
    console.log(&quot;我是2&quot;);
};

// 为connection 事件注册监听器
emitter.on(&quot;connection&quot;,callback1);
emitter.on(&quot;connection&quot;,callback2);

// 移除 connection事件的所有监听器
emitter.removeAllListeners(&quot;connection&quot;);
// 调用监听器
emitter.emit(&quot;connection&quot;);</code></pre><p>运行结果：</p>
<pre><code>    silly dog@LAPTOP-OEVDT7RG MINGW64 /e/程序代码/nodejs
    $ node removealllisteners.js 

    silly dog@LAPTOP-OEVDT7RG MINGW64 /e/程序代码/nodejs

说明所有监听器已被删除</code></pre><h2 id="设置监听器最大绑定数"><a href="#设置监听器最大绑定数" class="headerlink" title="设置监听器最大绑定数"></a>设置监听器最大绑定数</h2><p><br>emitter.setMaxListeners(n)<br></p>
<p>使用 emitter.setMaxListeners(n) 设置同一事件的监听器最大绑定数。默认情况下，如果为特定事件添加了超过 10 个监听器，则 EventEmitter 会打印一个警告，这有助于我们发现内存泄露。显然实际编码中并不是所有的事件都要限制 10 个监听器。emitter.setMaxListeners() 方法可以为指定的 EventEmitter 实例修改限制。当值设为 Infinity（或 0）表示不限制监听器的数量</p>
<p>使用 emitter.listenerCount(eventName) 查看事件绑定的监听器个数</p>
<p>例：</p>
<pre><code>// 引入 events 模块
var events = require(&quot;events&quot;);
// 创建emitter 对象
var emitter = new  events.EventEmitter();
// 定义回调函数
var callback1 = function(){
    console.log(&quot;test1&quot;);
}

var callback2 = function(){
    console.log(&quot;test2&quot;);
}

// 为connection 事件注册监听器
emitter.on(&quot;connection&quot;,callback1);
emitter.on(&quot;connection&quot;,callback2);

// 查看connection 事件绑定的监听个数 赋值给num
var num = emitter.listenerCount(&quot;connection&quot;);
    console.log(num);</code></pre><p>运行结果：</p>
<pre><code>silly dog@LAPTOP-OEVDT7RG MINGW64 /e/程序代码/nodejs
$ node maxlisteners.js
2

silly dog@LAPTOP-OEVDT7RG MINGW64 /e/程序代码/nodejs</code></pre><h2 id="ERROR-事件"><a href="#ERROR-事件" class="headerlink" title="ERROR 事件"></a>ERROR 事件</h2><p><br>当EventEmitter 实例出错时，应该触发’error’事件<br></p>
<p>如果没有为’error’事件注册监听器，则当’error’事件触发时，会抛出错误、打印堆栈跟踪、并退出nodejs进程<br><br>例如：<br></p>
<pre><code>var events = require(&quot;events&quot;);
var emitter = new events.EventEmitter();
emitter.emit(&quot;error&quot;);</code></pre><p>运行结果：</p>
<pre><code>silly dog@LAPTOP-OEVDT7RG MINGW64 /e/程序代码/nodejs
$ node error.js 
events.js:201
    throw err; // Unhandled &apos;error&apos; event
    ^

Error [ERR_UNHANDLED_ERROR]: Unhandled error. (undefined)
    at EventEmitter.emit (events.js:199:17)
    at Object.&lt;anonymous&gt; (E:\程序代码\nodejs\error.js:3:9)
    at Module._compile (internal/modules/cjs/loader.js:959:30)
    at Object.Module._extensions..js (internal/modules/cjs/loader.js:995:10)
    at Module.load (internal/modules/cjs/loader.js:815:32)
    at Function.Module._load (internal/modules/cjs/loader.js:727:14)
    at Function.Module.runMain (internal/modules/cjs/loader.js:1047:10)
    at internal/main/run_main_module.js:17:11 {
code: &apos;ERR_UNHANDLED_ERROR&apos;,
context: undefined
}

silly dog@LAPTOP-OEVDT7RG MINGW64 /e/程序代码/nodejs</code></pre><p>因为没有定义函数，会报错 undefined</p>
<p>通常我们要为会触发 error 事件的对象设置监听器，避免遇到错误后整个程序崩溃。比如：</p>
<pre><code>var events = require(&quot;events&quot;);
var emitter = new events.EventEmitter();
// 设置监听器
var error = function(){
    console.error(&quot;错误信息&quot;);
}
emitter.on(&quot;connection&quot;,error)
emitter.emit(&quot;connection&quot;);</code></pre><p>或者写为箭头函数：</p>
<pre><code>// 引入 events 模块
var events = require(&quot;events&quot;);
// 创建 emitter 对象
var emitter = new events.EventEmitter();
// 设置监听器
emitter.on(&quot;error&quot;, (err) =&gt; {
console.error(&quot;错误信息&quot;);
});
emitter.emit(&quot;error&quot;);</code></pre><p>运行结果：</p>
<pre><code>silly dog@LAPTOP-OEVDT7RG MINGW64 /e/程序代码/nodejs
$ node error.js
错误信息

silly dog@LAPTOP-OEVDT7RG MINGW64 /e/程序代码/nodejs</code></pre>]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>nodejs之基础函数</title>
    <url>/2020/05/30/nodejs4/</url>
    <content><![CDATA[<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>在JavaScript中，一个函数可以作为另一个函数的参数。我们可以先定义一个函数，然后传递，也可以在传递参数的地方直接定义函数。</p>
<p>Node.js中函数的使用与Javascript类似，举例来说，你可以这样做： </p>
<pre><code>function say(word) {
  console.log(word);
}

function execute(someFunction, value) {
  someFunction(value);
}

execute(say, &quot;Hello&quot;);</code></pre><p>执行结果</p>
<pre><code>Administrator@WF-20180726HPZY MINGW64 /e/coding/nodejs
$ node test.js
word</code></pre><p> 以上代码中，我们把 say 函数作为execute函数的第一个变量进行了传递。这里传递的不是 say 的返回值，而是 say 本身！<br><br>这样一来， say 就变成了execute 中的本地变量 someFunction ，execute可以通过调用 someFunction() （带括号的形式）来使用 say 函数。<br><br>当然，因为 say 有一个变量， execute 在调用 someFunction 时可以传递这样一个变量。 </p>
<h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p><br>我们可以把一个函数作为变量传递，但是我们不一样要绕这个”先定义，在传递”的圈子，我们可以直接在另一个函数的括号中定义和传递这个参数：<br></p>
<pre><code>function execute(someFunction,value){
    someFunction(value);
}
execute(function(word){console.log(word)},&quot;hello&quot;)</code></pre><p>运行结果：</p>
<pre><code>$ node test.js
hello</code></pre><p> 我们在 execute 接受第一个参数的地方直接定义了我们准备传递给 execute 的函数。用这种方式，我们甚至不用给这个函数起名字，这也是为什么它被叫做匿名函数 。 </p>
<h2 id="导出函数"><a href="#导出函数" class="headerlink" title="导出函数"></a>导出函数</h2><pre><code>function say(word){
      console.log(&quot;word&quot;);
  }

  exports.say = say;</code></pre><p>接收函数</p>
<pre><code>var test = require(&quot;./test.js&quot;)

test.say();</code></pre><p>执行结果</p>
<pre><code>$ node a.js
word</code></pre>]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>nodejs模块</title>
    <url>/2020/05/29/nodejs3/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><br>包用于管理多个模块及依赖关系，可以对多个模块进行封装，包的根目录必须包含package.jsonwenjian，package.json文件是commonjs规范用于描述包的文件，符合commonjs规范的package.json文件一般包含以下字段：<br><br>  1、name：包名。包名是唯一的，只能包含小写字母、数字和下划线<br>  2、version：包版本号<br>  3、description：包说明<br>  4、keywords：关键字数组，用于搜索<br>  5、homepage：项目主页<br>  6、bugs：提交bug的地址<br>  7、license：许可证<br>  8、maintainers：维护者数组<br>  9、contribution：贡献者数组<br>  10、repositories：项目仓库托管地址数组<br>  11、dependencies：包依赖</p>
<p>下面是一个package.json示例：</p>
<pre><code>{
  &quot;name&quot;: &quot;shiyanlou&quot;,
  &quot;description&quot;: &quot;Shiyanlou test package.&quot;,
  &quot;version&quot;: &quot;0.1.0&quot;,
  &quot;keywords&quot;: [&quot;shiyanlou&quot;, &quot;nodejs&quot;],
  &quot;maintainers&quot;: [
    {
      &quot;name&quot;: &quot;test&quot;,
      &quot;email&quot;: &quot;test@shiyanlou.com&quot;
    }
  ],
  &quot;contributors&quot;: [
    {
      &quot;name&quot;: &quot;test&quot;,
      &quot;web&quot;: &quot;http://www.shiyanlou.com/&quot;
    }
  ],
  &quot;bugs&quot;: {
    &quot;mail&quot;: &quot;test@shiyanlou.com&quot;,
    &quot;web&quot;: &quot;http://www.shiyanlou.com/&quot;
  },
  &quot;licenses&quot;: [
    {
      &quot;type&quot;: &quot;Apache License v2&quot;,
      &quot;url&quot;: &quot;http://www.apache.org/licenses/apache2.html&quot;
    }
  ],
  &quot;repositories&quot;: [
    {
      &quot;type&quot;: &quot;git&quot;,
      &quot;url&quot;: &quot;http://github.com/test/test.git&quot;
    }
  ],
  &quot;dependencies&quot;: {
    &quot;webkit&quot;: &quot;1.2&quot;,
    &quot;ssl&quot;: {
      &quot;gnutls&quot;: [&quot;1.0&quot;, &quot;2.0&quot;],
      &quot;openssl&quot;: &quot;0.9.8&quot;
    }
  }
}</code></pre><p>注：package.json 文件可以自己手动编辑，还可以通过 npm init 命令进行生成。你可以自己尝试在终端中输入 npm init 命令来生成一个包含 package.json 文件的包。直接输入 npm init –yes 跳过回答问题步骤，直接生成默认值的 package.json 文件。此外，我们在 github 上传自己项目的时候，通常是不会把 node_modules 这个文件夹传上去的（太大了），只需要有 package.json 就能通过 npm install 命令安装所有依赖</p>
<pre><code>npm init --yes</code></pre><p>执行结果</p>
<pre><code>Wrote to E:\程序代码\nodejs\package.json:

{
  &quot;name&quot;: &quot;nodejs&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;scripts&quot;: {
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;
  },
  &quot;keywords&quot;: [],
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;ISC&quot;
}</code></pre><p>注：执行init的文件夹名称必须要符合要求不可以包含中文以及特殊字符</p>
<h2 id="包操作"><a href="#包操作" class="headerlink" title="包操作"></a>包操作</h2><p>通过命令npm  install  xxx来安装包。比如：<br><br>安装包<br></p>
<pre><code>npm install  express</code></pre><p>更新包</p>
<pre><code>npm update  express</code></pre><p>删除包</p>
<pre><code>npm  uninstall express</code></pre><p>搜索包</p>
<pre><code>npm search express</code></pre><p>注：安装包的时候指定版本使用@  例如： npm install <a href="mailto:pm2@2.8.0">pm2@2.8.0</a></p>
<p>在JavaScripts中，我们通常把 JavaScript 代码分为几个 js 文件，然后在浏览器中将这些 js 文件合并运行，但是在 Node.js 中，是通过以模块为单位来划分所有功能的。每一个模块为一个 js 文件，每一个模块中定义的全局变量和函数的作用范围也被限定在这个模块之内，只有使用 exports 对象才能传递到外部使用。Node.js 官方提供了很多模块，这些模块分别实现了一种功能，如操作文件及文件系统的模块 fs，构建 http 服务的模块 http，处理文件路径的模块 path 等。当然我们也可以自己编写模块。</p>
<p>模块的使用<br><br>在nodejs创建模块很简单，比如我们创建一个myMoudule.js的文件<br></p>
<pre><code>function foo(){
  console.log(&quot;hello world&quot;)
}</code></pre><p>这样就创建好了一个模块，但是别的模块如何来访问它呢？我们使用 module.exports 来导出它。也就是说把 myModule.js 的代码改写成下面这样：</p>
<pre><code>function foo(){
  console.log(&quot;hello world&quot;)
}
module.exports.foo = foo;</code></pre><p>最后我们在创建一个index.js的文件，使用require()函数来访问上面的模块。输入一下代码：</p>
<pre><code>var hello = require(&quot;./myModule.js&quot;);
hello.foo();</code></pre><p>运行结果：</p>
<pre><code>$ node myModule.js 


$ node index.js
hello world</code></pre><p>注：require() 加载模块，以 ‘/‘ 为前缀的模块是文件的绝对路径。’./‘ 为前缀的模块是相对于调用 require() 的文件的，上面的例子中 index.js 和 myModule.js 是在同一个目录下（project 目录）。当没有以 ‘/‘、’./‘ 或 ‘../‘ 开头来表示文件时，这个模块必须是一个核心模块或加载自 node_modules 目录。如果给定的路径不存在，则 require() 会抛出一个 code 属性为 ‘MODULE_NOT_FOUND’ 的 Error。</p>
<h2 id="核心模块"><a href="#核心模块" class="headerlink" title="核心模块"></a>核心模块</h2><p><br>核心模块定义在nodejs源代码的lib/ 目录下。require()总是会优先加载核心模块。例如：require(‘http’)始终返回内置的HTTP模块，即使有同名文件<br></p>
<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p><br>当循环调用require()时，一个模块可能在未完成执行时被返还。比如：<br></p>
<p>a.js 的代码为：</p>
<pre><code>console.log(&quot;a 开始&quot;);
exports.done = false;
var b = require(&quot;./b.js&quot;);
console.log(&quot;在 a 中，b.done = %j&quot;, b.done);
exports.done = true;
console.log(&quot;a 结束&quot;);</code></pre><p>b.js 的代码为：</p>
<pre><code>console.log(&quot;b 开始&quot;);
exports.done = false;
var a = require(&quot;./a.js&quot;);
console.log(&quot;在 b 中，a.done = %j&quot;, a.done);
exports.done = true;
console.log(&quot;b 结束&quot;);</code></pre><p>main.js 的代码为：</p>
<pre><code>console.log(&quot;main 开始&quot;);
var a = require(&quot;./a.js&quot;);
var b = require(&quot;./b.js&quot;);
console.log(&quot;在 main 中，a.done=%j，b.done=%j&quot;, a.done, b.done);</code></pre><p>运行效果为：</p>
<pre><code>silly dog@LAPTOP-OEVDT7RG MINGW64 /e/程序代码/nodejs
$ node main.js
main 开始
a 开始
b 开始
在 b 中，a.done = false
b 结束
在a 中,b.done = true
a 结束
在 main 中，a.done=true，b.done=true

silly dog@LAPTOP-OEVDT7RG MINGW64 /e/程序代码/nodejs</code></pre><p>也就是说当 main.js 加载 a.js 时，a.js 又加载 b.js。此时，b.js 会尝试去加载 a.js。为了防止无限的循环，会返回一个 a.js 的 exports 对象的未完成的副本给 b.js 模块。然后 b.js 完成加载，并将 exports 对象提供给 a.js 模块。</p>
<p>module.exports 和 exports 的区别<br><br>我们发现每次导出接口成员的时候都通过module.exports.xxx = xxx 的方式很麻烦，点儿的太多了。所以，nodejs为了简化你的操作，专门提供了一个变量：exports 等于 module.exports。也就是说在模块中还有这么一句代码<br></p>
<pre><code>var exports = module.exports;</code></pre><p>我们前面案例中的代码也就可以简写了：</p>
<pre><code>module.exports.foo = foo;
exports.foo = foo; // 这两行代码效果是一样的</code></pre><p>但是需要注意的是：就像任何变量，如果一个新的值被赋值给 exports，它就不再绑定到 module.exports。我们具体来看个例子：</p>
<p>a.js 的代码:</p>
<pre><code>console.log(module.exports === exports);</code></pre><p>运行结果</p>
<pre><code>silly dog@LAPTOP-OEVDT7RG MINGW64 /e/程序代码/nodejs
$ node 1.js
true

silly dog@LAPTOP-OEVDT7RG MINGW64 /e/程序代码/nodejs</code></pre><p>两者一致，说明我们可以用任意一个来导出内部成员</p>
<p>b.js 的代码：</p>
<pre><code>exports = {
  a: 3,
};
console.log(exports);
console.log(module.exports);
console.log(exports === module.exports);</code></pre><p>运行结果</p>
<pre><code>silly dog@LAPTOP-OEVDT7RG MINGW64 /e/程序代码/nodejs
$ node 1.js
{ a: 3 }
{}
false

silly dog@LAPTOP-OEVDT7RG MINGW64 /e/程序代码/nodejs</code></pre><p>也就是说给 exports 赋值会断开和 module.exports 之间的引用，同样的给 module.exports 重新赋值也会断开它们之间的引用。但是最终导出的是 module.exports，在上面的例子中我们另外一个文件来用 require() 加载 b.js 只会得到 {} 而不是 {a:3}。</p>
<p>总结：require() 得到的是 module.exports 导出的值，导出多个成员可以用 module.exports 和 exports，导出单个成员只能用 module.exports。如果你实在不好区分，那就全部都使用 module.exports 也是没问题的。</p>
]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js 创建第一个应用</title>
    <url>/2020/05/28/nodejs2/</url>
    <content><![CDATA[<p>  1、引入 required 模块：使用 required 指令来载入 Node.js 模块。<br>  2、创建服务器：服务器可以监听客户端的请求，类似于 Apache、Nginx 等 HTTP 服务器。<br>  3、接受请求与响应请求。</p>
<p>新建一个名为 server.js 的文件</p>
<pre><code>var http = require(&quot;http&quot;); // 加载 http 模块，并将实例化的 HTTP 赋值给变量 http

http
  .createServer(function (request, response) {
    // 发送 HTTP 头部
    // HTTP 状态值: 200 : OK
    // 内容类型: text/plain
    response.writeHead(200, { &quot;Content-Type&quot;: &quot;text/plain&quot; });

    response.end(&quot;Hello World\n&quot;); // 发送响应数据 &quot;Hello World&quot;
  })
  .listen(8080);

// 终端打印如下信息
console.log(&quot;Server running at http://127.0.0.1:8080/&quot;);</code></pre><p>以上代码我们完成了一个可以工作的 HTTP 服务器。本地计算机使用 node server.js 命令后，直接在浏览器中访问 <a href="http://127.0.0.1:8888/，你会看到一个写着" target="_blank" rel="noopener">http://127.0.0.1:8888/，你会看到一个写着</a> “Hello World”的网页</p>
<p>由于我的环境部署在centos系统上，可以直接使用elinks访问，访问结果</p>
<pre><code>[sgsm@iZ2ze53g8gh7cdxahhcv95Z ~]$ elinks  http://127.0.0.1:8080
                                                                                                                  http://127.0.0.1:8080/ 
Hello World     </code></pre>]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>初学nodejs</title>
    <url>/2020/05/28/nodejs1/</url>
    <content><![CDATA[<h2 id="Node-js-概述"><a href="#Node-js-概述" class="headerlink" title="Node.js 概述"></a>Node.js 概述</h2><p>Node.js 是一个能够在服务器端运行 JavaScript 的开放源代码、跨平台 JavaScript 运行环境。Node.js 由 Node.js 基金会持有和维护，并与 Linux 基金会有合作关系。Node.js 采用 Google 开发的 V8 运行代码，使用事件驱动、非阻塞和异步输入输出模型等技术来提高性能，可优化应用程序的传输量和规模。这些技术通常用于数据密集的即时应用程序。</p>
<p>Node.js 大部分基本模块都用 JavaScript 语言编写。在 Node.js 出现之前，JavaScript 通常作为客户端程序设计语言使用，以 JavaScript 写出的程序常在用户的浏览器上运行。Node.js 的出现使 JavaScript 也能用于服务端编程。Node.js 含有一系列内置模块，使得程序可以脱离 Apache HTTP Server 或 IIS，作为独立服务器运行。</p>
<p>注：定义来自维基百科。</p>
<h2 id="Node-js-特点"><a href="#Node-js-特点" class="headerlink" title="Node.js 特点"></a>Node.js 特点</h2><p>  1、它是一个 JavaScript 运行环境。<br>  <br>2、依赖于 Chrome V8 引擎进行代码解释。<br><br>  3、事件驱动：在 Node.js 中，客户端请求建立连接，提交数据等行为，会触发相应的事件。Node.js 在一个时刻，只能执行一个事件回调函数，但是在执行一个事件回调函数的中途，可以转而处理其他事件，然后返回继续执行原事件的回调函数。<br>  <br>4、非阻塞 I/O：Node.js 中采用了非阻塞型 I/O 机制，在执行了访问数据库的代码之后，将立即转而执行其后面的代码，把数据库返回结果的处理代码放在回调函数中，从而提高了程序的执行效率。<br><br>  5、轻量可伸缩，适用于实时数据交互应用。<br>  <br>6、单线程：好处是减少内存开销，不用像多线程编程那样处处在意状态同步的问题。缺点是错误会引起整个应用的退出。<br></p>
<h2 id="Node-js-适用场景"><a href="#Node-js-适用场景" class="headerlink" title="Node.js 适用场景"></a>Node.js 适用场景</h2><p>我们从 Node.js 的特点中可以知道 Node.js 擅长处理 I/O，不善于计算（单线程的缺点），因此 Node.js 适用于：当应用程序需要处理大量并发的 I/O，而在向客户端发出响应之前，应用程序内部并不需要进行非常复杂的处理的时候，Node.js 也非常适合与 Web socket 配合，开发长连接的实时交互应用程序。比如：聊天室，博客系统，考试系统等。</p>
<h2 id="NPM介绍"><a href="#NPM介绍" class="headerlink" title="NPM介绍"></a>NPM介绍</h2><p>npm是随同nodejs一起安装的包管理工具</p>
<p>在中断中查看系统nodejs的版本：</p>
<pre><code>node -v</code></pre><p>查看系统中npm版本</p>
<pre><code>npm  -v</code></pre><h2 id="启动node终端"><a href="#启动node终端" class="headerlink" title="启动node终端"></a>启动node终端</h2><p><br>类似于python的终端，启动node终端直接输入node</p>
<pre><code>node</code></pre><p>基础的计算</p>
<pre><code>&gt; 1 + 1
2
&gt; 2 * 2
4
&gt; 6 / 2
3
&gt; 2+(8*3)-10
16
&gt; </code></pre><p>多行表达式</p>
<pre><code>&gt; for(var i=0; i &lt; 8 ; i++){
... console.log(i);
... }
0
1
2
3
4
5
6
7
undefined
&gt; </code></pre><p>三个点的符号是系统自动生成的，回车换行后即可。Node.js 会自动检测是否为连续的表达式。</p>
<p>下划线变量 – 可以使用下划线（_）获取上一个表达式的运算结果：</p>
<pre><code>&gt; var a = 10 ; var b = 20 ; a + b;
30
&gt; var num = _;
undefined
&gt; console.log(num)
30
undefined
&gt; </code></pre><p>REPL 常用命令</p>
<pre><code>Ctrl + C - 退出当前终端。
Ctrl + C - 连续按两次退出 Node REPL。
Ctrl + D - 退出 Node REPL。
向上/向下键 - 查看输入的历史命令</code></pre><p>运行 JavaScript 文件</p>
<p>新建两个 JavaScript 文件名为为 test.j写下如下代码：</p>
<p>test.js 中的代码：</p>
<pre><code>console.log(&quot;hello world&quot;);</code></pre><p>运行结果</p>
<pre><code>[sgsm@localhost nodejs]$ node  test.js 
hello world</code></pre><h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><p>按照 ECMAScript 的定义，满足以下条件的变量是全局变量：</p>
<pre><code>在最外层定义的变量。
全局对象的属性。
隐式定义的变量（未定义直接赋值的变量）。</code></pre><p>注：当你定义一个全局变量的时候，这个变量同时也会成为全局对象的属性，反之亦然。在 Node.js 中你不可能在最外层定义变量，因为所有用户代码都是属于当前模块的，而模块本身不是最外层上下文。定义变量一定要使用 var 关键字，因为全局变量会污染命名空间。</p>
<p>下面介绍一些常用的全局变量和全局函数：</p>
<p>  __filename 表示当前正在执行的脚本的文件名。它将输出文件所在位置的绝对路径，且和命令行参数所指定的文件名不一定相同。如果在模块中，返回的值是模块文件的路径。比如创建一个叫 fnTest.js 的文件，输入以下代码：</p>
<pre><code>console.log(__filename);</code></pre><p>  运行结果</p>
<pre><code>[sgsm@bogon nodejs]$ node fnTest.js
/home/sgsm/nodejs/fnTest.js</code></pre><p>  __dirname 表示当前执行脚本所在的目录。比如创建一个 dnTest.js 的文件，输入以下代码：</p>
<pre><code>console.log(__dirname);</code></pre><p>  运行结果</p>
<pre><code>[sgsm@bogon nodejs]$ node dnTest.js 
/home/sgsm/nodejs</code></pre><p>  setTimeout(cb, ms) 全局函数在指定的毫秒（ms）数后执行指定函数（cb），只执行一次函数。比如创建一个 st.js 的文件，输入以下代码：</p>
<pre><code>function foo() {
  console.log(&quot;Hello, syl!&quot;);
}
// 三秒后执行以上函数
setTimeout(foo, 3000);</code></pre><p>  运行结果</p>
<pre><code>[sgsm@bogon nodejs]$ node  st.js 
Hello, syl!
[sgsm@bogon nodejs]$</code></pre><p>  clearTimeout(t) 用于停止一个之前通过 setTimeout() 创建的定时器。参数 t 是通过 setTimeout() 函数创建的定时器。比如清除上面案例的定时器：</p>
<pre><code>function foo() {
  console.log(&quot;Hello, syl!&quot;);
}
// 三秒后执行以上函数
var t = setTimeout(foo, 3000);
// 清除定时器
clearTimeout(t);</code></pre><p>  运行结果</p>
<pre><code>[sgsm@bogon nodejs]$ node  st.js 
[sgsm@bogon nodejs]$ </code></pre><p>  setInterval(cb, ms) 与 setTimeout(cb, ms) 类似，不同的是这个方法会不停的执行函数。直到 clearInterval() 被调用或窗口被关闭，也可以按 Ctrl + C 停止。比如创建一个 sI.js 的文件，输入以下代码：</p>
<pre><code>function foo() {
  console.log(&quot;Hello, syl!&quot;);
}
// 三秒后执行以上函数
var t = setInterval(foo, 3000);
// 清除定时器
clearInterval(t);</code></pre><p>  运行结果</p>
<pre><code>[sgsm@bogon nodejs]$ node  st.js 
[sgsm@bogon nodejs]$ </code></pre><p>  如果不加clearInterval的运行结果</p>
<pre><code>[sgsm@iZ2ze53g8gh7cdxahhcv95Z nodejs]$ node st.js 
Hello, syl!
Hello, syl!
Hello, syl!</code></pre><p>  console.log() 是个全局函数用于进行标准输出流的输出，即在控制台中显示一行字符串，和 JavaScript 中的使用一样</p>
]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>centos7设置python3环境</title>
    <url>/2020/05/26/python3huanjing/</url>
    <content><![CDATA[<h2 id="配置yum源-使用阿里云的镜像"><a href="#配置yum源-使用阿里云的镜像" class="headerlink" title="配置yum源-使用阿里云的镜像"></a>配置yum源-使用阿里云的镜像</h2><pre><code>sudo  wget http://mirrors.aliyun.com/repo/Centos-7.repo
sudo  wget http://mirrors.aliyun.com/repo/epel-7.repo
yum clean  all</code></pre><p>安装依赖工具包</p>
<pre><code>sudo  yum -y install zlib-devel bzip2-devel openssl-devel openssl-static ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel libffi-devel lzma gcc</code></pre><h2 id="下载python3-7安装包"><a href="#下载python3-7安装包" class="headerlink" title="下载python3.7安装包"></a>下载python3.7安装包</h2><pre><code>cd /opt/
sudo   wget https://www.python.org/ftp/python/3.7.0/Python-3.7.0.tar.xz</code></pre><p>解压–&gt;配置–&gt;编译–&gt;安装</p>
<pre><code>sudo tar xf  Python-3.7.0.tar.xz    -C /usr/local/
cd  /usr/local/Python-3.7.0/
sudo  ./configure --prefix=/usr/local/sbin/python-3.7
sudo   make &amp;&amp; sudo  make install</code></pre><p>  安装成功会打印</p>
<pre><code>Collecting setuptools
Collecting pip
Installing collected packages: setuptools, pip
Successfully installed pip-10.0.1 setuptools-39.0.1</code></pre><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><pre><code>[sgsm@bogon Python-3.7.0]$ /usr/local/sbin/python-3.7/bin/python3
Python 3.7.0 (default, Jun  3 2020, 23:49:44) 
[GCC 4.8.5 20150623 (Red Hat 4.8.5-39)] on linux
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt; exit()</code></pre><h2 id="创建软连接"><a href="#创建软连接" class="headerlink" title="创建软连接"></a>创建软连接</h2><p><br>查看目前的链接文件<br></p>
<pre><code>[sgsm@bogon Python-3.7.0]$ ll /usr/bin/ |grep python
lrwxrwxrwx.   1 root root           7 4月  13 2017 python -&gt; python2
lrwxrwxrwx.   1 root root           9 4月  13 2017 python2 -&gt; python2.7
-rwxr-xr-x.   1 root root        7136 11月  6 2016 python2.7
-rwxr-xr-x.   1 root root        1835 11月  6 2016 python2.7-config
lrwxrwxrwx.   1 root root          16 4月  13 2017 python2-config -&gt; python2.7-config
lrwxrwxrwx.   1 root root          14 4月  13 2017 python-config -&gt; python2-config</code></pre><p>删除原来的连接文件</p>
<pre><code>sudo rm -rf /usr/bin/python</code></pre><p>创建新的连接文件</p>
<pre><code>sudo  ln -s /usr/local/sbin/python-3.7/bin/python3   /usr/bin/python</code></pre><p>查看现在的版本</p>
<pre><code>[sgsm@bogon Python-3.7.0]$ python -V
Python 3.7.0</code></pre><h2 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h2><p><br>修改完python默认版本之后，会存不能执行yum命令，需要做一些修改，如下<br></p>
<pre><code> 将/usr/bin/yum的顶部的：

!/usr/bin/python  改成  !/usr/bin/python2.7 

将/usr/libexec/urlgrabber-ext-down的顶部的：

/usr/bin/python  改为   /usr/bin/python2.7

将/usr/bin/yum-config-manager的顶部的

#!/usr/bin/python 改为 #!/usr/bin/python2.7 </code></pre><p>最后将pip指向到python3.7</p>
<pre><code>[sgsm@bogon Python-3.7.0]$ sudo ln -s /usr/local/sbin/python-3.7/bin/pip3 /usr/bin/pip 
[sgsm@bogon Python-3.7.0]$ 
[sgsm@bogon Python-3.7.0]$ pip -v
pip 10.0.1 from /usr/local/sbin/python-3.7/lib/python3.7/site-packages/pip (python 3.7)</code></pre>]]></content>
      <categories>
        <category>运维</category>
        <category>开发</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>centos下清除记录的svn用户名和密码</title>
    <url>/2020/05/26/svn-remove-passwd/</url>
    <content><![CDATA[<h2 id="centos下清除记录的svn用户名和密码"><a href="#centos下清除记录的svn用户名和密码" class="headerlink" title="centos下清除记录的svn用户名和密码"></a>centos下清除记录的svn用户名和密码</h2><p><br>由于公司人员的变动，离职人员的svn账号也会被删除，使用之前账号检出的代码执行svn update的时候会显示报错<br></p>
<pre><code>svn: E210005: Unable to connect to a repository at URL &apos;svn://xxx&apos;
svn: E210005: No repository found in &apos;svn://xxx&apos;</code></pre><p>是因为检出代码的是提示是否保存明文密码然后用户选择的yes</p>
<p><br>解决办法<br><br>linux下删除~/.subversion/auth即可清除之前的用户名和密码：</p>
<pre><code>rm -rf ~/.subversion/auth</code></pre><p>以后再操作svn会提示你输入root密码以及svn用户名和密码，这样就可以输入正常的账号密码了</p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>subversion</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础之字符串</title>
    <url>/2020/05/26/python-1/</url>
    <content><![CDATA[<h2 id="print函数"><a href="#print函数" class="headerlink" title="print函数"></a>print函数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">'hello world!'</span>)</span><br><span class="line">	print(<span class="string">'hello'</span>, <span class="string">'world!'</span>)  <span class="comment"># 逗号自动添加默认的分隔符：空格</span></span><br><span class="line">	print(<span class="string">'hello'</span> + <span class="string">'world!'</span>)  <span class="comment"># 加号表示字符拼接</span></span><br><span class="line">	print(<span class="string">'hello'</span>, <span class="string">'world'</span>, sep=<span class="string">'***'</span>)  <span class="comment"># 单词间用***分隔</span></span><br><span class="line">	print(<span class="string">'#'</span> * <span class="number">50</span>)  <span class="comment"># *号表示重复50遍</span></span><br><span class="line">	print(<span class="string">'how are you?'</span>, end=<span class="string">''</span>) <span class="comment"># 默认print会打印回车，end=''表示不要回车</span></span><br></pre></td></tr></table></figure>

<h2 id="双引号和单引号的作用"><a href="#双引号和单引号的作用" class="headerlink" title="双引号和单引号的作用"></a>双引号和单引号的作用</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str = <span class="string">"我是谁"</span></span><br><span class="line">print(str)</span><br><span class="line"></span><br><span class="line">str1 = <span class="string">'我是"谁"'</span></span><br><span class="line">print(str1)</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<pre><code>D:\python练习\venv\Scripts\python.exe E:/程序代码/hexo/test.py
我是谁
我是&quot;谁&quot;

进程已结束，退出代码 0</code></pre><h2 id="从字符串中提取字符"><a href="#从字符串中提取字符" class="headerlink" title="从字符串中提取字符"></a>从字符串中提取字符</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str = <span class="string">"hello python"</span></span><br><span class="line"><span class="comment">##提取里面的y</span></span><br><span class="line">print(str[<span class="number">7</span>])</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\python练习\venv\Scripts\python.exe E:/程序代码/hexo/test.py
y

进程已结束，退出代码 0</code></pre><h2 id="循环遍历字符串中的每一个字符"><a href="#循环遍历字符串中的每一个字符" class="headerlink" title="循环遍历字符串中的每一个字符"></a>循环遍历字符串中的每一个字符</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str = <span class="string">"hello"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> str:</span><br><span class="line">    print(c)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\python练习\venv\Scripts\python.exe E:/程序代码/hexo/test.py
h
e
l
l
o

进程已结束，退出代码 0</code></pre><h2 id="统计字符串长度"><a href="#统计字符串长度" class="headerlink" title="统计字符串长度"></a>统计字符串长度</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str = <span class="string">"hello world"</span></span><br><span class="line">print(len(str))</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\python练习\venv\Scripts\python.exe E:/程序代码/hexo/test.py
11

进程已结束，退出代码 0</code></pre><h2 id="统计一个字符在字符串出现的次数-如果不存在不会报错-会显示出现0次"><a href="#统计一个字符在字符串出现的次数-如果不存在不会报错-会显示出现0次" class="headerlink" title="统计一个字符在字符串出现的次数(如果不存在不会报错,会显示出现0次)"></a>统计一个字符在字符串出现的次数(如果不存在不会报错,会显示出现0次)</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str = <span class="string">"hello world"</span></span><br><span class="line"><span class="comment"># 查看字符"l"  在字符串中出现的次数</span></span><br><span class="line">print(str.count(<span class="string">"l"</span>))</span><br><span class="line"><span class="comment"># 如果不存在则显示0次</span></span><br><span class="line">print(str.count(<span class="string">"a"</span>))</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\python练习\venv\Scripts\python.exe E:/程序代码/hexo/test.py
3
0

进程已结束，退出代码 0</code></pre><h2 id="取出索引-如果不存在则报错"><a href="#取出索引-如果不存在则报错" class="headerlink" title="取出索引(如果不存在则报错)"></a>取出索引(如果不存在则报错)</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str = <span class="string">"hello world"</span></span><br><span class="line">print(str.index(<span class="string">"d"</span>))</span><br><span class="line">print(str.index(<span class="string">"K"</span>))</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\python练习\venv\Scripts\python.exe E:/程序代码/hexo/test.py
10
Traceback (most recent call last):
  File &quot;E:/程序代码/hexo/test.py&quot;, line 4, in &lt;module&gt;
    print(str.index(&quot;K&quot;))
ValueError: substring not found

进程已结束，退出代码 1</code></pre><h2 id="字符串操作–判断类型"><a href="#字符串操作–判断类型" class="headerlink" title="字符串操作–判断类型"></a>字符串操作–判断类型</h2><p>判断字符串中是否只包含空格,如果只包含空格会显示True,否则打印false (\t \n \r都属于空格)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">space_str = <span class="string">" \t \n \r"</span></span><br><span class="line">print(space_str.isspace())</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\python练习\venv\Scripts\python.exe E:/程序代码/hexo/test.py
True

进程已结束，退出代码 0</code></pre><p>判断字符串至少有一个字符并且所有字符都为字母或数字则返回True   （有一个空格或者符号都返还false）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">alnum = <span class="string">"skill2"</span></span><br><span class="line">print(alnum.isalnum())</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\python练习\venv\Scripts\python.exe E:/程序代码/hexo/test.py
True

进程已结束，退出代码 0</code></pre><p>判断字符串至少有一个字符并且所有字符都为字母则返回True   （有一个空格、数字或者符号都返还false）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">alpha = <span class="string">"string"</span></span><br><span class="line">print(alpha.isalpha())</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\python练习\venv\Scripts\python.exe E:/程序代码/hexo/test.py
True

进程已结束，退出代码 0</code></pre><p>判断字符串只包含数字则返还True</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">digit = <span class="string">"942868591"</span></span><br><span class="line">print(digit.isdigit())</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\python练习\venv\Scripts\python.exe E:/程序代码/hexo/test.py
True

进程已结束，退出代码 0</code></pre><p>注：</p>
<pre><code>isdigit   isdecimal  isnumeric    三个方法都不能判断小数
isdigit 可以判断unicode字符串   例如：\u00b2      isnumeric  可以判断中文数字  例如：一千零一</code></pre><p>判断字符串是标题化的(每个单词的首字母大写)则返回 True  (单词首字母不是大写则返回false）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">title = <span class="string">"Hello World"</span></span><br><span class="line">print(title.istitle())</span><br><span class="line">title1 = <span class="string">"Hello world"</span></span><br><span class="line">print(title1.istitle())</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\python练习\venv\Scripts\python.exe E:/程序代码/hexo/test.py
True
False

进程已结束，退出代码 0</code></pre><p>判断字符串全是小写</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lower = <span class="string">"abc"</span></span><br><span class="line">print(lower.islower())</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\python练习\venv\Scripts\python.exe E:/程序代码/hexo/test.py
True

进程已结束，退出代码 0</code></pre><p>判断字符串全是大写</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">upper = <span class="string">"PWD"</span></span><br><span class="line">print(upper.isupper())</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\python练习\venv\Scripts\python.exe E:/程序代码/hexo/test.py
True

进程已结束，退出代码 0</code></pre><h2 id="字符串操作–查找和替换"><a href="#字符串操作–查找和替换" class="headerlink" title="字符串操作–查找和替换"></a>字符串操作–查找和替换</h2><p>检查字符串师傅以na开头,是则返还True</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">start = <span class="string">"name is xxx"</span></span><br><span class="line">print(start.startswith(<span class="string">"na"</span>))</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<pre><code>D:\python练习\venv\Scripts\python.exe E:/程序代码/hexo/test.py
True

进程已结束，退出代码 0</code></pre><p>检查字符串是否是以xxx结束,是则返回True</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">start = <span class="string">"name is xxx"</span></span><br><span class="line">print(start.endswith(<span class="string">"xxx"</span>))</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\python练习\venv\Scripts\python.exe E:/程序代码/hexo/test.py
True

进程已结束，退出代码 0</code></pre><p>检测 server 是否包含在 string 中，如果 start 和 end 指定范围，则检查是否包含在指定范围内，如果是返回开始的索引值，否则返回 -1</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">find = <span class="string">"all the servers is Ok and set ableConnect"</span></span><br><span class="line"><span class="comment">##查找find字符串中是否包含server</span></span><br><span class="line">print(find.find(<span class="string">"server"</span>))</span><br><span class="line"><span class="comment">##查找find字符串中是否包含server   开始索引0   结束索引20</span></span><br><span class="line">print(find.find(<span class="string">"server"</span>,<span class="number">0</span>,<span class="number">20</span>))</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\python练习\venv\Scripts\python.exe E:/程序代码/hexo/test.py
8
8

进程已结束，退出代码 0</code></pre><p>rfind()类似于find(),不过是从右边开始查找</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rfind = <span class="string">"all the servers is Ok and set ableConnect"</span></span><br><span class="line">print(rfind.rfind(<span class="string">"server"</span>))</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\python练习\venv\Scripts\python.exe E:/程序代码/hexo/test.py
8

进程已结束，退出代码 0</code></pre><p>index()和find()方法类型,不过如果str不在string中会报错</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">index = <span class="string">"all the servers is Ok and set ableConnect"</span></span><br><span class="line">print(index.index(<span class="string">"server"</span>))</span><br><span class="line">print(index.index(<span class="string">"problem"</span>))</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\python练习\venv\Scripts\python.exe E:/程序代码/hexo/test.py
Traceback (most recent call last):
8
  File &quot;E:/程序代码/hexo/test.py&quot;, line 3, in &lt;module&gt;
    print(index.index(&quot;problem&quot;))
ValueError: substring not found

进程已结束，退出代码 1</code></pre><p>把 string 中的 all 替换成 two，如果 num 指定，则替换不超过 num 次</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">replace = <span class="string">"all the servers is Ok and set ableConnect  all  all  all"</span></span><br><span class="line"><span class="comment">##把 string 中的 all 全部替换成 two</span></span><br><span class="line">print(replace.replace(<span class="string">"all"</span>,<span class="string">"two"</span>))</span><br><span class="line"><span class="comment">##把 string 中的前两个 all 替换成 two</span></span><br><span class="line">print(replace.replace(<span class="string">"all"</span>,<span class="string">"two"</span>,<span class="number">2</span>))</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\python练习\venv\Scripts\python.exe E:/程序代码/hexo/test.py
two the servers is Ok and set ableConnect  two  two  two
two the servers is Ok and set ableConnect  two  all  all

进程已结束，退出代码 0</code></pre><h2 id="字符串操作–大小写转换"><a href="#字符串操作–大小写转换" class="headerlink" title="字符串操作–大小写转换"></a>字符串操作–大小写转换</h2><p>把字符串的第一个字符大写</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">capitalize = <span class="string">"all the servers is Ok and set ableConnect"</span></span><br><span class="line">print(capitalize.capitalize())</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\python练习\venv\Scripts\python.exe E:/程序代码/hexo/test.py
All the servers is ok and set ableconnect

进程已结束，退出代码 0</code></pre><p>把字符串的每个单词首字母大写</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">title = <span class="string">"all the servers is Ok and set aBleConnect"</span></span><br><span class="line">print(title.title())</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\python练习\venv\Scripts\python.exe E:/程序代码/hexo/test.py
All The Servers Is Ok And Set Ableconnect

进程已结束，退出代码 0</code></pre><p>转换 string 中所有大写字符为小写</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lower = <span class="string">"All The Servers Is Ok And Set Ableconnect"</span></span><br><span class="line">print(lower.lower())</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\python练习\venv\Scripts\python.exe E:/程序代码/hexo/test.py
all the servers is ok and set ableconnect

进程已结束，退出代码 0</code></pre><p>转换 string 中所有小写字母为大写</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">upper = <span class="string">"all the servers is ok and set ableconnect"</span></span><br><span class="line">print(upper.upper())</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\python练习\venv\Scripts\python.exe E:/程序代码/hexo/test.py
ALL THE SERVERS IS OK AND SET ABLECONNECT

进程已结束，退出代码 0</code></pre><p>翻转 string 中的大小写</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">swapcase = <span class="string">"A b C d E f"</span></span><br><span class="line">print(swapcase.swapcase())</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\python练习\venv\Scripts\python.exe E:/程序代码/hexo/test.py
a B c D e F

进程已结束，退出代码 0</code></pre><h2 id="字符串操作–文本对齐"><a href="#字符串操作–文本对齐" class="headerlink" title="字符串操作–文本对齐"></a>字符串操作–文本对齐</h2><p>返回一个原字符串左对齐      例如str.ljust(width[, fillchar])      width是个数  fillchar是填充符 默认空格<br> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">just = <span class="string">"all the servers is Ok and set ableConnect"</span></span><br><span class="line"><span class="comment">## 49 意思就是加上原来的字符串 一共的长度  +为填充符</span></span><br><span class="line">print(just.ljust(<span class="number">49</span>,<span class="string">"+"</span>))</span><br></pre></td></tr></table></figure><br>运行结果：</p>
<pre><code>D:\python练习\venv\Scripts\python.exe E:/程序代码/hexo/test.py
all the servers is Ok and set ableConnect++++++++

进程已结束，退出代码 0</code></pre><p>返回一个原字符串右对齐<br> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">just = <span class="string">"all the servers is Ok and set ableConnect"</span></span><br><span class="line">print(just.rjust(<span class="number">49</span>,<span class="string">"+"</span>))</span><br><span class="line">print(just.center(<span class="number">49</span>,<span class="string">"+"</span>))</span><br></pre></td></tr></table></figure><br>运行结果：</p>
<pre><code>D:\python练习\venv\Scripts\python.exe E:/程序代码/hexo/test.py
++++++++all the servers is Ok and set ableConnect
++++all the servers is Ok and set ableConnect++++

进程已结束，退出代码 0</code></pre><h2 id="字符串操作–去除空白字符"><a href="#字符串操作–去除空白字符" class="headerlink" title="字符串操作–去除空白字符"></a>字符串操作–去除空白字符</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str = <span class="string">"       all the servers is Ok and set ableConnect      "</span></span><br><span class="line">print(str)</span><br><span class="line"><span class="comment">##截掉 string 左边（开始）的空白字符</span></span><br><span class="line">print(str.lstrip())</span><br><span class="line"><span class="comment">##截掉 string 右边（开始）的空白字符</span></span><br><span class="line">print(str.rstrip())</span><br><span class="line"><span class="comment">##截掉 string 左右两边的空白字符</span></span><br><span class="line">print(str.strip())</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\python练习\venv\Scripts\python.exe E:/程序代码/hexo/test.py
      all the servers is Ok and set ableConnect      
all the servers is Ok and set ableConnect      
      all the servers is Ok and set ableConnect
all the servers is Ok and set ableConnect</code></pre><p>进程已结束，退出代码 0</p>
<h2 id="字符串操作–拆分和连接"><a href="#字符串操作–拆分和连接" class="headerlink" title="字符串操作–拆分和连接"></a>字符串操作–拆分和连接</h2><p>把字符串 string 分成一个 3 元素的元组 (str前面, str, str后面)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">partition = <span class="string">"all the servers is Ok and set ableConnect"</span></span><br><span class="line">print(partition.partition(<span class="string">"the"</span>))</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\python练习\venv\Scripts\python.exe E:/程序代码/hexo/test.py
(&apos;all &apos;, &apos;the&apos;, &apos; servers is Ok and set ableConnect&apos;)

进程已结束，退出代码 0</code></pre><p>rpartition()类似于 partition() 方法，不过是从右边开始查找</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">partition = <span class="string">"all the and servers is Ok and set ableConnect"</span></span><br><span class="line">print(partition.rpartition(<span class="string">"and"</span>))</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\python练习\venv\Scripts\python.exe E:/程序代码/hexo/test.py
(&apos;all the and servers is Ok &apos;, &apos;and&apos;, &apos; set ableConnect&apos;)

进程已结束，退出代码 0</code></pre><p>string.split(str=””, num) | 以 str 为分隔符拆分 string，如果 num 有指定值，则仅分隔 num + 1 个子字符串，str 默认包含 ‘\r’, ‘\t’, ‘\n’ 和空格</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pome = <span class="string">"登鹤雀楼 \t  王之涣  \t  白日依山尽  \t \n  黄河入海流  \t  \t 欲穷千里目   \n  更上一层楼"</span></span><br><span class="line">print(pome)</span><br><span class="line">print(<span class="string">"-"</span>*<span class="number">50</span>)</span><br><span class="line">pome_list = pome.split()</span><br><span class="line">print(pome_list)</span><br><span class="line">print(<span class="string">"-"</span>*<span class="number">50</span>)</span><br><span class="line">lastpome = <span class="string">" "</span>.join(pome_list)</span><br><span class="line">print(lastpome)</span><br><span class="line">print(<span class="string">"-"</span>*<span class="number">50</span>)</span><br><span class="line">print(lastpome.replace(<span class="string">" "</span>,<span class="string">"\n"</span>))</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\python练习\venv\Scripts\python.exe E:/程序代码/hexo/test.py
登鹤雀楼       王之涣        白日依山尽       
  黄河入海流             欲穷千里目   
  更上一层楼
--------------------------------------------------
[&apos;登鹤雀楼&apos;, &apos;王之涣&apos;, &apos;白日依山尽&apos;, &apos;黄河入海流&apos;, &apos;欲穷千里目&apos;, &apos;更上一层楼&apos;]
--------------------------------------------------
登鹤雀楼 王之涣 白日依山尽 黄河入海流 欲穷千里目 更上一层楼
--------------------------------------------------
登鹤雀楼
王之涣
白日依山尽
黄河入海流
欲穷千里目
更上一层楼

进程已结束，退出代码 0</code></pre><h2 id="字符串切片"><a href="#字符串切片" class="headerlink" title="字符串切片"></a>字符串切片</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num_str = <span class="string">"0123456789"</span></span><br><span class="line"><span class="comment">##1、截取从2 - 5位置的字符串</span></span><br><span class="line">print(num_str[<span class="number">2</span>:<span class="number">6</span>])</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\python练习\venv\Scripts\python.exe E:/程序代码/hexo/test.py
2345

进程已结束，退出代码 0</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">##2、截取2 - 末尾的字符串</span><br><span class="line">print(num_str[2:])</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\python练习\venv\Scripts\python.exe E:/程序代码/hexo/test.py
23456789

进程已结束，退出代码 0</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">##3、截取从开始 - 5 位置的字符串</span><br><span class="line">print(num_str[:6])</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\python练习\venv\Scripts\python.exe E:/程序代码/hexo/test.py
012345

进程已结束，退出代码 0</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">##4、截取完整的字符串</span><br><span class="line">print(num_str[:])</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\python练习\venv\Scripts\python.exe E:/程序代码/hexo/test.py
0123456789

进程已结束，退出代码 0</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">##5、从开始位置，每隔一个字符截取字符串</span><br><span class="line">print(num_str[::2])</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\python练习\venv\Scripts\python.exe E:/程序代码/hexo/test.py
02468

进程已结束，退出代码 0</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">##6、从索引 1 开始，每隔一个取一个</span><br><span class="line">print(num_str[1::2])</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\python练习\venv\Scripts\python.exe E:/程序代码/hexo/test.py
13579

进程已结束，退出代码 0</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">##7、截取从2 - 末尾 -1  的字符串</span><br><span class="line">print(num_str[2:-1])</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\python练习\venv\Scripts\python.exe E:/程序代码/hexo/test.py
2345678

进程已结束，退出代码 0</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">##8、截取字符串末尾两个字符</span><br><span class="line">print(num_str[-2:])</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\python练习\venv\Scripts\python.exe E:/程序代码/hexo/test.py
89

进程已结束，退出代码 0</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">##9、字符串的逆序</span><br><span class="line">print(num_str[-1::-1])</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\python练习\venv\Scripts\python.exe E:/程序代码/hexo/test.py
9876543210

进程已结束，退出代码 0</code></pre>]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>kube-flannel</title>
    <url>/2020/05/24/kube-flannel/</url>
    <content><![CDATA[<pre><code>---
apiVersion: policy/v1beta1
kind: PodSecurityPolicy
metadata:
  name: psp.flannel.unprivileged
  annotations:
    seccomp.security.alpha.kubernetes.io/allowedProfileNames: docker/default
    seccomp.security.alpha.kubernetes.io/defaultProfileName: docker/default
    apparmor.security.beta.kubernetes.io/allowedProfileNames: runtime/default
    apparmor.security.beta.kubernetes.io/defaultProfileName: runtime/default
spec:
  privileged: false
  volumes:
    - configMap
    - secret
    - emptyDir
    - hostPath
  allowedHostPaths:
    - pathPrefix: &quot;/etc/cni/net.d&quot;
    - pathPrefix: &quot;/etc/kube-flannel&quot;
    - pathPrefix: &quot;/run/flannel&quot;
  readOnlyRootFilesystem: false
  # Users and groups
  runAsUser:
    rule: RunAsAny
  supplementalGroups:
    rule: RunAsAny
  fsGroup:
    rule: RunAsAny
  # Privilege Escalation
  allowPrivilegeEscalation: false
  defaultAllowPrivilegeEscalation: false
  # Capabilities
  allowedCapabilities: [&apos;NET_ADMIN&apos;]
  defaultAddCapabilities: []
  requiredDropCapabilities: []
  # Host namespaces
  hostPID: false
  hostIPC: false
  hostNetwork: true
  hostPorts:
  - min: 0
    max: 65535
  # SELinux
  seLinux:
    # SELinux is unused in CaaSP
    rule: &apos;RunAsAny&apos;
---
kind: ClusterRole
apiVersion: rbac.authorization.k8s.io/v1beta1
metadata:
  name: flannel
rules:
  - apiGroups: [&apos;extensions&apos;]
    resources: [&apos;podsecuritypolicies&apos;]
    verbs: [&apos;use&apos;]
    resourceNames: [&apos;psp.flannel.unprivileged&apos;]
  - apiGroups:
      - &quot;&quot;
    resources:
      - pods
    verbs:
      - get
  - apiGroups:
      - &quot;&quot;
    resources:
      - nodes
    verbs:
      - list
      - watch
  - apiGroups:
      - &quot;&quot;
    resources:
      - nodes/status
    verbs:
      - patch
---
kind: ClusterRoleBinding
apiVersion: rbac.authorization.k8s.io/v1beta1
metadata:
  name: flannel
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: flannel
subjects:
- kind: ServiceAccount
  name: flannel
  namespace: kube-system
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: flannel
  namespace: kube-system
---
kind: ConfigMap
apiVersion: v1
metadata:
  name: kube-flannel-cfg
  namespace: kube-system
  labels:
    tier: node
    app: flannel
data:
  cni-conf.json: |
    {
      &quot;name&quot;: &quot;cbr0&quot;,
      &quot;cniVersion&quot;: &quot;0.3.1&quot;,
      &quot;plugins&quot;: [
        {
          &quot;type&quot;: &quot;flannel&quot;,
          &quot;delegate&quot;: {
            &quot;hairpinMode&quot;: true,
            &quot;isDefaultGateway&quot;: true
          }
        },
        {
          &quot;type&quot;: &quot;portmap&quot;,
          &quot;capabilities&quot;: {
            &quot;portMappings&quot;: true
          }
        }
      ]
    }
  net-conf.json: |
    {
      &quot;Network&quot;: &quot;10.244.0.0/16&quot;,
      &quot;Backend&quot;: {
        &quot;Type&quot;: &quot;vxlan&quot;
      }
    }
---
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: kube-flannel-ds-amd64
  namespace: kube-system
  labels:
    tier: node
    app: flannel
spec:
  selector:
    matchLabels:
      app: flannel
  template:
    metadata:
      labels:
        tier: node
        app: flannel
    spec:
      affinity:
        nodeAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
            nodeSelectorTerms:
              - matchExpressions:
                  - key: kubernetes.io/os
                    operator: In
                    values:
                      - linux
                  - key: kubernetes.io/arch
                    operator: In
                    values:
                      - amd64
      hostNetwork: true
      tolerations:
      - operator: Exists
        effect: NoSchedule
      serviceAccountName: flannel
      initContainers:
      - name: install-cni
        image: quay.io/coreos/flannel:v0.12.0-amd64
        command:
        - cp
        args:
        - -f
        - /etc/kube-flannel/cni-conf.json
        - /etc/cni/net.d/10-flannel.conflist
        volumeMounts:
        - name: cni
          mountPath: /etc/cni/net.d
        - name: flannel-cfg
          mountPath: /etc/kube-flannel/
      containers:
      - name: kube-flannel
        image: quay.io/coreos/flannel:v0.12.0-amd64
        command:
        - /opt/bin/flanneld
        args:
        - --ip-masq
        - --kube-subnet-mgr
        resources:
          requests:
            cpu: &quot;100m&quot;
            memory: &quot;50Mi&quot;
          limits:
            cpu: &quot;100m&quot;
            memory: &quot;50Mi&quot;
        securityContext:
          privileged: false
          capabilities:
            add: [&quot;NET_ADMIN&quot;]
        env:
        - name: POD_NAME
          valueFrom:
            fieldRef:
              fieldPath: metadata.name
        - name: POD_NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
        volumeMounts:
        - name: run
          mountPath: /run/flannel
        - name: flannel-cfg
          mountPath: /etc/kube-flannel/
      volumes:
        - name: run
          hostPath:
            path: /run/flannel
        - name: cni
          hostPath:
            path: /etc/cni/net.d
        - name: flannel-cfg
          configMap:
            name: kube-flannel-cfg
---
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: kube-flannel-ds-arm64
  namespace: kube-system
  labels:
    tier: node
    app: flannel
spec:
  selector:
    matchLabels:
      app: flannel
  template:
    metadata:
      labels:
        tier: node
        app: flannel
    spec:
      affinity:
        nodeAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
            nodeSelectorTerms:
              - matchExpressions:
                  - key: kubernetes.io/os
                    operator: In
                    values:
                      - linux
                  - key: kubernetes.io/arch
                    operator: In
                    values:
                      - arm64
      hostNetwork: true
      tolerations:
      - operator: Exists
        effect: NoSchedule
      serviceAccountName: flannel
      initContainers:
      - name: install-cni
        image: quay.io/coreos/flannel:v0.12.0-arm64
        command:
        - cp
        args:
        - -f
        - /etc/kube-flannel/cni-conf.json
        - /etc/cni/net.d/10-flannel.conflist
        volumeMounts:
        - name: cni
          mountPath: /etc/cni/net.d
        - name: flannel-cfg
          mountPath: /etc/kube-flannel/
      containers:
      - name: kube-flannel
        image: quay.io/coreos/flannel:v0.12.0-arm64
        command:
        - /opt/bin/flanneld
        args:
        - --ip-masq
        - --kube-subnet-mgr
        resources:
          requests:
            cpu: &quot;100m&quot;
            memory: &quot;50Mi&quot;
          limits:
            cpu: &quot;100m&quot;
            memory: &quot;50Mi&quot;
        securityContext:
          privileged: false
          capabilities:
            add: [&quot;NET_ADMIN&quot;]
        env:
        - name: POD_NAME
          valueFrom:
            fieldRef:
              fieldPath: metadata.name
        - name: POD_NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
        volumeMounts:
        - name: run
          mountPath: /run/flannel
        - name: flannel-cfg
          mountPath: /etc/kube-flannel/
      volumes:
        - name: run
          hostPath:
            path: /run/flannel
        - name: cni
          hostPath:
            path: /etc/cni/net.d
        - name: flannel-cfg
          configMap:
            name: kube-flannel-cfg
---
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: kube-flannel-ds-arm
  namespace: kube-system
  labels:
    tier: node
    app: flannel
spec:
  selector:
    matchLabels:
      app: flannel
  template:
    metadata:
      labels:
        tier: node
        app: flannel
    spec:
      affinity:
        nodeAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
            nodeSelectorTerms:
              - matchExpressions:
                  - key: kubernetes.io/os
                    operator: In
                    values:
                      - linux
                  - key: kubernetes.io/arch
                    operator: In
                    values:
                      - arm
      hostNetwork: true
      tolerations:
      - operator: Exists
        effect: NoSchedule
      serviceAccountName: flannel
      initContainers:
      - name: install-cni
        image: quay.io/coreos/flannel:v0.12.0-arm
        command:
        - cp
        args:
        - -f
        - /etc/kube-flannel/cni-conf.json
        - /etc/cni/net.d/10-flannel.conflist
        volumeMounts:
        - name: cni
          mountPath: /etc/cni/net.d
        - name: flannel-cfg
          mountPath: /etc/kube-flannel/
      containers:
      - name: kube-flannel
        image: quay.io/coreos/flannel:v0.12.0-arm
        command:
        - /opt/bin/flanneld
        args:
        - --ip-masq
        - --kube-subnet-mgr
        resources:
          requests:
            cpu: &quot;100m&quot;
            memory: &quot;50Mi&quot;
          limits:
            cpu: &quot;100m&quot;
            memory: &quot;50Mi&quot;
        securityContext:
          privileged: false
          capabilities:
            add: [&quot;NET_ADMIN&quot;]
        env:
        - name: POD_NAME
          valueFrom:
            fieldRef:
              fieldPath: metadata.name
        - name: POD_NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
        volumeMounts:
        - name: run
          mountPath: /run/flannel
        - name: flannel-cfg
          mountPath: /etc/kube-flannel/
      volumes:
        - name: run
          hostPath:
            path: /run/flannel
        - name: cni
          hostPath:
            path: /etc/cni/net.d
        - name: flannel-cfg
          configMap:
            name: kube-flannel-cfg
---
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: kube-flannel-ds-ppc64le
  namespace: kube-system
  labels:
    tier: node
    app: flannel
spec:
  selector:
    matchLabels:
      app: flannel
  template:
    metadata:
      labels:
        tier: node
        app: flannel
    spec:
      affinity:
        nodeAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
            nodeSelectorTerms:
              - matchExpressions:
                  - key: kubernetes.io/os
                    operator: In
                    values:
                      - linux
                  - key: kubernetes.io/arch
                    operator: In
                    values:
                      - ppc64le
      hostNetwork: true
      tolerations:
      - operator: Exists
        effect: NoSchedule
      serviceAccountName: flannel
      initContainers:
      - name: install-cni
        image: quay.io/coreos/flannel:v0.12.0-ppc64le
        command:
        - cp
        args:
        - -f
        - /etc/kube-flannel/cni-conf.json
        - /etc/cni/net.d/10-flannel.conflist
        volumeMounts:
        - name: cni
          mountPath: /etc/cni/net.d
        - name: flannel-cfg
          mountPath: /etc/kube-flannel/
      containers:
      - name: kube-flannel
        image: quay.io/coreos/flannel:v0.12.0-ppc64le
        command:
        - /opt/bin/flanneld
        args:
        - --ip-masq
        - --kube-subnet-mgr
        resources:
          requests:
            cpu: &quot;100m&quot;
            memory: &quot;50Mi&quot;
          limits:
            cpu: &quot;100m&quot;
            memory: &quot;50Mi&quot;
        securityContext:
          privileged: false
          capabilities:
            add: [&quot;NET_ADMIN&quot;]
        env:
        - name: POD_NAME
          valueFrom:
            fieldRef:
              fieldPath: metadata.name
        - name: POD_NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
        volumeMounts:
        - name: run
          mountPath: /run/flannel
        - name: flannel-cfg
          mountPath: /etc/kube-flannel/
      volumes:
        - name: run
          hostPath:
            path: /run/flannel
        - name: cni
          hostPath:
            path: /etc/cni/net.d
        - name: flannel-cfg
          configMap:
            name: kube-flannel-cfg
---
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: kube-flannel-ds-s390x
  namespace: kube-system
  labels:
    tier: node
    app: flannel
spec:
  selector:
    matchLabels:
      app: flannel
  template:
    metadata:
      labels:
        tier: node
        app: flannel
    spec:
      affinity:
        nodeAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
            nodeSelectorTerms:
              - matchExpressions:
                  - key: kubernetes.io/os
                    operator: In
                    values:
                      - linux
                  - key: kubernetes.io/arch
                    operator: In
                    values:
                      - s390x
      hostNetwork: true
      tolerations:
      - operator: Exists
        effect: NoSchedule
      serviceAccountName: flannel
      initContainers:
      - name: install-cni
        image: quay.io/coreos/flannel:v0.12.0-s390x
        command:
        - cp
        args:
        - -f
        - /etc/kube-flannel/cni-conf.json
        - /etc/cni/net.d/10-flannel.conflist
        volumeMounts:
        - name: cni
          mountPath: /etc/cni/net.d
        - name: flannel-cfg
          mountPath: /etc/kube-flannel/
      containers:
      - name: kube-flannel
        image: quay.io/coreos/flannel:v0.12.0-s390x
        command:
        - /opt/bin/flanneld
        args:
        - --ip-masq
        - --kube-subnet-mgr
        resources:
          requests:
            cpu: &quot;100m&quot;
            memory: &quot;50Mi&quot;
          limits:
            cpu: &quot;100m&quot;
            memory: &quot;50Mi&quot;
        securityContext:
          privileged: false
          capabilities:
            add: [&quot;NET_ADMIN&quot;]
        env:
        - name: POD_NAME
          valueFrom:
            fieldRef:
              fieldPath: metadata.name
        - name: POD_NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
        volumeMounts:
        - name: run
          mountPath: /run/flannel
        - name: flannel-cfg
          mountPath: /etc/kube-flannel/
      volumes:
        - name: run
          hostPath:
            path: /run/flannel
        - name: cni
          hostPath:
            path: /etc/cni/net.d
        - name: flannel-cfg
          configMap:
            name: kube-flannel-cfg</code></pre>]]></content>
  </entry>
  <entry>
    <title>kubernetes-1.18.2常见报错--持续更新</title>
    <url>/2020/05/24/error/</url>
    <content><![CDATA[<h2 id="初始化时端口已经启动"><a href="#初始化时端口已经启动" class="headerlink" title="初始化时端口已经启动"></a>初始化时端口已经启动</h2><pre><code>[root@k8s-master01 ~]# kubeadm init --config config.yaml

[init] Using Kubernetes version: v1.10.0
[init] Using Authorization modes: [Node RBAC]
[preflight] Running pre-flight checks.
[preflight] Some fatal errors occurred:
        [ERROR Port-6443]: Port 6443 is in use
        [ERROR Port-10250]: Port 10250 is in use
        [ERROR Port-10251]: Port 10251 is in use
        [ERROR Port-10252]: Port 10252 is in use
        [ERROR FileAvailable--etc-kubernetes-manifests-kube-apiserver.yaml]: /etc/kubernetes/manifests/kube-apiserver.yaml already exists
        [ERROR FileAvailable--etc-kubernetes-manifests-kube-controller-manager.yaml]: /etc/kubernetes/manifests/kube-controller-manager.yaml already exists
        [ERROR FileAvailable--etc-kubernetes-manifests-kube-scheduler.yaml]: /etc/kubernetes/manifests/kube-scheduler.yaml already exists
[preflight] If you know what you are doing, you can make a check non-fatal with `--ignore-preflight-errors=...`



解决方案：发现杀死进程都没有用，最终重启一下kubeadm就可以了，如下：

[root@k8s-master01 ~]# kubeadm reset</code></pre><h2 id="无法拉取镜像"><a href="#无法拉取镜像" class="headerlink" title="无法拉取镜像"></a>无法拉取镜像</h2><p>使用kubeadm配置文件，通过在配置文件中指定docker仓库地址，便于内网快速部署。</p>
<p>生成配置文件</p>
<pre><code>kubeadm config print init-defaults ClusterConfiguration &gt;kubeadm.conf</code></pre><p>修改kubeadm.conf</p>
<pre><code>vi kubeadm.conf
修改 imageRepository: k8s.gcr.io
改为 registry.aliyuncs.com/google_containers
imageRepository: registry.aliyuncs.com/google_containers
修改kubernetes版本kubernetesVersion: v1.13.0
改为kubernetesVersion: v1.18.2
kubernetesVersion: v1.18.2</code></pre><p>  再次查看kubeadm config所需的镜像</p>
<pre><code>[root@master01 ~]# kubeadm config images list --config kubeadm.conf
W0524 14:25:08.505708   14715 configset.go:202] WARNING: kubeadm cannot validate component configs for API groups [kubelet.config.k8s.io kubeproxy.config.k8s.io]
registry.aliyuncs.com/google_containers/kube-apiserver:v1.18.2
registry.aliyuncs.com/google_containers/kube-controller-manager:v1.18.2
registry.aliyuncs.com/google_containers/kube-scheduler:v1.18.2
registry.aliyuncs.com/google_containers/kube-proxy:v1.18.2
registry.aliyuncs.com/google_containers/pause:3.2
registry.aliyuncs.com/google_containers/etcd:3.4.3-0
registry.aliyuncs.com/google_containers/coredns:1.6.7</code></pre><p>拉取镜像并初始化</p>
<pre><code>kubeadm config images pull --config kubeadm.conf

kubeadm init --kubernetes-version=1.18.2 --apiserver-advertise-address=192.168.1.100  --image-repository registry.aliyuncs.com/google_containers  --service-cidr=10.10.0.0/16 --pod-network-cidr=10.122.0.0/16  </code></pre><h2 id="初始化报错"><a href="#初始化报错" class="headerlink" title="初始化报错"></a>初始化报错</h2><pre><code>W0523 10:11:56.806416  112153 configset.go:202] WARNING: kubeadm cannot validate component configs for API groups [kubelet.config.k8s.io kubeproxy.config.k8s.io]
[init] Using Kubernetes version: v1.18.3
[preflight] Running pre-flight checks
error execution phase preflight: [preflight] Some fatal errors occurred:
        [ERROR DirAvailable--var-lib-etcd]: /var/lib/etcd is not empty
[preflight] If you know what you are doing, you can make a check non-fatal with `--ignore-preflight-errors=...`</code></pre><p>删除文件</p>
<pre><code>rm -rf /var/lib/etcd</code></pre><p>就可以继续初始化了</p>
<h2 id="无法下载flannel网络插件"><a href="#无法下载flannel网络插件" class="headerlink" title="无法下载flannel网络插件"></a>无法下载flannel网络插件</h2><pre><code>[root@master01 ~]# wget https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml
--2020-05-24 14:32:30--  https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml
正在解析主机 raw.githubusercontent.com (raw.githubusercontent.com)... 0.0.0.0, ::
正在连接 raw.githubusercontent.com (raw.githubusercontent.com)|0.0.0.0|:443... 失败：拒绝连接。
正在连接 raw.githubusercontent.com (raw.githubusercontent.com)|::|:443... 失败：拒绝连接。

[root@master01 ~]# kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml
The connection to the server raw.githubusercontent.com was refused - did you specify the right host or port?</code></pre><p>  如果无法访问网站需要手动创建文件    kube-flannel.yaml<br>  <br>由于内容太长保存在下面网站中：<br><br>    <a href="https://xinlong.youare.ink/2020/05/24/kube-flannel/" target="_blank" rel="noopener">https://xinlong.youare.ink/2020/05/24/kube-flannel/</a><br>  <br>然后执行<br></p>
<pre><code>kubectl apply -f kube-flannel.yaml</code></pre><p>  稍等几秒后使用如下命令确认其输出结果中Pod的状态为“Running”，</p>
<pre><code>kubectl get pods -n kube-system -l app=flannel</code></pre><p>  类似如下所示：</p>
<pre><code>NAME READY STATUS RESTARTS AGE

kube-flannel-ds-amd64-wscnz 1/1 Running 0 14m</code></pre><p>  验正master节点已经就绪</p>
<pre><code>kubectl get nodes</code></pre><p>  上述命令应该会得到类似如下输出：</p>
<pre><code>NAME STATUS ROLES AGE VERSION

master01.ilinux.io Ready master 4m9s v1.12.1</code></pre><h2 id="添加node节点报错"><a href="#添加node节点报错" class="headerlink" title="添加node节点报错"></a>添加node节点报错</h2><p>node节点报错<br>    [root@node01 yum.repos.d]# kubectl get node<br>    The connection to the server localhost:8080 was refused - did you specify the right host or port?    </p>
<pre><code>kubeadm join 192.168.1.100:6443 --token 946w2y.xhj1wukp35zu6ppb     --discovery-token-ca-cert-hash sha256:93253b79ac5f2a3f32ee7d76e4d7d75cb2bbcd9190132a931c7ea5d5985521a1         </code></pre><p>在node上执行kubeadm join后 在master服务器查询状态为 NotReady 在node上查询报错为上述日志<br><br>解决办法：<br></p>
<p>在node服务器上执行scp  把master上的admin.conf文件拉取到/etc/kubernetes/admin.conf             </p>
<pre><code>scp root@192.168.1.100:/etc/kubernetes/admin.conf /etc/kubernetes/admin.conf             </code></pre><p>设置环境变量</p>
<pre><code>export KUBECONFIG=/etc/kubernetes/admin.conf </code></pre><p>再次执行 kubectl get node </p>
<pre><code>[root@node01 yum.repos.d]# kubectl get node 
NAME       STATUS   ROLES    AGE     VERSION
master01   Ready    master   7h58m   v1.18.3
master02   Ready    &lt;none&gt;   14m     v1.18.3</code></pre><p>master执行 kubectl get node </p>
<pre><code>[root@master01 ~]# kubectl get nodes
NAME       STATUS   ROLES    AGE     VERSION
master01   Ready    master   7h58m   v1.18.3
master02   Ready    &lt;none&gt;   14m     v1.18.3</code></pre>]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>使用kubeadm安装kubernetes</title>
    <url>/2020/05/22/kubeadm/</url>
    <content><![CDATA[<p>Kubernetes技术已经成为了原生云技术的事实标准，它是目前基础软件领域最为热门的分布式调度和管理平台。于是，Kubernetes也几乎成了时下开发工程师和运维工程师必备的技能之一。</p>
<h2 id="一、主机环境预设"><a href="#一、主机环境预设" class="headerlink" title="一、主机环境预设"></a>一、主机环境预设</h2><p>1、测试环境说明</p>
<p>  测试使用的Kubernetes集群可由一个master主机及一个以上（建议至少两个）node主机组成，这些主机可以是物理服务器，也可以运行于vmware、virtualbox或kvm等虚拟化平台上的虚拟机，甚至是公有云上的VPS主机。</p>
<p>  本测试环境将由master01、node01和node02三个独立的主机组成，它们分别拥有4核心的CPU及4G的内存资源，操作系统环境均为CentOS 7.5 1804，域名为ilinux.io。此外，需要预设的系统环境如下：</p>
<p>   （1）借助于NTP服务设定各节点时间精确同步；</p>
<p>  （2）通过DNS完成各节点的主机名称解析，测试环境主机数量较少时也可以使用hosts文件进行；</p>
<p>  （3）关闭各节点的iptables或firewalld服务，并确保它们被禁止随系统引导过程启动；</p>
<p>  （4）各节点禁用SELinux；</p>
<p>  （5）各节点禁用所有的Swap设备；</p>
<p>  （6）若要使用ipvs模型的proxy，各节点还需要载入ipvs相关的各模块；</p>
<p>2、设定时钟同步</p>
<p>  若节点可直接访问互联网，直接启动chronyd系统服务，并设定其随系统引导而启动。</p>
<pre><code>systemctl start chronyd.service

systemctl enable chronyd.service</code></pre><p>  不过，建议用户配置使用本地的的时间服务器，在节点数量众多时尤其如此。存在可用的本地时间服务器时，修改节点的/etc/crhony.conf配置文件，并将时间服务器指向相应的主机即可，配置格式如下：</p>
<pre><code>server CHRONY-SERVER-NAME-OR-IP iburst</code></pre><p>  或者使用ntpdate</p>
<pre><code>yum -y install wget vim net-tools ntpdate
ntpdate time.pool.aliyun.com</code></pre><p>3、主机名称解析</p>
<p>  出于简化配置步骤的目的，本测试环境使用hosts文件进行各节点名称解析，文件内容如下所示：</p>
<pre><code>[root@master01 ~]# cat /etc/hosts
127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
::1         localhost localhost.localdomain localhost6 localhost6.localdomain6
192.168.1.100 master01

192.168.1.101 node1

192.168.1.102 node2</code></pre><p>4、关闭iptables或firewalld服务</p>
<p>  在CentOS7上，iptables或firewalld服务通常只会安装并启动一种，在不确认具体启动状态的前提下，这里通过同时关闭并禁用二者即可简单达到设定目标。</p>
<pre><code>systemctl stop firewalld.service

systemctl stop iptables.service

systemctl disable firewalld.service

systemctl disable iptables.service</code></pre><p>5、关闭并禁用SELinux</p>
<p>  若当前启用了SELinux，则需要编辑/etc/sysconfig/selinux文件,禁用SELinux，并临时设置其当前状态为permissive：</p>
<pre><code>sed -i ‘s@^\(SELINUX=\).*@\1disabled@‘  /etc/sysconfig/selinux

setenforce 0</code></pre><p>6、禁用Swap设备</p>
<p>  部署集群时，kubeadm默认会预先检查当前主机是否禁用了Swap设备，并在未禁用时强制终止部署过程。因此，在主机内存资源充裕的条件下，需要禁用所有的Swap设备，否则，就需要在后文的kubeadm init及kubeadm join命令执行时额外使用相关的选项忽略检查错误。</p>
<p>  关闭Swap设备，需要分两步完成。首先是关闭当前已启用的所有Swap设备：</p>
<pre><code>swapoff -a</code></pre><p>  而后编辑/etc/fstab配置文件，注释用于挂载Swap设备的所有行。</p>
<p>7、启用ipvs内核模块</p>
<p>  创建内核模块载入相关的脚本文件/etc/sysconfig/modules/ipvs.modules，设定自动载入的内核模块。文件内容如下：</p>
<pre><code>#!/bin/bash

ipvs_modules_dir=&quot;/usr/lib/modules/$(uname -r)/kernel/net/netfilter/ipvs&quot;

for i in $(ls $ipvs_modules_dir | sed -r ‘s@(.*).ko.xz@\1@‘); do

/sbin/modinfo -F filename $i &amp;&gt; /dev/null

if [ $? -eq 0 ]; then

/sbin/modprobe $i

fi

done</code></pre><p>  修改文件权限，并手动为当前系统加载内核模块：</p>
<pre><code>chmod +x /etc/sysconfig/modules/ipvs.modules

bash /etc/sysconfig/modules/ipvs.modules</code></pre><p>8、master对node节点ssh互信</p>
<pre><code>ssh-keygen
ssh-copy-id node01
ssh-copy-id node02</code></pre><h2 id="二、安装程序包（在各主机上完成如下设定）"><a href="#二、安装程序包（在各主机上完成如下设定）" class="headerlink" title="二、安装程序包（在各主机上完成如下设定）"></a>二、安装程序包（在各主机上完成如下设定）</h2><p>1、生成yum仓库配置</p>
<p>  首先获取docker-ce的配置仓库配置文件：</p>
<pre><code> yum install wget  -y
wget https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo -O /etc/yum.repos.d/docker.repo</code></pre><p>  而后手动生成kubernetes的yum仓库配置文件/etc/yum.repos.d/kubernetes.repo，内容如下：</p>
<pre><code>[kubernetes]
name=Kubernetes
baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/
gpgcheck=1
gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg
enabled=1</code></pre><p>2、安装相关的程序包</p>
<p>  Kubernetes会对经过充分验正的Docker程序版本进行认证，目前认证完成的最高版本是17.03，但docker-ce的最新版本已经高出了几个版本号。管理员可忽略此认证而直接使用最新版本的docker-ce程序，不过，建议根据后面的说明，将安装命令替换为安装17.03版。</p>
<pre><code>yum install docker-ce

yum install kubelet kubeadm kubectl</code></pre><p>  如果要安装目前经过Kubernetes认证的docker-17版本，可以将上面第一条安装命令替换为如下命令：</p>
<pre><code>yum install -y --setopt=obsoletes=0 docker-ce-17.03.2.ce docker-ce-selinux-17.03.2.ce</code></pre><h2 id="三、配置并启动docker服务（在各节点执行）"><a href="#三、配置并启动docker服务（在各节点执行）" class="headerlink" title="三、配置并启动docker服务（在各节点执行）"></a>三、配置并启动docker服务（在各节点执行）</h2><p>安装组件的几种方法：</p>
<p>1、从阿里云镜像仓库拉取镜像</p>
<pre><code>docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/kube-apiserver:v1.13.0      </code></pre><p>  修改镜像tag</p>
<pre><code>docker tag  registry.cn-hangzhou.aliyuncs.com/google_containers/kube-apiserver:v1.13.0  k8s.gcr.io/kube-apiserver:v1.13.0
docker images</code></pre><p>  使用docker pull镜像后  就不用修改代理配置了<br> <br> 批量修改脚本： <br> </p>
<pre><code>#!/bin/bash
KUBE_VERSION=v1.13.0
KUBE_PAUSE_VERSION=3.1
ETCD_VERSION=3.1.12
DNS_VERSION=1.14.8
GCR_URL=k8s.gcr.io
ALIYUN_URL=registry.cn-shenzhen.aliyuncs.com/cookcodeblog
images=(kube-proxy:${KUBE_VERSION}
kube-scheduler:${KUBE_VERSION}
kube-controller-manager:${KUBE_VERSION}
kube-apiserver:${KUBE_VERSION}
pause:${KUBE_PAUSE_VERSION}
etcd:${ETCD_VERSION}
k8s-dns-sidecar:${DNS_VERSION}
k8s-dns-kube-dns:${DNS_VERSION}
k8s-dns-dnsmasq-nanny:${DNS_VERSION})


for imageName in ${images[@]} ; do
  docker pull $ALIYUN_URL/$imageName
  docker tag  $ALIYUN_URL/$imageName $GCR_URL/$imageName
  docker rmi $ALIYUN_URL/$imageName
done

docker images</code></pre><p>2、若要通过默认的k8s.gcr.io镜像仓库获取Kubernetes系统组件的相关镜像，需要配置docker Unit  #File（/usr/lib/systemd/system/docker.service文件）中的Environment变量，为其定义合用的HTTPS_PROXY，格式如下：</p>
<pre><code>Environment=&quot;HTTPS_PROXY=PROTOCOL://HOST:PORT&quot;

Environment=&quot;NO_PROXY=172.20.0.0/16,127.0.0.0/8&quot;</code></pre><p>  如果没有国外的服务器最好还是先使用docker pull下镜像 然后修改</p>
<p>3、生成配置文件</p>
<pre><code>kubeadm config print init-defaults ClusterConfiguration &gt;kubeadm.conf  </code></pre><p>  修改kubeadm.conf</p>
<pre><code>  vi kubeadm.conf
# 修改 imageRepository: k8s.gcr.io
# 改为 registry.aliyuncs.com/google_containers
imageRepository: registry.aliyuncs.com/google_containers
# 修改kubernetes版本kubernetesVersion: v1.13.0
# 改为kubernetesVersion: v1.18.2
kubernetesVersion: v1.18.2</code></pre><p>  查看所以下载的镜像</p>
<pre><code>kubeadm config images list --config kubeadm.conf

  W0524 14:25:08.505708   14715 configset.go:202] WARNING: kubeadm cannot validate component configs for API groups [kubelet.config.k8s.io kubeproxy.config.k8s.io]
  registry.aliyuncs.com/google_containers/kube-apiserver:v1.18.2
  registry.aliyuncs.com/google_containers/kube-controller-manager:v1.18.2
  registry.aliyuncs.com/google_containers/kube-scheduler:v1.18.2
  registry.aliyuncs.com/google_containers/kube-proxy:v1.18.2
  registry.aliyuncs.com/google_containers/pause:3.2
  registry.aliyuncs.com/google_containers/etcd:3.4.3-0
  registry.aliyuncs.com/google_containers/coredns:1.6.7</code></pre><p>  拉取镜像</p>
<pre><code>kubeadm config images pull --config kubeadm.conf</code></pre><p>4、初始化的时候指定镜像库 – 个人推荐这种方式比较简单<br><br>例如：<br></p>
<pre><code>kubeadm init --kubernetes-version=1.18.2 --apiserver-advertise-address=192.168.1.100  --image-repository registry.aliyuncs.com/google_containers  --service-cidr=10.10.0.0/16 --pod-network-cidr=10.122.0.0/16  </code></pre><p>  另外，docker自1.13版起会自动设置iptables的FORWARD默认策略为DROP，这可能会影响Kubernetes集群依赖的报文转发功能，因此，需要在docker服务启动后，重新将FORWARD链的默认策略设备为ACCEPT，方式是修改/usr/lib/systemd/system/docker.service文件，在“ExecStart=/usr/bin/dockerd”一行之后新增一行如下内容：</p>
<pre><code>ExecStartPost=/usr/sbin/iptables -P FORWARD ACCEPT</code></pre><p>  重载完成后即可启动docker服务：</p>
<pre><code>systemctl daemon-reload

systemctl start docker.service</code></pre><p>  而后设定docker和kubelet随系统引导自动启动：</p>
<pre><code>systemctl enable docker kubelet</code></pre><h2 id="四、初始化主节点（在master01上完成如下操作）"><a href="#四、初始化主节点（在master01上完成如下操作）" class="headerlink" title="四、初始化主节点（在master01上完成如下操作）"></a>四、初始化主节点（在master01上完成如下操作）</h2><p>1、初始化init</p>
<pre><code>kubeadm init --kubernetes-version=1.18.2 --apiserver-advertise-address=192.168.1.100  --image-repository registry.aliyuncs.com/google_containers  --service-cidr=10.10.0.0/16 --pod-network-cidr=10.122.0.0/16  </code></pre><p>  master初始化日志</p>
<pre><code>[mark-control-plane] Marking the node master01 as control-plane by adding the taints [node-role.kubernetes.io/master:NoSchedule]
[bootstrap-token] Using token: 946w2y.xhj1wukp35zu6ppb
[bootstrap-token] Configuring bootstrap tokens, cluster-info ConfigMap, RBAC Roles
[bootstrap-token] configured RBAC rules to allow Node Bootstrap tokens to get nodes
[bootstrap-token] configured RBAC rules to allow Node Bootstrap tokens to post CSRs in order for nodes to get long term certificate credentials
[bootstrap-token] configured RBAC rules to allow the csrapprover controller automatically approve CSRs from a Node Bootstrap Token
[bootstrap-token] configured RBAC rules to allow certificate rotation for all node client certificates in the cluster
[bootstrap-token] Creating the &quot;cluster-info&quot; ConfigMap in the &quot;kube-public&quot; namespace
[kubelet-finalize] Updating &quot;/etc/kubernetes/kubelet.conf&quot; to point to a rotatable kubelet client certificate and key
[addons] Applied essential addon: CoreDNS
[addons] Applied essential addon: kube-proxy

Your Kubernetes control-plane has initialized successfully!

To start using your cluster, you need to run the following as a regular user:

  mkdir -p $HOME/.kube
  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
  sudo chown $(id -u):$(id -g) $HOME/.kube/config

You should now deploy a pod network to the cluster.
Run &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at:
  https://kubernetes.io/docs/concepts/cluster-administration/addons/

Then you can join any number of worker nodes by running the following on each as root:

kubeadm join 192.168.1.100:6443 --token 946w2y.xhj1wukp35zu6ppb \
    --discovery-token-ca-cert-hash sha256:93253b79ac5f2a3f32ee7d76e4d7d75cb2bbcd9190132a931c7ea5d5985521a1 </code></pre><p>  上面master初始化的日志需要保留   token值创建node节点的时候需要用到</p>
<p>2、初始化kubectl</p>
<p>  kubectl是kube-apiserver的命令行客户端程序，实现了除系统部署之外的几乎全部的管理操作，是kubernetes管理员使用最多的命令之一。kubectl需经由API server认证及授权后方能执行相应的管理操作，kubeadm部署的集群为其生成了一个具有管理员权限的认证配置文件/etc/kubernetes/admin.conf，它可由kubectl通过默认的“$HOME/.kube/config”的路径进行加载。当然，用户也可在kubectl命令上使用–kubeconfig选项指定一个别的位置。</p>
<p>  下面复制认证为Kubernetes系统管理员的配置文件至目标用户（例如当前用户root）的家目录下：</p>
<pre><code>mkdir -p $HOME/.kube
cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
chown $(id -u):$(id -g) $HOME/.kube/config</code></pre><p>  而后，即可通过kubectl进行客户端命令测试，并借此了解集群组件的当前状态：</p>
<pre><code>kubectl get componentstatus</code></pre><p>一个正常的输出应该类似如下输出结果所示：</p>
<pre><code>NAME STATUS MESSAGE ERROR

controller-manager Healthy ok

scheduler Healthy ok

etcd-0 Healthy {&quot;health&quot;: &quot;true&quot;}</code></pre><p>3、添加flannel网络附件  </p>
<p>  Kubernetes系统上Pod网络的实现依赖于第三方插件进行，这类插件有近数十种之多，较为著名的有flannel、calico、canal和kube-router等，简单易用的实现是为CoreOS提供的flannel项目。下面的命令用于在线部署flannel至Kubernetes系统之上：</p>
<pre><code>kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</code></pre><p>  如果无法访问网站需要手动创建文件    kube-flannel.yaml<br>  <br>由于内容太长保存在下面网站中：<br><br>    <a href="https://xinlong.youare.ink/2020/05/24/kube-flannel/" target="_blank" rel="noopener">https://xinlong.youare.ink/2020/05/24/kube-flannel/</a><br>  <br>然后执行<br></p>
<pre><code>kubectl apply -f kube-flannel.yaml</code></pre><p>  稍等几秒后使用如下命令确认其输出结果中Pod的状态为“Running”，</p>
<pre><code>kubectl get pods -n kube-system -l app=flannel</code></pre><p>  类似如下所示：</p>
<pre><code>NAME READY STATUS RESTARTS AGE

kube-flannel-ds-amd64-wscnz 1/1 Running 0 14m</code></pre><p>4、验正master节点已经就绪</p>
<pre><code>kubectl get nodes</code></pre><p>  上述命令应该会得到类似如下输出：</p>
<pre><code>NAME STATUS ROLES AGE VERSION

master01.ilinux.io Ready master 4m9s v1.12.1</code></pre><h2 id="五、添加节点到集群中（在node01和node02上分别完成如下操作）"><a href="#五、添加节点到集群中（在node01和node02上分别完成如下操作）" class="headerlink" title="五、添加节点到集群中（在node01和node02上分别完成如下操作）"></a>五、添加节点到集群中（在node01和node02上分别完成如下操作）</h2><p>1、忽略Swap相关的预检错误</p>
<p>  若未禁用Swap设备，编辑kubelet的配置文件/etc/sysconfig/kubelet，设置其忽略Swap启用的状态错误，内容如下：</p>
<pre><code>KUBELET_EXTRA_ARGS=&quot;--fail-swap-on=false&quot;</code></pre><p>  提示：若节点禁用了所有的Swap设备，并无须执行此步骤。</p>
<p>2、添加节点</p>
<p> 将节点加入第二步中创建的master的集群中，要使用主节点初始化过程中记录的kubeadm join命令，并且在未禁用Swap设备的情况下，额外附加“–ignore-preflight-errors=Swap”选项；下面的命令来自于前面初始master时运行的kubeadm init命令的输出结果。</p>
<p>   kubeadm join 192.168.1.100:6443 –token 946w2y.xhj1wukp35zu6ppb     –discovery-token-ca-cert-hash sha256:93253b79ac5f2a3f32ee7d76e4d7d75cb2bbcd9190132a931c7ea5d5985521a1     –ignore-preflight-errors=Swap</p>
<p>在node服务器上执行scp  把master上的admin.conf文件拉取到/etc/kubernetes/admin.conf             </p>
<pre><code>scp root@192.168.1.100:/etc/kubernetes/admin.conf /etc/kubernetes/admin.conf             </code></pre><p>设置环境变量</p>
<pre><code>export KUBECONFIG=/etc/kubernetes/admin.conf </code></pre><p>  在每个节点添加完成后，即可通过kubectl验正添加结果。下面的命令及其输出是在node01和node02均添加完成后运行的，其输出结果表明两个Node已经准备就绪。</p>
<pre><code>kubectl get nodes</code></pre><p>  输出：</p>
<pre><code>NAME STATUS ROLES AGE VERSION

master01.magedu.com Ready master 31m v1.12.1

node01.magedu.com Ready &lt;none&gt; 3m8s v1.12.1

node02.magedu.com Ready &lt;none&gt; 2m25s v1.12.1</code></pre><p>  到此为止，一个master，并附带有两个node的kubernetes集群基础设施已经部署完成，用户随后即可测试其核心功能。例如，下面的命令可将myapp以Pod的形式编排运行于集群之上，并通过在集群外部进行访问：</p>
<pre><code>kubectl create deployment myapp --image=ikubernetes/myapp:v1

kubectl create service nodeport myapp --tcp=80:80</code></pre><p>  而后，使用如下命令了解Service对象myapp使用的NodePort，以便于在集群外部进行访问：</p>
<pre><code>kubectl get svc -l app=myapp</code></pre><p>  输出：</p>
<pre><code>NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE

myapp NodePort 10.102.254.75 &lt;none&gt; 80:31257/TCP 2m32s</code></pre><p>myapp是一个web应用，因此，用户可以于集群外部通过“<a href="http://NodeIP:31257”这个URL访问myapp上的应用，例如于集群外通过浏览器访问“http://172.20.0.61:31257”。">http://NodeIP:31257”这个URL访问myapp上的应用，例如于集群外通过浏览器访问“http://172.20.0.61:31257”。</a></p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>史上最全breeze安装k8s文档</title>
    <url>/2020/05/21/breeze/</url>
    <content><![CDATA[<p>在我们的实验环境中准备了四台服务器，配置与角色如下（如果需要增加 Minion/Worker 节点请自行准备即可）：<br><img src="/2020/05/21/breeze/1.png" alt></p>
<h2 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h2><h2 id="一、准备部署主机（deploy-192-168-9-10）"><a href="#一、准备部署主机（deploy-192-168-9-10）" class="headerlink" title="一、准备部署主机（deploy / 192.168.9.10）"></a>一、准备部署主机（deploy / 192.168.9.10）</h2><p>（1）以标准 Minimal 方式安装 CentOS 7.6 (1810) x64 之后(7.4 和 7.5 也支持)，登录 shell 环境，执行以下命令关闭防火墙：<br>setenforce 0</p>
<pre><code>systemctl stop firewalld.service

systemctl stop iptables.service

systemctl disable firewalld.service

systemctl disable iptables.service</code></pre><p>（2）安装 docker-compose 命令</p>
<pre><code>curl -L https://github.com/docker/compose/releases/download/1.21.2/docker-compose-$(uname -s)-$(uname -m) -o /usr/local/bin/docker-compose

chmod +x /usr/local/bin/docker-compose</code></pre><p>（3）安装 docker</p>
<pre><code>yum install docker
systemctl enable docker &amp;&amp; systemctl start docker</code></pre><p>（4）建立部署主机到其它所有服务器的 ssh 免密登录途径<br>    a) 生成秘钥，执行：</p>
<pre><code>    ssh-keygen

b) 针对目标服务器做 ssh 免密登录，依次执行：

    ssh-copy-id 192.168.1.100
    ssh-copy-id 192.168.1.101
    ssh-copy-id 192.168.1.102
    ssh-copy-id 192.168.1.103
    ssh-copy-id 192.168.1.104</code></pre><h2 id="二、获取针对-K8S-某个具体版本的-Breeze-资源文件并启动部署工具，例如此次实验针对刚刚发布的-K8S-v1-13-1"><a href="#二、获取针对-K8S-某个具体版本的-Breeze-资源文件并启动部署工具，例如此次实验针对刚刚发布的-K8S-v1-13-1" class="headerlink" title="二、获取针对 K8S 某个具体版本的 Breeze 资源文件并启动部署工具，例如此次实验针对刚刚发布的 K8S v1.13.1"></a>二、获取针对 K8S 某个具体版本的 Breeze 资源文件并启动部署工具，例如此次实验针对刚刚发布的 K8S v1.13.1</h2><pre><code>curl -L https://raw.githubusercontent.com/wise2c-devops/breeze/v1.13.1/docker-compose.yml -o docker-compose.yml</code></pre><p>  如果无法访问此网站，复制一下内容到文件中命名为   docker-compose.yml</p>
<pre><code>vim   docker-compose.yml

  version: &apos;2&apos;
  services:
    deploy:
      container_name: deploy-main
      image: registry.cn-shenzhen.aliyuncs.com/breeze-project/pagoda:v1.2.0
      restart: always
      entrypoint: sh
      command:
      - -c
      - &quot;/root/pagoda -logtostderr -v 4 -w /workspace&quot;
      ports:
      - 88:80
      - 8088:8080
      volumes:
      - $HOME/.ssh:/root/.ssh
      - $PWD/deploy:/deploy
      volumes_from:
      - playbook
    ui:
      container_name: deploy-ui
      image: registry.cn-shenzhen.aliyuncs.com/breeze-project/deploy-ui:v1.8
      restart: always
      network_mode: &quot;service:deploy&quot;
    playbook:
      container_name: deploy-playbook
      image: registry.cn-shenzhen.aliyuncs.com/breeze-project/playbook:v1.18.2
      volumes:
      - playbook:/workspace
    yum-repo:
      container_name: deploy-yumrepo
      image: registry.cn-shenzhen.aliyuncs.com/breeze-project/yum-repo:v1.18.2
      ports:
      - 2009:2009 
      restart: always
  volumes:
    playbook:
      external: false</code></pre><h2 id="三、访问部署工具的浏览器页面-部署机-IP-及端口-88-，开始部署工作"><a href="#三、访问部署工具的浏览器页面-部署机-IP-及端口-88-，开始部署工作" class="headerlink" title="三、访问部署工具的浏览器页面(部署机 IP 及端口 88)，开始部署工作"></a>三、访问部署工具的浏览器页面(部署机 IP 及端口 88)，开始部署工作</h2><p>  <a href="http://192.168.1.199:88" target="_blank" rel="noopener">http://192.168.1.199:88</a></p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>ssl证书申请</title>
    <url>/2020/05/21/ssl/</url>
    <content><![CDATA[<h2 id="SSL证书申请"><a href="#SSL证书申请" class="headerlink" title="SSL证书申请"></a>SSL证书申请</h2><p><br>1、 购买证书 （免费版一年）<br><br>2、证书申请   –&gt; 绑定域名    子域名随便起   例如     qwer.effc.ltd    qwer任意<br><br>3、在此域名解析看到有一条TXT记录值，然后返回证书申请点击认证  然后提交<br></p>
<p>认证通过后直接下载证书   （nginx证书   会有.key    .pem  两个秘钥文件）</p>
]]></content>
      <categories>
        <category>阿里云</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>阿里云</tag>
      </tags>
  </entry>
  <entry>
    <title>pm2安装报错</title>
    <url>/2020/05/20/pm2/</url>
    <content><![CDATA[<h2 id="使用npm安装pm2报错"><a href="#使用npm安装pm2报错" class="headerlink" title="使用npm安装pm2报错"></a>使用npm安装pm2报错</h2><pre><code>sudo  npm  -g  install   pm2  </code></pre><p>报错日志</p>
<pre><code>gyp WARN EACCES user &quot;root&quot; does not have permission to access the dev dir &quot;/root/.node-gyp/4.9.1&quot;
gyp WARN EACCES attempting to reinstall using temporary dev dir &quot;/usr/lib/node_modules/pm2/node_modules/@pm2/agent/node_modules/utf-8-validate/.node-gyp&quot;
make: Entering directory `/usr/lib/node_modules/pm2/node_modules/@pm2/agent/node_modules/utf-8-validate/build&apos;
  CC(target) Release/obj.target/validation/src/validation.o
make: cc: Command not found
make: *** [Release/obj.target/validation/src/validation.o] Error 127
make: Leaving directory `/usr/lib/node_modules/pm2/node_modules/@pm2/agent/node_modules/utf-8-validate/build&apos;
gyp ERR! build error 
gyp ERR! stack Error: `make` failed with exit code: 2
gyp ERR! stack     at ChildProcess.onExit (/usr/lib/node_modules/npm/node_modules/node-gyp/lib/build.js:276:23)
gyp ERR! stack     at emitTwo (events.js:87:13)
gyp ERR! stack     at ChildProcess.emit (events.js:172:7)
gyp ERR! stack     at Process.ChildProcess._handle.onexit (internal/child_process.js:211:12)
gyp ERR! System Linux 3.10.0-957.el7.x86_64
gyp ERR! command &quot;/usr/bin/node&quot; &quot;/usr/lib/node_modules/npm/node_modules/node-gyp/bin/node-gyp.js&quot; &quot;rebuild&quot;
gyp ERR! cwd /usr/lib/node_modules/pm2/node_modules/@pm2/agent/node_modules/utf-8-validate
gyp ERR! node -v v4.9.1
gyp ERR! node-gyp -v v3.4.0
gyp ERR! not ok </code></pre><p>这个意思是因为node版本太低很多依赖库无法使用</p>
<p>更换镜像重试下</p>
<pre><code>sudo  npm install -g pm2 --registry=https://registry.npm.taobao.org  </code></pre><p>使用cnpm安装试下</p>
<pre><code>sudo  npm install -g cnpm --registry=https://registry.npm.taobao.org  
sudo  cnpm install -g  pm2</code></pre><p>还是报错，只有升级node的版本了</p>
<h2 id="node有一个模块叫-n-，是专门用来管理node-js的版本的"><a href="#node有一个模块叫-n-，是专门用来管理node-js的版本的" class="headerlink" title="node有一个模块叫 n ，是专门用来管理node.js的版本的"></a>node有一个模块叫 n ，是专门用来管理node.js的版本的</h2><p><br>第一步：首先安装n模块:<br></p>
<pre><code>sudo  npm install -g n</code></pre><p>第二步：升级node.js到最新稳定版</p>
<pre><code>n stable</code></pre><p>第二步：n后面也可以跟随版本号比如</p>
<pre><code>n v0.10.26
n 0.10.26</code></pre><p>安装管理命令</p>
<pre><code>sudo npm install -g n  

[sgsm@f069vn-thamdinh yum.repos.d]$ sudo n stable

  installing : node-v12.16.3
      mkdir : /usr/local/n/versions/node/12.16.3
      fetch : https://nodejs.org/dist/v12.16.3/node-v12.16.3-linux-x64.tar.xz
  installed : v12.16.3 to /usr/local/bin/node
      active : v4.9.1 at /bin/node</code></pre><p>升级node之后就可以安装pm2了</p>
<pre><code>[sgsm@f069vn-thamdinh yum.repos.d]$ pm2 list             

                        -------------

__/\\\\\\\\\\\\\____/\\\\____________/\\\\____/\\\\\\\\\_____
_\/\\\/////////\\\_\/\\\\\\________/\\\\\\__/\\\///////\\\___
  _\/\\\_______\/\\\_\/\\\//\\\____/\\\//\\\_\///______\//\\\__
  _\/\\\\\\\\\\\\\/__\/\\\\///\\\/\\\/_\/\\\___________/\\\/___
    _\/\\\/////////____\/\\\__\///\\\/___\/\\\________/\\\//_____
    _\/\\\_____________\/\\\____\///_____\/\\\_____/\\\//________
      _\/\\\_____________\/\\\_____________\/\\\___/\\\/___________
      _\/\\\_____________\/\\\_____________\/\\\__/\\\\\\\\\\\\\\\_
        _\///______________\///______________\///__\///////////////__


                          Runtime Edition

        PM2 is a Production Process Manager for Node.js applications
                    with a built-in Load Balancer.

                Start and Daemonize any application:
                $ pm2 start app.js

                Load Balance 4 instances of api.js:
                $ pm2 start api.js -i 4

                Monitor in production:
                $ pm2 monitor

                Make pm2 auto-boot at server restart:
                $ pm2 startup

                To go further checkout:
                http://pm2.io/


                        -------------

[PM2] Spawning PM2 daemon with pm2_home=/home/sgsm/.pm2
[PM2] PM2 Successfully daemonized
┌─────┬───────────┬─────────────┬─────────┬─────────┬──────────┬────────┬──────┬───────────┬──────────┬──────────┬──────────┬──────────┐
│ id  │ name      │ namespace   │ version │ mode    │ pid      │ uptime │ ↺    │ status    │ cpu      │ mem      │ user     │ watching │
└─────┴───────────┴─────────────┴─────────┴─────────┴──────────┴────────┴──────┴───────────┴──────────┴──────────┴──────────┴──────────┘</code></pre><p>其实到这里就出现了很大的问题了，首先应该需要确定下代码是否支持node的高版本，所以更改node版本后其他进程就会有问题<br><br>(还好是测试服，如果正式服我估计现在已经没办法写这个文档了)<br></p>
<p>最后只能还原node版本</p>
<pre><code>sudo n   v4.4.4</code></pre><h2 id="然后把进程启动，关于安装pm2只能使用下面的办法了"><a href="#然后把进程启动，关于安装pm2只能使用下面的办法了" class="headerlink" title="然后把进程启动，关于安装pm2只能使用下面的办法了"></a>然后把进程启动，关于安装pm2只能使用下面的办法了</h2><p><br>找一个同版本node并且已经安装pm2的机器<br></p>
<pre><code>[sgsm@f069vn-thamdinh ~]$ rpm -ql  nodejs  |head  -30
/usr/bin/node
/usr/bin/npm
/usr/lib/node_modules
/usr/lib/node_modules/npm
/usr/lib/node_modules/npm/.mailmap
/usr/lib/node_modules/npm/.npmignore
/usr/lib/node_modules/npm/.travis.yml
/usr/lib/node_modules/npm/AUTHORS
/usr/lib/node_modules/npm/CHANGELOG.md
/usr/lib/node_modules/npm/CONTRIBUTING.md
/usr/lib/node_modules/npm/LICENSE
/usr/lib/node_modules/npm/Makefile</code></pre><p>查看到nodejs模板文件的安装位置然后进入目录</p>
<pre><code>cd /usr/lib/node_modules/</code></pre><p>ls会查看到有一个pm2的目录</p>
<pre><code>[sgsm@localhost node_modules]$ ll
总用量 4
drwxr-xr-x 9 root   root  4096 12月 12 2018 npm
drwxr-xr-x 5 nobody users  320 5月   6 2019 pm2
drwxr-xr-x 8 nobody root   267 12月 12 2018 pomelo</code></pre><p>直接使用tar打包</p>
<pre><code>tar czf  pm2.tar.gz  pm2/</code></pre><p>最后传到需要安装pm2的机器</p>
<p>然后去相同的目录解压</p>
<pre><code>sudo  tar  xf  pm2.tar.gz </code></pre><p>设置环境变量</p>
<pre><code>sudo vim /etc/profile
    export PM2_HOME=/usr/lib/node_modules/pm2
    export PATH=$PM2_HOME/bin:$PATH</code></pre><p>生效环境变量</p>
<pre><code>source  /etc/profile</code></pre><p>由于pm2这个命令在pm2/bin/下面 所以设置个软连接 方便使用</p>
<pre><code>sudo ln -s /usr/lib/node_modules/pm2/bin/pm2 /usr/bin/pm2</code></pre><p>执行试下是否报错 </p>
<pre><code>pm2 list </code></pre><p>我这里是遇到了权限的问题给下用户权限就可以了</p>
<pre><code>sudo chown  sgsm.sgsm   pm2 -R</code></pre><p>至此pm2 成功安装</p>
<p>最后最后最后最后最后最后  经过神秘大佬的指点</p>
<pre><code>sudo  npm -g install  pm2@版本号</code></pre><p>可以安装指定的低版本pm2</p>
<p>写完这篇文档就GG</p>
<p>等下 还有几个npm的常用命令分享</p>
<pre><code>npm -v #显示版本，检查npm 是否正确安装。

npm install express #安装express模块

npm install -g express #全局安装express模块

npm list #列出已安装模块

npm show express #显示模块详情

npm update #升级当前目录下的项目的所有模块

npm update express #升级当前目录下的项目的指定模块

npm update -g express #升级全局安装的express模块

npm uninstall express #删除指定的模块</code></pre>]]></content>
      <categories>
        <category>运维</category>
        <category>开发</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>pm2</tag>
      </tags>
  </entry>
  <entry>
    <title>一个奇怪的报错</title>
    <url>/2020/05/19/strange/</url>
    <content><![CDATA[<p>前因：因为程序需要node的启动进行需要改到80端口，改过之后却报错</p>
<pre><code>Error: listen EACCES 0.0.0.0:80</code></pre><p>过程：这个报错是端口冲突，然后就排查服务器是否某个进程把80端口占用</p>
<pre><code>sudo netstat -ntpla  |grep  80</code></pre><p>结果什么都没有</p>
<pre><code>sudo  lsof -i:80</code></pre><p>也没有查到这个端口，百度各种搜资料也是无望马上要爆炸的时候一位神秘的大佬给了一个网站</p>
<p><img src="/2020/05/19/strange/1.png" alt><br>看到后就崩溃了</p>
<pre><code>翻译：如果 需要在80端口上运行服务，则需要使用反向代理（如nginx），它将使用首选端口上的系统账户运行，并将请求代理到运行在未观端口（&gt;1024）</code></pre><p>结语：官方文档看到不够多</p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>mvn环境配置</title>
    <url>/2020/05/18/mvn/</url>
    <content><![CDATA[<h2 id="配置jdk环境变量"><a href="#配置jdk环境变量" class="headerlink" title="配置jdk环境变量"></a>配置jdk环境变量</h2><p>创建目录</p>
<pre><code>mkdir /application/ </code></pre><p>解压jdk包到创建的目录中</p>
<pre><code>tar xf jdk-8u60-linux-x64.tar.gz   -C /application/</code></pre><p>做软连接</p>
<pre><code>ln -s  /application/jdk1.8.0_60/ /application/jdk</code></pre><p>设置环境变量</p>
<pre><code>sed -i.ori &apos;$a export  JAVA_HOME=/application/jdk\nexport PATH=$JAVA_HOME/bin:$JAVA_HOME/jre/bin:$PATH\nexport  CLASSPATH=.$CLASSPATH:$JAVA_HOME/lib:$JAVA_HOME/jre/lib:$JAVA_HOME/lib/tools.jar&apos;  /etc/profile</code></pre><p>source一下生效环境变量</p>
<h2 id="配置mvn环境变量"><a href="#配置mvn环境变量" class="headerlink" title="配置mvn环境变量"></a>配置mvn环境变量</h2><pre><code>cd /application/ </code></pre><p>下载mvn包</p>
<pre><code>wget http://mirrors.hust.edu.cn/apache/maven/maven-3/3.5.4/binaries/apache-maven-3.5.4-bin.tar.gz</code></pre><p>解压</p>
<pre><code>tar -zxvf apache-maven-3.5.4-bin.tar.gz</code></pre><p>vim /etc/profile</p>
<pre><code>export MAVEN_HOME=/application/apache-maven-3.0.5
export PATH=$PATH:$MAVEN_HOME/bin</code></pre><p>source一下生效环境变量</p>
<p>最后可以使用mvn -v 查看</p>
<pre><code>[sgsm@localhost weblog]$ mvn  -v
Apache Maven 3.5.4 (1edded0938998edf8bf061f1ceb3cfdeccf443fe; 2018-06-18T02:33:14+08:00)
Maven home: /home/sgsm/test3/apache-maven-3.5.4
Java version: 1.8.0_60, vendor: Oracle Corporation, runtime: /application/jdk1.8.0_60/jre
Default locale: zh_CN, platform encoding: UTF-8
OS name: &quot;linux&quot;, version: &quot;3.10.0-514.21.2.el7.x86_64&quot;, arch: &quot;amd64&quot;, family: &quot;unix&quot;</code></pre><p>接下来就可以使用mvn打jar包了</p>
<pre><code>mvn clean package </code></pre>]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>mvn</tag>
      </tags>
  </entry>
  <entry>
    <title>Git无法添加主题文件夹</title>
    <url>/2020/05/17/gitremove/</url>
    <content><![CDATA[<p>由于主题都是在git上下载的所以默认会有一个.git的文件，这样导致提交的时候无法提交主题文件<br><br>解决办法<br></p>
<p>删除主题文件夹下.git</p>
<pre><code>git rm --cached themes/hexo-theme-ayer
git add .
git commit -m &quot;xxx&quot;
git push origin master</code></pre>]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>大于2T的硬盘需要parted磁盘分区</title>
    <url>/2020/05/16/parted/</url>
    <content><![CDATA[<h2 id="首先安装parted"><a href="#首先安装parted" class="headerlink" title="首先安装parted"></a>首先安装parted</h2><pre><code>yum install parted   -y</code></pre><p>查看硬盘情况使用fdisk -l 查看分区情况，对于大于2TB的硬盘用parted分区<br><br>格式化 /dev/sdb<br></p>
<pre><code>parted /dev/sdb</code></pre><p>使用print打印分区信息</p>
<pre><code>(parted) print</code></pre><p>将分区设置成gpt格式</p>
<pre><code>mklabel gpt    </code></pre><p>将所有空间创建一个分区</p>
<pre><code>mkpart primary 0 100%</code></pre><p>退出</p>
<pre><code>quit</code></pre><h2 id="将硬盘分为两个主分区"><a href="#将硬盘分为两个主分区" class="headerlink" title="将硬盘分为两个主分区"></a>将硬盘分为两个主分区</h2><pre><code>[root@localhost ~]# parted /dev/sdb   
GNU Parted 1.8.1 Using /dev/sdb Welcome to GNU Parted! Type ‘help’ to view a list of commands.
(parted) mklabel gpt           # 将MBR磁盘格式化为GPT
(parted) print                       #打印当前分区
(parted) mkpart primary 0 4.5TB                # 分一个4.5T的主分区
(parted) mkpart primary 4.5TB 12TB      # 分一个7.5T的主分区
(parted) print                         #打印当前分区
(parted) quit 退出</code></pre>]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>parted</tag>
      </tags>
  </entry>
  <entry>
    <title>centos安装samba文件共享--隐藏目录</title>
    <url>/2020/05/14/samba/</url>
    <content><![CDATA[<h2 id="配置环境–关闭防火墙和selinux"><a href="#配置环境–关闭防火墙和selinux" class="headerlink" title="配置环境–关闭防火墙和selinux"></a>配置环境–关闭防火墙和selinux</h2><p><br>centos6<br></p>
<pre><code>service  iptables  stop
service  ip6tables  stop</code></pre><p>centos7</p>
<pre><code>systemctl stop  firewalld</code></pre><p>永久关闭</p>
<pre><code>chkconfig  iptables  off   
chkconfig  ip6tables  off   </code></pre><p>临时关闭selinux</p>
<pre><code>setenforce 0</code></pre><p>永久关闭selinux</p>
<pre><code>vim  /etc/selinux/config
    SELINUX=disabled</code></pre><p>重启生效</p>
<h2 id="安装samba服务"><a href="#安装samba服务" class="headerlink" title="安装samba服务"></a>安装samba服务</h2><pre><code>yum  install samba  samba-client  samba-common  samba-doc  -y </code></pre><h2 id="配置samba服务"><a href="#配置samba服务" class="headerlink" title="配置samba服务"></a>配置samba服务</h2><pre><code>cp  /etc/samba/smb.conf  /etc/samba/smb.conf_bak
vim /etc/samba/smb.conf
[global]     #定义全局策略
    workgroup = MYGROUP   #定义工作组
    server string = Samba Server Version %v #服务器提示字符，默认显示samba版本
    log file = /var/log/samba/log.%m    #定义日志文件
    max log size = 50      #定义日志文件单个文件最大容量为50KB
    security = user        #security选项将会影响客户端访问方式       #可以设置user、share、server、domain。User代表用户名和密码验证；share代表匿名访问；server代表基于验证身份的访问，账户信息在另一台SMB服务器上；domain:同样基于验证身份验证，账户信息在活动目录中    
    passdb backend = tdbsam    #账户与密码存储方式，smbpasswd使用老的明文格式存储账户及密码；tdbsam代表基于TDB的密文格式存储；ldapsam代表使用LDAP存储账户资料。
    load printers = yes        #客户端在10分钟内没有打开任何Samba资源，服务器将自动关闭回话。
    cups options = raw       #打印属性

    config file = /etc/samba/%U.smb.conf   #指定扩展文件


[dome]       #共享名称为dome
    comment = Common share
    path = /common        #指定共享目录
    valid users = tom jerry    #有效账户列表
    create mask = 0750        #客户端上传文件的默认权限
    directorymask = 0775       #客户端创建目录的默认权限 
    browseable = yes       #客户端是否对所有人可见    
    writable= no          #是否允许写入
    write list = tom       #写权限账户列表
    admin users = tom       #该共享的管理员，具有完全权限
    invalid users = root bin    #禁止root与bin访问common共享
      guest ok = no       #是否允许匿名访问


[server]
    path = /share/samba/server
    directory  mask = 0755
    create mask = 0644
    valid users = yanfa
    browseable = no

[meishu]
    path = /share/samba/meishu
    directory  mask =0755
    create mask =0644
    valid users = meishu
    browseable = no

[yunyingmeishu]
    path = /share/samba/yunyingmeishu
    directory  mask =0755
    create mask =0644
    valid users = yunying
    browseable = no</code></pre><h2 id="创建扩展文件"><a href="#创建扩展文件" class="headerlink" title="创建扩展文件"></a>创建扩展文件</h2><pre><code>cd /etc/samba/

vim   yanfa.smb.conf  
    [share]
    security = user
    path = /share/samba/yanfa
    valid users = @yanfa
    read list = @yanfa
    write list = @yanfa
    writable = yes
    create mask = 0644
    directory mask = 0755 


vim   meishu.smb.conf   
    [meishu]
    security = user
    path = /share/samba/meishu
    valid users = @meishu
    read list = @meishu
    write list = @meishu
    writable = yes
    create mask = 0644
    directory mask = 0755


vim   yunying.smb.conf 
    [yunying]
    security = user
    path = /share/samba/yunyingmeishu
    valid users = @yunying
    read list = @yunying
    write list = @yunying
    writable = yes
    create mask = 0644
    directory mask = 0755</code></pre><h2 id="创建共享文件夹"><a href="#创建共享文件夹" class="headerlink" title="创建共享文件夹"></a>创建共享文件夹</h2><p>  mkdir /share/samba/{yanfa,meishu,yunyingmeishu}    -p</p>
<h2 id="创建登录用户"><a href="#创建登录用户" class="headerlink" title="创建登录用户"></a>创建登录用户</h2><pre><code>useradd  yanfa
useradd  meishu
useradd  yunying</code></pre><h2 id="创建samba用户–需要交互式输入密码，此密码和系统用户密码无关"><a href="#创建samba用户–需要交互式输入密码，此密码和系统用户密码无关" class="headerlink" title="创建samba用户–需要交互式输入密码，此密码和系统用户密码无关"></a>创建samba用户–需要交互式输入密码，此密码和系统用户密码无关</h2><pre><code>pdbedit -a  yanfa
pdbedit -a  meishu
pdbedit -a  yunying</code></pre><p>pdbedit常用参数</p>
<pre><code>pdbedit -L  ：查看samba用户
pdbedit -Lv：列出Samba用户列表详细信息
pdbedit -a  -u  user：添加samba用户
pdbedit -r  -u  user：修改samba用户信息
pdbedit -x  -u  user： 删除samba用户</code></pre><h2 id="共享文件夹更改权限"><a href="#共享文件夹更改权限" class="headerlink" title="共享文件夹更改权限"></a>共享文件夹更改权限</h2><pre><code>cd  /share/samba/
chown  meishu.meishu  meishu/ -R
chown   yunying.yunying  yunyingmeishu/ -R
chown  yanfa.yanfa  yanfa/ -R</code></pre><h2 id="启动服务就可以访问了"><a href="#启动服务就可以访问了" class="headerlink" title="启动服务就可以访问了"></a>启动服务就可以访问了</h2><pre><code>/etc/init.d/smb  start
/etc/init.d/nmb  start</code></pre><h2 id="好礼大放送–wind客户端清理已保存的samba用户和密码"><a href="#好礼大放送–wind客户端清理已保存的samba用户和密码" class="headerlink" title="好礼大放送–wind客户端清理已保存的samba用户和密码"></a>好礼大放送–wind客户端清理已保存的samba用户和密码</h2><pre><code>net  use      # 查看已保存的用户和密码

net use  *  /del   /y     # 清除所有账号密码</code></pre>]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>samba</tag>
      </tags>
  </entry>
  <entry>
    <title>Mongo常见报错</title>
    <url>/2020/05/14/MongoError/</url>
    <content><![CDATA[<p>mongod宕机常见报错</p>
<pre><code>/data/lib/mongo//WiredTiger.turtle: handle-open: open: Permission denied</code></pre><p>  解决办法直接给权限</p>
<pre><code>sudo chown  mongod.mongod   ./*  -R</code></pre><p>还有一种是非正常关闭mongo再次启动会失败  使用</p>
<pre><code>sudo  journalctl -xe</code></pre><p>查看到报错</p>
<pre><code>Error starting mongod. /var/run/mongodb/mongod.pid exists.</code></pre><p>是因为非正常关闭mongo的时候pid文件还存在，删除后启动就正常了</p>
<p>锁文件报错</p>
<pre><code>2020-06-20T19:55:41.371+0800 W -        [initandlisten] Detected unclean shutdown - /data/lib/mongo/mongod.lock is not empty.</code></pre><p>解决办法</p>
<pre><code>sudo  rm   /data/lib/mongo/mongod.lock</code></pre><p>最大连接数报错</p>
<pre><code>[1592654142:807610][13609:0x7fb0fc34bdc0], file:collection-1898--8679891645894746372.wt, WT_SESSION.open_cursor: /data/lib/mongo//collection-1898--8679891645894746372.wt: handle-open: open: Too many open files
2020-06-20T19:55:42.807+0800 I -        [initandlisten] Invariant failure: ret resulted in status UnknownError: 24: Too many open files at src/mongo/db/storage/wiredtiger/wiredtiger_session_cache.cpp 79</code></pre><p>解决办法</p>
<pre><code>ulimit -n 4096</code></pre><p>查看mongo连接数</p>
<pre><code>db.serverStatus().connections
{ &quot;current&quot; : 80, &quot;available&quot; : 52348, &quot;totalCreated&quot; : NumberLong(367) }</code></pre><p>Current表示当前到实例上正在运行的连接数。<br><br>Available表示当前实例还可以支持的并发连接数。<br></p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>mongo</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>lamp</title>
    <url>/2020/05/13/lamp/</url>
    <content><![CDATA[<!-- 文章头部设置 -->

<blockquote>
<p>&amp;  表示任务在后台执行，如要在后台运行redis-server,则有  redis-server &amp;<br>&amp;&amp; 表示前一条命令执行成功时，才执行后一条命令 ，如 echo ‘1’ &amp;&amp; echo ‘2’<br>| 表示管道，上一条命令的输出，作为下一条命令参数，如 echo ‘yes’ | wc -l<br>|| 表示上一条命令执行失败后，才执行下一条命令，如 cat nofile || echo “fail”</p>
</blockquote>
<h1 id="安装apache"><a href="#安装apache" class="headerlink" title="安装apache"></a>安装apache</h1><h2 id="下载和安装依赖"><a href="#下载和安装依赖" class="headerlink" title="下载和安装依赖"></a>下载和安装依赖</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install autoconf libtool gcc expat expat-devel make zlib-devel gcc-c++ openssl-devel pcre-devel openssl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入 https://mirror.bit.edu.cn/apache//apr/ 找到最新的 apr 和 apr-util 包即可</span></span><br><span class="line">wget https://mirror.bit.edu.cn/apache//apr/apr-1.7.0.tar.gz</span><br><span class="line">wget https://mirror.bit.edu.cn/apache/httpd/httpd-2.4.43.tar.gz</span><br><span class="line">wget https://mirror.bit.edu.cn/apache//apr/apr-util-1.6.1.tar.gz</span><br></pre></td></tr></table></figure>

<h2 id="编译安装apr"><a href="#编译安装apr" class="headerlink" title="编译安装apr"></a>编译安装apr</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 编辑 configure文件，查找 $RM "$cfgfile" 这个地方，用#注释掉</span></span><br><span class="line">31880行 <span class="comment">#    $RM "$cfgfile"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在configure里面 RM='$RM  -f' 这里的$RM后面一定有一个空格。 如果后面没有空格，直接连接减号，就依然会报错。把 RM='$RM' 改为 RM='$RM -f'</span></span><br><span class="line">31279行     RM=<span class="string">'$RM -f'</span></span><br><span class="line"><span class="comment"># 更改上面两行，否则./configure会报错：rm: cannot remove `libtoolT': No such file or directory</span></span><br><span class="line">./configure --prefix=/home/lamp/apr</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<h2 id="编译安装apr-util"><a href="#编译安装apr-util" class="headerlink" title="编译安装apr-util"></a>编译安装apr-util</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指明apr的安装位置--with-apr=/home/lamp/apr</span></span><br><span class="line">./configure --prefix=/home/lamp/apr-util --with-apr=/home/lamp/apr</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<h2 id="编译安装apache"><a href="#编译安装apache" class="headerlink" title="编译安装apache"></a>编译安装apache</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./configure --prefix=/home/lamp/apache2 --with-apr=/home/lamp/apr --with-apr-util=/home/lamp/apr-util</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<h1 id="启动apache"><a href="#启动apache" class="headerlink" title="启动apache"></a>启动apache</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/lamp/apache2</span><br><span class="line"><span class="comment"># 修改端口为800</span></span><br><span class="line">./bin/httpd -k start</span><br><span class="line">curl localhost:800</span><br><span class="line"><span class="comment"># 显示&lt;html&gt;&lt;body&gt;&lt;h1&gt;It works!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="配置基于域名访问不同资源目录"><a href="#配置基于域名访问不同资源目录" class="headerlink" title="配置基于域名访问不同资源目录"></a>配置基于域名访问不同资源目录</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 编辑httpd.conf，在文件最后加入以下几行：</span></span><br><span class="line"></span><br><span class="line">&lt;/IfModule&gt;</span><br><span class="line">&lt;VirtualHost *:800&gt;</span><br><span class="line">    DocumentRoot <span class="string">"/home/lamp/apache2/htdocs/"</span></span><br><span class="line">    ServerName www.example.com</span><br><span class="line">    <span class="comment"># 访问www.example.com会访问/home/lamp/apache2/htdocs/目录下的资源</span></span><br><span class="line"></span><br><span class="line">&lt;/VirtualHost&gt;</span><br><span class="line"></span><br><span class="line">&lt;VirtualHost *:800&gt;</span><br><span class="line">    DocumentRoot <span class="string">"/home/lamp/apache2/htdocs/org/"</span></span><br><span class="line">    ServerName www.example.org</span><br><span class="line">    <span class="comment"># 访问www.example.org会访问/home/lamp/apache2/htdocs/org/目录下的资源</span></span><br><span class="line"></span><br><span class="line">&lt;/VirtualHost&gt;</span><br></pre></td></tr></table></figure>

<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置hosts文件！！！</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /home/lamp/apache2/</span><br><span class="line">mkdir htdocs/org/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑htdocs/index.html填入www.example.com</span></span><br><span class="line">cat &gt; htdocs/index.html &lt;&lt; EOF</span><br><span class="line">www.example.com</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑htdocs/org/index.html填入www.example.org</span></span><br><span class="line">cat &gt; htdocs/org/index.html &lt;&lt; EOF</span><br><span class="line">www.example.org</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启 访问</span></span><br><span class="line">./bin/httpd -k restart</span><br><span class="line"></span><br><span class="line">[root@www apache2]<span class="comment"># curl www.example.org:800</span></span><br><span class="line">www.example.org</span><br><span class="line">[root@www apache2]<span class="comment"># curl www.example.com:800</span></span><br><span class="line">www.example.com</span><br></pre></td></tr></table></figure>

<h2 id="配置基于端口访问不同资源目录"><a href="#配置基于端口访问不同资源目录" class="headerlink" title="配置基于端口访问不同资源目录"></a>配置基于端口访问不同资源目录</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在上文的基础上增加www.example.com:8000端口，直接在配置文件最下面添加以下内容</span></span><br><span class="line">&lt;VirtualHost *:8000&gt;</span><br><span class="line">    DocumentRoot <span class="string">"/home/lamp/apache2/htdocs/8000/"</span></span><br><span class="line">    ServerName www.example.com</span><br><span class="line">    <span class="comment"># 访问www.example.com:8000会访问/htdocs/8000/目录下的资源</span></span><br><span class="line"></span><br><span class="line">&lt;/VirtualHost&gt;</span><br><span class="line"><span class="comment"># 在监听端口下面增加新的监听端口</span></span><br><span class="line">Listen 800</span><br><span class="line">Listen 8000</span><br></pre></td></tr></table></figure>

<h3 id="验证-1"><a href="#验证-1" class="headerlink" title="验证"></a>验证</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir htdocs/8000</span><br><span class="line"></span><br><span class="line">cat &gt; htdocs/8000/index.html &lt;&lt; EOF</span><br><span class="line">www.example.com:8000</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查</span></span><br><span class="line">./bin/httpd -t   <span class="comment"># 显示Syntax OK即可</span></span><br><span class="line"></span><br><span class="line">./bin/httpd -k restart</span><br><span class="line"></span><br><span class="line">[root@www apache2]<span class="comment"># curl www.example.com:8000</span></span><br><span class="line">www.example.com:8000</span><br><span class="line">[root@www apache2]<span class="comment"># curl www.example.com:800</span></span><br><span class="line">www.example.com</span><br><span class="line">[root@www apache2]<span class="comment"># curl www.example.org:800</span></span><br><span class="line">www.example.org</span><br></pre></td></tr></table></figure>

<h2 id="配置基于虚拟主机访问不同资源目录"><a href="#配置基于虚拟主机访问不同资源目录" class="headerlink" title="配置基于虚拟主机访问不同资源目录"></a>配置基于虚拟主机访问不同资源目录</h2><p>&emsp;&emsp;注释掉上面的3个配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 增加新的配置</span></span><br><span class="line"><span class="comment"># 注意！IP地址是主机自带的IP地址，并非虚拟不存在的。改完配置要修改hosts解析！！！</span></span><br><span class="line">&lt;VirtualHost 192.168.1.100&gt;</span><br><span class="line">    DocumentRoot <span class="string">"/home/lamp/apache2/htdocs/100/"</span></span><br><span class="line">    ServerName www.example.com</span><br><span class="line">    <span class="comment"># 访问www.example.com:800会访问htdocs/100/目录下的资源</span></span><br><span class="line"></span><br><span class="line">&lt;/VirtualHost&gt;</span><br><span class="line"></span><br><span class="line">&lt;VirtualHost 192.168.1.200&gt;</span><br><span class="line">    DocumentRoot <span class="string">"/home/lamp/apache2/htdocs/200/"</span></span><br><span class="line">    ServerName www.example.org</span><br><span class="line">    <span class="comment"># 访问www.example.org:800会访问htdocs/200/目录下的资源</span></span><br><span class="line"></span><br><span class="line">&lt;/VirtualHost&gt;</span><br></pre></td></tr></table></figure>
<h3 id="验证-2"><a href="#验证-2" class="headerlink" title="验证"></a>验证</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./bin/httpd -k restart</span><br><span class="line"></span><br><span class="line">mkdir htdocs/&#123;1,2&#125;00</span><br><span class="line">cat &gt; htdocs/100/index.html &lt;&lt; EOF</span><br><span class="line">www.example.com  100</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">cat &gt; htdocs/200/index.html &lt;&lt; EOF</span><br><span class="line">www.example.org  200</span><br><span class="line">EOF</span><br><span class="line">./bin/httpd -k restart</span><br><span class="line"></span><br><span class="line">[root@www apache2]<span class="comment"># curl www.example.com:800</span></span><br><span class="line">www.example.com  100</span><br><span class="line">[root@www apache2]<span class="comment"># curl www.example.org:800</span></span><br><span class="line">www.example.org  200</span><br></pre></td></tr></table></figure>
<h2 id="配置基于简单的用户密码验证访问"><a href="#配置基于简单的用户密码验证访问" class="headerlink" title="配置基于简单的用户密码验证访问"></a>配置基于简单的用户密码验证访问</h2><p>&emsp;&emsp;注释掉上面的配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;Directory /usr/<span class="built_in">local</span>/apache2/htdocs/wang&gt;</span><br><span class="line">        AuthName <span class="string">"wang Auth"</span></span><br><span class="line">        AuthType basic</span><br><span class="line">        AuthUserFile /usr/<span class="built_in">local</span>/apache2/.htpasswd</span><br><span class="line">        Require user wang</span><br><span class="line">&lt;/Directory&gt;</span><br><span class="line"><span class="comment"># AuthName "wang Auth"   该字符串显示在网页访问时输入用户密码的对话框之上，实际测试并未显示</span></span><br><span class="line"><span class="comment"># AuthType basic         定义验证模块类型</span></span><br><span class="line"><span class="comment"># AuthUserFile /file     密码文件的存放地址</span></span><br><span class="line"><span class="comment"># Require user wang      设置哪些用户生效</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面这些注释也能实现用户密码访问，建议留存以便解决一些未知的bug，如果你是yum安装的httpd，你可以直接修改conf.d/userdir.conf文件，直接在最下面增加上述配置即可。</span></span><br><span class="line">&lt;IfModule mod_userdir.c&gt;</span><br><span class="line">    UserDir public_html</span><br><span class="line">&lt;/IfModule&gt;</span><br><span class="line"></span><br><span class="line">&lt;Directory /home/*/public_html&gt;</span><br><span class="line">    AllowOverride FileInfo AuthConfig Limit</span><br><span class="line">    Options MultiViews Indexes SymLinksIfOwnerMatch IncludesNoExec</span><br><span class="line">    &lt;Limit GET POST OPTIONS&gt;</span><br><span class="line">        Order allow,deny</span><br><span class="line">        Allow from all</span><br><span class="line">    &lt;/Limit&gt;</span><br><span class="line">    &lt;LimitExcept GET POST OPTIONS&gt;</span><br><span class="line">        Order deny,allow</span><br><span class="line">        Deny from all</span><br><span class="line">    &lt;/LimitExcept&gt;</span><br><span class="line">&lt;/Directory&gt;</span><br></pre></td></tr></table></figure>

<h3 id="验证-3"><a href="#验证-3" class="headerlink" title="验证"></a>验证</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./bin/httpd -k restart</span><br><span class="line"><span class="comment"># 创建用户：</span></span><br><span class="line">useradd wang</span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/apache2</span><br><span class="line">mkdir htdocs/wang</span><br><span class="line">cat &gt; htdocs/wang/index.html &lt;&lt; EOF</span><br><span class="line">wang auth</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成密码文件，修改密码再次执行此命令即可</span></span><br><span class="line">./bin/htpasswd -c -m /home/lamp/apache2/.htpasswd wang</span><br><span class="line"><span class="comment"># 输入密码a123456</span></span><br><span class="line"></span><br><span class="line">cat .htpasswd</span><br><span class="line"><span class="comment"># 显示 wang:$apr1$eL9wB7zB$F6bE1abbu1vGDVrW4Ji9V1</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th align="left">选项</th>
<th align="left">注释</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-c</td>
<td align="left">自动创建文件，仅应该在文件不存在时使用(初建时使用-c,再次创建不取消该选项则会覆盖之前内容)</td>
</tr>
<tr>
<td align="left">-m</td>
<td align="left">md5格式加密</td>
</tr>
<tr>
<td align="left">-s</td>
<td align="left">sha格式加密</td>
</tr>
<tr>
<td align="left">-D</td>
<td align="left">删除指定用户</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 访问</span></span><br><span class="line">curl www.example.com:800/wang</span><br><span class="line"><span class="comment"># 报错401</span></span><br><span class="line"><span class="comment"># 下载elinks</span></span><br><span class="line">wget http://rpmfind.net/linux/centos/8.1.1911/PowerTools/x86_64/os/Packages/elinks-0.12-0.58.pre6.el8.x86_64.rpm</span><br><span class="line">rpm -ivh elinks-0.12-0.58.pre6.el8.x86_64.rpm</span><br><span class="line"><span class="comment"># elinks访问</span></span><br><span class="line">elinks http://www.example.com:800/wang</span><br><span class="line"><span class="comment"># 输入用户名密码 &gt;&gt; 点击OK &gt;&gt; 点击here （①可以鼠标操作，②可以通过方向键移动光标，enter确认）</span></span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/13/lamp/lamp/0.jpg" alt><br><img src="/2020/05/13/lamp/lamp/1.jpg" alt><br><img src="/2020/05/13/lamp/lamp/2.jpg" alt></p>
<h3 id="扩展基于组用户密码访问"><a href="#扩展基于组用户密码访问" class="headerlink" title="扩展基于组用户密码访问"></a>扩展基于组用户密码访问</h3><p>&emsp;&emsp;上面的<strong>配置不变</strong>，增加两行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;Directory /usr/<span class="built_in">local</span>/apache2/htdocs/wang&gt;</span><br><span class="line">        AuthName <span class="string">"wang Auth"</span></span><br><span class="line">        AuthType basic</span><br><span class="line">        AuthUserFile /usr/<span class="built_in">local</span>/apache2/.htpasswd</span><br><span class="line">        Require user wang</span><br><span class="line">        AuthGroupFile /usr/<span class="built_in">local</span>/apache2/groupfile   <span class="comment"># 组文件</span></span><br><span class="line">        Require group wang   <span class="comment"># 允许的组</span></span><br><span class="line">&lt;/Directory&gt;</span><br><span class="line"><span class="comment"># 通过上面的配置文件可知，允许wang组里面的用户访问，允许用户wang访问</span></span><br></pre></td></tr></table></figure>

<h4 id="验证-4"><a href="#验证-4" class="headerlink" title="验证"></a>验证</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./bin/httpd -k restart</span><br><span class="line">cat &gt; groupfile &lt;&lt; EOF</span><br><span class="line">wang:<span class="built_in">test</span></span><br><span class="line">test0:test0</span><br><span class="line">EOF</span><br><span class="line"><span class="comment"># :前面是组名，后面是用户名；组名等于http.conf中的Require group wang规定的组名</span></span><br><span class="line"><span class="comment"># 增加用户test，test0</span></span><br><span class="line">./bin/htpasswd -m /home/lamp/apache2/.htpasswd <span class="built_in">test</span></span><br><span class="line">./bin/htpasswd -m /home/lamp/apache2/.htpasswd test0</span><br><span class="line"><span class="comment"># 由配置文件可知，允许test，和wang访问，不允许test0访问</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分别输入wang，test，test0用户密码验证即可</span></span><br><span class="line">elinks http://www.example.com:800/wang</span><br></pre></td></tr></table></figure>

<h1 id="一般遇到的问题"><a href="#一般遇到的问题" class="headerlink" title="一般遇到的问题"></a>一般遇到的问题</h1><ol>
<li>httpd.conf配置文件中，填写的路径不对</li>
<li>多使用./bin/httpd -t检查，可以避免很多的粗心错误</li>
<li>修改完配置文件一定记得重启，./bin/httpd -k restart</li>
<li>端口，资源目录，目录权限等，一定要再三验证</li>
<li>你遇到的其它问题欢迎留言~</li>
</ol>
<h1 id="编译MySQL"><a href="#编译MySQL" class="headerlink" title="编译MySQL"></a>编译MySQL</h1><p>&emsp;&emsp;安装依赖</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># MySQL源码地址：https://cdn.mysql.com//Downloads/MySQL-8.0/mysql-8.0.20.tar.gz</span></span><br><span class="line">yum install -y ncurses-devel libtirpc-devel cmake</span><br><span class="line"></span><br><span class="line"><span class="comment"># 缺少：libtirpc-devel</span></span><br><span class="line"><span class="comment"># 报错：Could not find rpc/rpc.h in /usr/include or /usr/include/tirpc</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 缺少：ncurses-devel</span></span><br><span class="line"><span class="comment"># 报错：Curses library not found. Please install appropriate package</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 缺少：rpcsvc</span></span><br><span class="line"><span class="comment"># 报错：Could not find rpcgen</span></span><br><span class="line"><span class="comment"># 编译安装</span></span><br><span class="line">wget https://github.com/thkukuk/rpcsvc-proto/releases/download/v1.4.1/rpcsvc-proto-1.4.1.tar.xz</span><br><span class="line">tar xf rpcsvc-proto-1.4.1.tar.xz</span><br><span class="line"><span class="built_in">cd</span> rpcsvc-proto-1.4.1/</span><br><span class="line">./configure &amp;&amp; make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir /home/lamp/mysql/data -p</span><br><span class="line"></span><br><span class="line">cmake . \</span><br><span class="line">-DCMAKE_INSTALL_PREFIX=/home/lamp/mysql \</span><br><span class="line">-DMYSQL_DATADIR=/home/lamp/mysql/data \</span><br><span class="line">-DMYSQL_UNIX_ADDR=/home/lamp/mysql/mysql.sock \</span><br><span class="line">-DWITH_INNODBBASE_STORAGE_ENGINE=1 \</span><br><span class="line">-DENABLE_LOCAL_INFILE=1 \</span><br><span class="line">-DEXTRA_CHARSETS=all \</span><br><span class="line">-DDEFAULT_CHARSET=utf8 \</span><br><span class="line">-DDEFAULT_COLLATION=utf8_general_ci \</span><br><span class="line">-DMYSQL_USER=mysql \</span><br><span class="line">-DWITH_DEBUG=0 \</span><br><span class="line">-DFORCE_INSOURCE_BUILD=1 \</span><br><span class="line">-DDOWNLOAD_BOOST=1 -DWITH_BOOST=/home/lamp/boost \</span><br><span class="line">-DWITH_EMBEDED_SERVER=0</span><br><span class="line"><span class="comment"># boost下载超时的话，记录下载地址：https://dl.bintray.com/boostorg/release/1.70.0/source/boost_1_70_0.tar.gz</span></span><br><span class="line"><span class="comment"># 使用迅雷下载，大约不到1min就下载好了</span></span><br><span class="line"><span class="comment"># 移动到/home/lamp/boost目录下面</span></span><br></pre></td></tr></table></figure>
<p>编译时间较长长长长长长长长长长长长长长长长😡</p>
<h2 id="一般遇到的问题-1"><a href="#一般遇到的问题-1" class="headerlink" title="一般遇到的问题"></a>一般遇到的问题</h2><ol>
<li>依赖问题</li>
<li>网速太慢</li>
<li>编译的时候内存不足</li>
<li>目录权限</li>
</ol>
<p>不等待直接编译PHP</p>
<h1 id="编译PHP"><a href="#编译PHP" class="headerlink" title="编译PHP"></a>编译PHP</h1><h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install libxml2-devel bzip2-devel net-snmp-devel curl-devel libpng-devel freetype-devel libjpeg-devel -y</span><br><span class="line"></span><br><span class="line">wget http://ftp.gnu.org/gnu/libiconv/libiconv-1.16.tar.gz</span><br><span class="line"><span class="comment"># wget http://ftp.gnu.org/gnu/libiconv/libiconv-1.14.tar.gz</span></span><br><span class="line">./configure --prefix=/usr/<span class="built_in">local</span> --with-apr=/home/lamp/apr</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line"></span><br><span class="line">wget https://sourceforge.net/projects/mcrypt/files/Libmcrypt/2.5.8/libmcrypt-2.5.8.tar.gz</span><br><span class="line">./configure &amp;&amp; make &amp;&amp; make install &amp;&amp; /sbin/ldconfig</span><br><span class="line"><span class="built_in">cd</span> libltdl/</span><br><span class="line">./configure --<span class="built_in">enable</span>-ltdl-install &amp;&amp; make &amp;&amp; make install</span><br><span class="line"></span><br><span class="line">wget https://jaist.dl.sourceforge.net/project/mhash/mhash/0.9.9.9/mhash-0.9.9.9.tar.gz</span><br><span class="line">./configure &amp;&amp; make &amp;&amp; make install</span><br><span class="line">ln -s /usr/<span class="built_in">local</span>/lib/* /usr/lib/</span><br><span class="line">ln -s /usr/<span class="built_in">local</span>/bin/libmcrypt-config /usr/bin/</span><br><span class="line"></span><br><span class="line">wget https://jaist.dl.sourceforge.net/project/mcrypt/MCrypt/2.6.8/mcrypt-2.6.8.tar.gz</span><br><span class="line"><span class="comment"># 解决报错：configure: error: *** libmcrypt was not found</span></span><br><span class="line">ln -s /usr/<span class="built_in">local</span>/bin/libmcrypt_config /usr/bin/libmcrypt_config</span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=/usr/<span class="built_in">local</span>/lib: LD_LIBRARY_PATH</span><br><span class="line">./configure &amp;&amp; make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<h2 id="安装PHP"><a href="#安装PHP" class="headerlink" title="安装PHP"></a>安装PHP</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://www.php.net/distributions/php-7.4.5.tar.gz</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>code</title>
    <url>/2020/05/13/code/</url>
    <content><![CDATA[<p>categories: 测试<br>    #!/usr/bin/python3<br>    def main():<br>        print(“hello world”)</p>
<pre><code>if __name__ == &quot;__mian__&quot;:
    main()</code></pre><h1 id="ceshi"><a href="#ceshi" class="headerlink" title="ceshi"></a>ceshi</h1><pre><code>#!/bin/bash
echo &quot;ceshi&quot;</code></pre><p> cehshi</p>
<pre><code>#!/usr/bin/python3
    def main():
        print(&quot;hello world&quot;)

    if __name__ == &quot;__mian__&quot;:
        main()</code></pre><p>hexo 文章插入图片的方法<br><br>设置站点配置_config.yml:将post_asset_folder: false改为post_asset_folder: true<br><br>安装插件:npm install <a href="https://github.com/CodeFalling/hexo-asset-image" target="_blank" rel="noopener">https://github.com/CodeFalling/hexo-asset-image</a> – save<br><br>运行hexo n “XXXXXX”,生成XXXXX.md博文时就会在/source/_posts目录下生成XXXXXX的文件夹，将你想在XXXXX博文中插入的照片放置到这个同名文件夹中即可，图片的命名随意<br><br>添加图片:在想添加的位置写入![](图片名字.图片格式),例如![](1.png)</p>
]]></content>
  </entry>
  <entry>
    <title>docker--容器创建后添加端口映射</title>
    <url>/2020/05/13/docker/</url>
    <content><![CDATA[<p>标注：[hash_of_the_container] 为容器id</p>
<pre><code>vim /var/lib/docker/containers/[hash_of_the_container]/hostconfig.json</code></pre><p>在 hostconfig.json 里有 “PortBindings”:{} 这个配置项，</p>
<p>改成 </p>
<pre><code>&quot;PortBindings&quot;:{&quot;9001/tcp&quot;:[{&quot;HostIp&quot;:&quot;&quot;,&quot;HostPort&quot;:&quot;900&quot;}]}
      前者为容器端口，后者为宿主机端口</code></pre><p>如果容器内端口从没有暴露，需要在修改config.v2.json</p>
<pre><code>vim /var/lib/docker/containers/[hash_of_the_container]/config.v2.json</code></pre><p>在 config.v2.json 里面添加一个配置项 </p>
<pre><code>&quot;ExposedPorts&quot;:{&quot;80/tcp&quot;:{}} ,</code></pre><p><font color="#FF0000">必须将这个配置项添加到 “Tty”: true, 前面</font></p>
<p>最后重启 docker的守护进程 systemctl restart  docker<br><br>启动容器id   docker start   ID<br></p>
<p>使用docker ps  查看容器端口是否映射<br><img src="/2020/05/13/docker/1.png" alt></p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础之列表</title>
    <url>/2020/04/23/python-3/</url>
    <content><![CDATA[<h2 id="定义一个列表"><a href="#定义一个列表" class="headerlink" title="定义一个列表"></a>定义一个列表</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name_list = [<span class="string">"zhangsan"</span>,<span class="string">"lisi"</span>,<span class="string">"wangwu"</span>,<span class="string">"wangxiaoer"</span>,<span class="string">"wangwu"</span>,<span class="string">"wangxiaoer"</span>]</span><br><span class="line">num_list = [<span class="string">"1"</span>,<span class="string">"3"</span>,<span class="string">"2"</span>,<span class="string">"0"</span>]</span><br></pre></td></tr></table></figure>
<h2 id="增加列表内的指定参数索引和参数"><a href="#增加列表内的指定参数索引和参数" class="headerlink" title="增加列表内的指定参数索引和参数"></a>增加列表内的指定参数索引和参数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name_list = [<span class="string">"zhangsan"</span>,<span class="string">"lisi"</span>,<span class="string">"wangwu"</span>,<span class="string">"wangxiaoer"</span>,<span class="string">"wangwu"</span>,<span class="string">"wangxiaoer"</span>]</span><br><span class="line">name_list.insert(<span class="number">0</span>,<span class="string">"long"</span>)</span><br><span class="line">print(name_list)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test.py
[&apos;long&apos;, &apos;zhangsan&apos;, &apos;lisi&apos;, &apos;wangwu&apos;, &apos;wangxiaoer&apos;, &apos;wangwu&apos;, &apos;wangxiaoer&apos;]

进程已结束，退出代码 0</code></pre><h2 id="增加另一个列表内容到此列表中"><a href="#增加另一个列表内容到此列表中" class="headerlink" title="增加另一个列表内容到此列表中"></a>增加另一个列表内容到此列表中</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name_list = [<span class="string">"zhangsan"</span>,<span class="string">"lisi"</span>,<span class="string">"wangwu"</span>,<span class="string">"wangxiaoer"</span>,<span class="string">"wangwu"</span>,<span class="string">"wangxiaoer"</span>]</span><br><span class="line">num_list = [<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>]</span><br><span class="line">name_list.extend(num_list)</span><br><span class="line">print(name_list)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test.py
[&apos;zhangsan&apos;, &apos;lisi&apos;, &apos;wangwu&apos;, &apos;wangxiaoer&apos;, &apos;wangwu&apos;, &apos;wangxiaoer&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;]

进程已结束，退出代码 0</code></pre><h2 id="增加一个参数到列表的尾部"><a href="#增加一个参数到列表的尾部" class="headerlink" title="增加一个参数到列表的尾部"></a>增加一个参数到列表的尾部</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name_list = [<span class="string">"zhangsan"</span>,<span class="string">"lisi"</span>,<span class="string">"wangwu"</span>,<span class="string">"wangxiaoer"</span>,<span class="string">"wangwu"</span>,<span class="string">"wangxiaoer"</span>]</span><br><span class="line">name_list.append(<span class="string">"long"</span>)</span><br><span class="line">print(name_list)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test.py
[&apos;zhangsan&apos;, &apos;lisi&apos;, &apos;wangwu&apos;, &apos;wangxiaoer&apos;, &apos;wangwu&apos;, &apos;wangxiaoer&apos;, &apos;long&apos;]

进程已结束，退出代码 0</code></pre><h2 id="删除列表内指定的参数"><a href="#删除列表内指定的参数" class="headerlink" title="删除列表内指定的参数"></a>删除列表内指定的参数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name_list = [<span class="string">"zhangsan"</span>,<span class="string">"lisi"</span>,<span class="string">"wangwu"</span>,<span class="string">"wangxiaoer"</span>,<span class="string">"wangwu"</span>,<span class="string">"wangxiaoer"</span>]</span><br><span class="line">name_list.remove(<span class="string">"lisi"</span>)</span><br><span class="line">print(name_list)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test.py
[&apos;zhangsan&apos;, &apos;wangwu&apos;, &apos;wangxiaoer&apos;, &apos;wangwu&apos;, &apos;wangxiaoer&apos;]

进程已结束，退出代码 0</code></pre><h2 id="删除列表内最后一个参数"><a href="#删除列表内最后一个参数" class="headerlink" title="删除列表内最后一个参数"></a>删除列表内最后一个参数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name_list = [<span class="string">"zhangsan"</span>,<span class="string">"lisi"</span>,<span class="string">"wangwu"</span>,<span class="string">"wangxiaoer"</span>,<span class="string">"wangwu"</span>,<span class="string">"wangxiaoer"</span>]</span><br><span class="line">name_list.pop()</span><br><span class="line">print(name_list)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test.py
[&apos;zhangsan&apos;, &apos;lisi&apos;, &apos;wangwu&apos;, &apos;wangxiaoer&apos;, &apos;wangwu&apos;]

进程已结束，退出代码 0</code></pre><h2 id="修改列表内的参数"><a href="#修改列表内的参数" class="headerlink" title="修改列表内的参数"></a>修改列表内的参数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name_list = [<span class="string">"zhangsan"</span>,<span class="string">"lisi"</span>,<span class="string">"wangwu"</span>,<span class="string">"wangxiaoer"</span>,<span class="string">"wangwu"</span>,<span class="string">"wangxiaoer"</span>]</span><br><span class="line">name_list[<span class="number">0</span>] = <span class="string">"xinxin"</span></span><br><span class="line">print(name_list)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test.py
[&apos;xinxin&apos;, &apos;lisi&apos;, &apos;wangwu&apos;, &apos;wangxiaoer&apos;, &apos;wangwu&apos;, &apos;wangxiaoer&apos;]

进程已结束，退出代码 0</code></pre><h2 id="清空列表中的数据"><a href="#清空列表中的数据" class="headerlink" title="清空列表中的数据"></a>清空列表中的数据</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name_list = [<span class="string">"zhangsan"</span>,<span class="string">"lisi"</span>,<span class="string">"wangwu"</span>,<span class="string">"wangxiaoer"</span>,<span class="string">"wangwu"</span>,<span class="string">"wangxiaoer"</span>]</span><br><span class="line">name_list.clear()</span><br><span class="line">print(name_list)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test.py
[]

进程已结束，退出代码 0</code></pre><h2 id="统计列表长度"><a href="#统计列表长度" class="headerlink" title="统计列表长度"></a>统计列表长度</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name_list = [<span class="string">"zhangsan"</span>,<span class="string">"lisi"</span>,<span class="string">"wangwu"</span>,<span class="string">"wangxiaoer"</span>,<span class="string">"wangwu"</span>,<span class="string">"wangxiaoer"</span>]</span><br><span class="line">lenght = len(name_list)</span><br><span class="line">print(lenght)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test.py
6

进程已结束，退出代码 0</code></pre><h2 id="统计数据在列表中出现的次数"><a href="#统计数据在列表中出现的次数" class="headerlink" title="统计数据在列表中出现的次数"></a>统计数据在列表中出现的次数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name_list = [<span class="string">"zhangsan"</span>,<span class="string">"lisi"</span>,<span class="string">"wangwu"</span>,<span class="string">"wangxiaoer"</span>,<span class="string">"wangwu"</span>,<span class="string">"wangxiaoer"</span>]</span><br><span class="line">num = name_list.count(<span class="string">"wangxiaoer"</span>)</span><br><span class="line">print(num)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test.py
2

进程已结束，退出代码 0</code></pre><h2 id="列表中数据排序"><a href="#列表中数据排序" class="headerlink" title="列表中数据排序"></a>列表中数据排序</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name_list = [<span class="string">"CC"</span>,<span class="string">"BB"</span>,<span class="string">"AA"</span>,<span class="string">"DD"</span>,<span class="string">"WW"</span>,<span class="string">"YY"</span>]</span><br><span class="line">num_list = [<span class="string">"1"</span>,<span class="string">"3"</span>,<span class="string">"2"</span>,<span class="string">"0"</span>]</span><br><span class="line">print(num_list)   <span class="comment"># 排序前打印</span></span><br><span class="line">print(name_list)  <span class="comment"># 排序前打印</span></span><br><span class="line">num_list.sort()   <span class="comment"># 排序</span></span><br><span class="line">name_list.sort()  <span class="comment"># 排序</span></span><br><span class="line">print(num_list)   <span class="comment"># 排序后打印</span></span><br><span class="line">print(name_list)   <span class="comment"># 排序后打印</span></span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test.py
[&apos;1&apos;, &apos;3&apos;, &apos;2&apos;, &apos;0&apos;]          #  排序前打印
[&apos;CC&apos;, &apos;BB&apos;, &apos;AA&apos;, &apos;DD&apos;, &apos;WW&apos;, &apos;YY&apos;]    # 排序前打印
[&apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;]         # 排序后打印
[&apos;AA&apos;, &apos;BB&apos;, &apos;CC&apos;, &apos;DD&apos;, &apos;WW&apos;, &apos;YY&apos;]         # 排序后打印

进程已结束，退出代码 0</code></pre><h2 id="打印列表中的数据"><a href="#打印列表中的数据" class="headerlink" title="打印列表中的数据"></a>打印列表中的数据</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">alist = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="string">'bob'</span>, <span class="string">'alice'</span>, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line"><span class="comment"># 打印最后一项</span></span><br><span class="line">print(alist[<span class="number">-1</span>])</span><br><span class="line"><span class="comment"># 因为最后一列是列表,列表还可以继续取下标</span></span><br><span class="line">print(alist[<span class="number">-1</span>][<span class="number">-1</span>])</span><br><span class="line"><span class="comment"># 10 是否在列表中</span></span><br><span class="line">print(<span class="number">10</span> <span class="keyword">in</span> alist)</span><br><span class="line"><span class="comment"># 字符 "qq" 是否在列表中</span></span><br><span class="line">print(<span class="string">"qq"</span> <span class="keyword">in</span> alist)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>D:\软件下载\python.exe E:/资料/python/hexo/test2.py
[1, 2, 3]
3
True
False

进程已结束，退出代码 0</code></pre>]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python-str</title>
    <url>/2020/04/23/python-str/</url>
    <content><![CDATA[<p>code here<br>从字符串中提取字符</p>
<pre><code>str = &quot;hello python&quot;
print(str[7])</code></pre><p>for循环遍历字符串中每一个字符</p>
<pre><code>for c in str:
    print(c)</code></pre><p>统计字符串长度</p>
<pre><code>str = &quot;hello python&quot;
print(len(str))</code></pre><p>统计一个字符在字符串中出现的次数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str = <span class="string">"hello python"</span></span><br><span class="line">print(str.count(<span class="string">"l"</span>))</span><br></pre></td></tr></table></figure>
<pre><code>puts &quot;Awesome!&quot; unless lame</code></pre><pre><code>

    代码

</code></pre>
]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>全球加速--阿里云</title>
    <url>/2020/01/16/jiasu/</url>
    <content><![CDATA[<h1 id="全球加速"><a href="#全球加速" class="headerlink" title="全球加速"></a>全球加速</h1><p>首先确定加速区域以及服务区域<br><br>例如：业务服务器在华北2（北京）,想让美国的玩家流畅访问,需要购买加速区域在北美,服务区域在中国大陆<br></p>
<p>创建全球加速后，会得到一个美国IP，把这个IP和华北2服务器的IP绑定同一个域名，根据解析路线区分解析。<br><br>如果是北京地区访问这个IP，返回的是华北2的服务器IP。相反如果是美国玩家访问，则会返回全球加速的IP。<br></p>
<pre><code>解析路线：比如，DnsCEO的智能DNS就会自动判断用户的上网路线是联通还是电信，然后智能返回联通或者电信的服务器IP。多线多地区智能DNS，能自动判断用户的上网路线是上海电信还是广东电信，然后智能返回对应的上海电信和广东电信的服务器IP。</code></pre><p>例如：<br>    <br>新加坡实例需要拥有弹性公网IP   (ECS控制台–&gt;更多–&gt;网络和安全组–&gt;公网IP转为弹性公网IP)<br></p>
<pre><code>还需要创建个弹性网卡
    网卡名称：自定义
    专有网络：需同ECS同一网络
    交换机：需同ECS同一网络
    安全组：需同ECS同一网络
然后绑定ECS</code></pre><p>创建一个全球加速实例，在全球加速主界面找到实例，然后添加IP(购买个ip就好)。然后点击创建的ip，绑定一个新加坡的实例</p>
<p>最后域名解析</p>
<p>需要购买一个域名版本管理套餐 绑定一个子域名<br>然后用子域名解析A记录</p>
<pre><code>test    A    世界_北美洲     xxx.xxx.xxx.xxx(全球加速ip)
test    A    默认         xxx.xxx.xxx.xxx(服务器ip)</code></pre>]]></content>
      <categories>
        <category>阿里云</category>
      </categories>
      <tags>
        <tag>阿里云</tag>
      </tags>
  </entry>
  <entry>
    <title>mongodb安装以及基础操作</title>
    <url>/2020/01/08/mongo/</url>
    <content><![CDATA[<h1 id="安装mongo数据库"><a href="#安装mongo数据库" class="headerlink" title="安装mongo数据库"></a>安装mongo数据库</h1><pre><code>cd  /etc/yum.repos.d/
vim   mongodb-org-3.2.repo
[mogodb-org]
name=MongoDB Repository
baseurl=http://mirrors.aliyun.com/mongodb/yum/redhat/6Server/mongodb-org/3.4/x86_64/
gpgcheck=0
enabled=1</code></pre><p>然后保存退出</p>
<pre><code>yum clean all    # 清除缓存
yum install  mongod-org  -y</code></pre><h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><pre><code># mongod.conf

# for documentation of all options, see:
#   http://docs.mongodb.org/manual/reference/configuration-options/

# where to write logging data.
systemLog:
  destination: file
  logAppend: true
  path: /var/log/mongodb/mongod.log     #  日志文件路径

# Where and how to store data.
storage:
  dbPath: /var/lib/mongo    # 数据保存路径
  journal:
    enabled: true        # 是否开启
#  engine:
#  mmapv1:
#  wiredTiger:

# how the process runs
processManagement:
  fork: true  # fork and run in background
  pidFilePath: /var/run/mongodb/mongod.pid  # location of pidfile

# network interfaces
net:
  port: 27017        # 监听端口
  bindIp: 192.168.1.163  # 允许连接的IP


#security:
#security:

#  authorization: enabled

#operationProfiling:

#replication:

#sharding:
## Enterprise-Only Options

#auditLog:

#snmp:</code></pre><h1 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h1><pre><code>mongo   IP   #  进入数据库

show  dbs    # 查看所有库

show tables    # 查看当前库的所有表

use   DBNAME    # 进入数据库

db.table.find()        # 查看表中的所有数据

db.table.find({name : xxx})    # 查看表中name为xxx的数据

db.table.find({name : xxx}).pretty()    # 查看表中name为xxx的数据   以json格式显示

db.roles.find({roleID: 626524320},{&quot;userType&quot; : 1,&quot;_id&quot; : 0}) # 只显示某一列

db.table.count()    # 统计数据行数

db.tables.find().count()    # 统计行数   同上

db.table.count({name : xxx})    # 统计name为xxx的行数

db.table.update({},{$set:{name : xxx}})        # 把表中所有数据的name 改为 xxx

db.table.update({name : xxx},{$set:{ID : 666}})        # 把name 为 xxx 的ID 改为666  （只更改匹配到的第一条数据）

db.table.update({name : xxx},{$set:{ID : 666}},false,true)    # 把全部name 为 xxx的ID 改为666  （匹配到的所有数据）

db.payments.update({roleID : xxx, &quot;orderNo&quot; : &quot;xxx&quot;},{$set:{&quot;realMoney_usd&quot; : xxx}},true,false)     # 修改数据如果字段不存在 则新建

db.copyDatabase(&apos;old_name&apos;, &apos;new_name&apos;, &apos;localhost&apos;)    # 复制数据库

use  DBNAME     # 进入数据库
db.dropDatabase()    # 删除当前所在的库

db.table.drop()        # 删除表

db.table.remove({})    # 删除表中所有数据

db.table.remove({name : xxx})    # 删除表中被匹配到的第一条数据

db.table.remove({name : xxx},false,true)    # 删除表中被匹配到的所有数据

use DBNAME     # 进入数据库
db.create.table()    # 创建一个表      如果这个数据库之前不存在  创建表后会自动创建库</code></pre><h1 id="增删改查–扩展"><a href="#增删改查–扩展" class="headerlink" title="增删改查–扩展"></a>增删改查–扩展</h1><pre><code>db.roles.find({&quot;ID&quot;:{&quot;$lte&quot;: 200,&quot;$gte&quot;:155 },userType:41})    # 范围查询  查看ID 小于等于200  大于等于155 并且userType=41 的数据

db.roles.find({ &quot;name&quot; : {$regex:/大气的.*/i}})        # 模糊查询    匹配name 包含&quot;大气的&quot; 数据

db.towers.update({&quot;_id&quot; : ObjectId(&quot;5a6205e275a50f321e04b8ae&quot;)},{$set:{ &quot;levelCustomList.1.state&quot;:2}})        # 把匹配数据的levelCustomlist的第二个字段(state) 的值改为 2

db.oreseasons.update({&quot;_id&quot; : ObjectId(&quot;5ad227d8da0d2e0522930156&quot;)},{$unset:{&quot;groups.0&quot;:&apos;&apos;}},false, true)    # 把匹配数据的groups中第一个字段删除</code></pre><h1 id="数据库的备份以及恢复"><a href="#数据库的备份以及恢复" class="headerlink" title="数据库的备份以及恢复"></a>数据库的备份以及恢复</h1><pre><code>mongodump   -h  IP    -d  DBNAME    -o  dir    # 备份数据库

mongorestore   -h  IP   -d    DBNAME     dir/DBNAME/    # 恢复数据库</code></pre>]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>mongo</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>sshpass</title>
    <url>/2019/12/27/sshpass/</url>
    <content><![CDATA[<h3 id="使用前提：对于未连接过的主机。而又不输入yes进行确认。需要sshd服务的优化："><a href="#使用前提：对于未连接过的主机。而又不输入yes进行确认。需要sshd服务的优化：" class="headerlink" title="使用前提：对于未连接过的主机。而又不输入yes进行确认。需要sshd服务的优化："></a>使用前提：对于未连接过的主机。而又不输入yes进行确认。需要sshd服务的优化：</h3><pre><code># vim /etc/ssh/ssh_config   
StrictHostKeyChecking no
GSSAPIAuthentication no
UseDNS no

# service sshd restart</code></pre><h3 id="sshpass-命令安装："><a href="#sshpass-命令安装：" class="headerlink" title="sshpass 命令安装："></a>sshpass 命令安装：</h3><pre><code># yum -y install sshpass</code></pre><h3 id="sshpass的用法举例"><a href="#sshpass的用法举例" class="headerlink" title="sshpass的用法举例"></a>sshpass的用法举例</h3><pre><code>sshpass -p password ssh -o StrictHostKeyChecking=no lius@192.168.33.56 &quot;ls /tmp&quot;

-p: 指定密码
-o: ssh或scp的一个选项, StrictHostKeyChecking=no表示在第一次主机认证的时候, 自动接收远端主机密钥.</code></pre><h3 id="常用案例"><a href="#常用案例" class="headerlink" title="常用案例"></a>常用案例</h3><pre><code>#!/bin/bash
sshpass  -p password  ssh  -o  StrictHostKeyChecking=no  xxxx@IP  &lt;&lt; restartserver
cd   /subverison/data/
svn update

restartserver</code></pre>]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>sshpass</tag>
      </tags>
  </entry>
  <entry>
    <title>jenkins项目迁移</title>
    <url>/2019/12/24/remove/</url>
    <content><![CDATA[<pre><code>systemctl stop jenkins
cp -rp /var/lib/jenkins /home/jenkins
sed -i s&apos;@/var/lib/jenkins@/home/jenkins@&apos; /etc/sysconfig/jenkins #修改主目录
systemctl start jenkins
rm -rf /var/lib/jenkins</code></pre>]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>jenkins添加普通用户设置权限</title>
    <url>/2019/12/24/jenkins/</url>
    <content><![CDATA[<h3 id="jenkins创建普通用户并配置权限"><a href="#jenkins创建普通用户并配置权限" class="headerlink" title="jenkins创建普通用户并配置权限"></a>jenkins创建普通用户并配置权限</h3><p><br>1、首先在Manage Jenkins –&gt; 用户管理  创建用户<br><br>2、然后在Manage Jenkins –&gt; 全局设置 授权策略选择：<br><br>项目矩阵授权策略  添加用户或者用户组 选择权限<br><br><img src="/2019/12/24/jenkins/1.png" alt><br><br>3、找到需要授权的项目点击配置<br><br><img src="/2019/12/24/jenkins/2.png" alt><br><br>启用项目安全<br><br><img src="/2019/12/24/jenkins/3.png" alt><br><br>添加admin用户以及其他用户<br><br><img src="/2019/12/24/jenkins/4.png" alt><br><br>最后登录测试<br><br><br><br></p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>subversion+jenkinks部署</title>
    <url>/2019/12/03/test/</url>
    <content><![CDATA[<ul>
<li><a href="#1">1.subversion+jenkins安装部署</a><ul>
<li><a href="#2">1.1配置环境</a></li>
<li><a href="#3">1.2安装jenkins</a></li>
<li><a href="#4">1.3安装subversion</a></li>
</ul>
</li>
</ul>
<p>#</p><h4 id="2">1.1配置环境<br>    环境：centos6.9<br>    软件包：jdk-8u60-linux-x64.tar.gz<br>首先关闭selinux和防火墙<br><br><img src="/2019/12/03/test/1.png" alt><br><br>更改时间      &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;–可以写入计划任务中<br><br><img src="/2019/12/03/test/3.png" alt><br><br>创建目录   <p></p>
<pre><code>mkdir /application/</code></pre><p><br>解压jdk包到创建的目录中<br></p>
<pre><code>tar xf jdk-8u60-linux-x64.tar.gz   -C /application/</code></pre><p><br>做软连接<br></p>
<pre><code>ln -s  /application/jdk1.8.0_60/ /application/jdk</code></pre><p><br>设置环境变量<br></p>
<pre><code>sed -i.ori &apos;$a export  JAVA_HOME=/application/jdk\nexport PATH=$JAVA_HOME/bin:$JAVA_HOME/jre/bin:$PATH\nexport  CLASSPATH=.$CLASSPATH:$JAVA_HOME/lib:$JAVA_HOME/jre/lib:$JAVA_HOME/lib/tools.jar&apos;  /etc/profile</code></pre><p><br>source一下生效环境变量<br><br><img src="/2019/12/03/test/2.png" alt><br><br><img src="/2019/12/03/test/4.png" alt><br></p>
<h4 id="3">1.2安装jenkins

<p>下载yum源并且导入秘钥</p>
<br>

<pre><code>wget -O /etc/yum.repos.d/jenkins.repo http://pkg.jenkins-ci.org/redhat/jenkins.repo&lt;br/&gt;

rpm --import https://jenkins-ci.org/redhat/jenkins-ci.org.key</code></pre><p><br><img src="/2019/12/03/test/5.png" alt><br></p>
<pre><code>yum install jenkins -y </code></pre><p><br><img src="/2019/12/03/test/6.png" alt><br></p>
<pre><code>如果安装失败就到官网下载jenkins的rpm包
http://pkg.jenkins-ci.org/redhat-stable/</code></pre><p>编辑配置文件更改端口启动jenkins</p>
<pre><code>vim /etc/sysconfig/jenkins</code></pre><p>找到修改端口号：<br><br>JENKINS_PORT=”8080”  # 此端口不冲突可以不修改<br></p>
<pre><code>service  jenkins  start</code></pre><p><img src="/2019/12/03/test/7.png" alt><br><br>这里会报错 因为Jenkins默认找的jdk环境变量在/usr/bin下  我们需要更改下路径<br></p>
<pre><code>vim  /etc/init.d/jenkins</code></pre><p><br>找到candidates=”   这个配置项<br><br><img src="/2019/12/03/test/8.png" alt><br><br>可以使用这种方式找到路径<br><br><img src="/2019/12/03/test/9.png" alt><br><br>然后在次启动Jenkins    成功<br><br><img src="/2019/12/03/test/10.png" alt><br><br>在浏览器中访问<br><br>首次进入会要求输入初始密码如下图，<br><br><img src="/2019/12/03/test/11.png" alt><br><br>初始密码在：/var/lib/jenkins/secrets/initialAdminPassword<br><img src="/2019/12/03/test/12.png" alt><br><br><img src="/2019/12/03/test/13.png" alt><br><br><img src="/2019/12/03/test/14.png" alt><br><br><img src="/2019/12/03/test/15.png" alt><br><br><img src="/2019/12/03/test/16.png" alt><br><br><img src="/2019/12/03/test/17.png" alt><br><br><img src="/2019/12/03/test/18.png" alt><br><br><img src="/2019/12/03/test/19.png" alt><br><br><img src="/2019/12/03/test/20.png" alt></p>
<h4 id="4">1.3安装subversion

<p>配置好yum源 直接yum安装subversion </p>
<pre><code>yum -y install subversion </code></pre><p><br><img src="/2019/12/03/test/21.png" alt><br><br>查看版本号</p>
<pre><code>svnserve --version</code></pre><p>递归创建目录</p>
<pre><code>mkdir  /data/svn/program   -p</code></pre><p><br><img src="/2019/12/03/test/22.png" alt><br><br>创建svn版本库</p>
<pre><code>svnadmin create /data/svn/program/</code></pre><p>配置账号：</p>
<pre><code>vim /data/svn/program/conf/passwd

    [manager]
    xinlong = xinlong</code></pre><p><br><img src="/2019/12/03/test/23.png" alt><br><br>配置权限：</p>
<pre><code>vim /data/svn/program/conf/authz

    [groups]
    manager = xinlong

    [program:/]
    @manager = rw</code></pre><p><br><img src="/2019/12/03/test/24.png" alt><br><br>配置服务：</p>
<pre><code>vim /data/svn/program/conf/svnserve.conf

    anon-access = none ## 匿名用户可读(关闭)
    auth-access = write ## 授权用户可写
    password-db = /data/svn/program/conf/passwd ## 指定账号配置文件   绝对路径
    authz-db = /data/svn/program/conf/authz ## 指定权限配置文件  绝对路径
    realm = /data/svn/program ## 指定版本库的认证域，即在登录时提示的认证域名称。缺省值：一个UUID(Universal Unique IDentifier，全局唯一标示)。</code></pre><p><br><img src="/2019/12/03/test/25.png" alt><br><br>启动subversion</p>
<pre><code>svnserve -d</code></pre><p>开通HTTP协议 安装httpd及其svn模块</p>
<pre><code>yum -y install httpd mod_dav_svn</code></pre><p><br><img src="/2019/12/03/test/26.png" alt><br><br>确认模块 dav/dav_svn 已加载<br><br>(Centos6  路径是/etc/httpd/conf/httpd.conf )<br></p>
<pre><code>grep -E &quot;dav_module&quot; /etc/httpd/conf.modules.d/00-dav.conf</code></pre><p><br><img src="/2019/12/03/test/27.png" alt><br><br>( Centos6  路径是 /etc/httpd/conf.d/subversion.conf )</p>
<pre><code>grep -E &quot;dav_svn_module&quot; /etc/httpd/conf.modules.d/10-subversion.conf</code></pre><p><br><img src="/2019/12/03/test/28.png" alt><br><br>SVN HTTP 配置</p>
<pre><code>vim /etc/httpd/conf/httpd.conf

    &lt;Location /program&gt;
    DAV svn
    SVNPath /data/svn/program
    AuthType Basic
    AuthName &quot;SVN program repository&quot;
    AuthUserFile /data/svn/program/conf/svn-auth.htpasswd
    AuthzSVNAccessFile /data/svn/program/conf/authz
    # Authorization: Authenticated users only
    # SVNListParentPath on
    Satisfy all
    Require valid-user
    &lt;/Location&gt;</code></pre><p><br><img src="/2019/12/03/test/29.png" alt><br><br>创建 SVN HTTP 用户</p>
<pre><code>-m 表示以 md5 加密密码

touch  /data/svn/program/conf/svn-auth.htpasswd</code></pre><p><br><img src="/2019/12/03/test/30.png" alt><br></p>
<pre><code>htpasswd -m  /data/svn/program/conf/svn-auth.htpasswd    xinlong</code></pre><p><br><img src="/2019/12/03/test/31.png" alt><br><br>启动httpd服务<br><br><img src="/2019/12/03/test/32.png" alt><br><br>客户端验证(<a href="http://xxx" target="_blank" rel="noopener">http://xxx</a>)</p>
<p>Windows 下使用 Chrome 浏览器访问: <a href="http://ip/program/，输入用户名" target="_blank" rel="noopener">http://ip/program/，输入用户名</a> chalres 及其密码，成功。<br><br><img src="/2019/12/03/test/33.png" alt><br><br><br>TortoiseSVN检测<br><br>右击  点击SVN checkout<br><br><img src="/2019/12/03/test/34.png" alt><br><br><img src="/2019/12/03/test/35.png" alt><br><br><img src="/2019/12/03/test/36.png" alt><br><br><img src="/2019/12/03/test/37.png" alt><br><br><img src="/2019/12/03/test/38.png" alt><br><br>然后右击 点击SVN commit</p>
<p><img src="/2019/12/03/test/39.png" alt><br><br><img src="/2019/12/03/test/40.png" alt><br><br><img src="/2019/12/03/test/41.png" alt><br><br><img src="/2019/12/03/test/42.png" alt><br><br>访问网站也可以看到</p>
<p><img src="/2019/12/03/test/43.png" alt><br><br><img src="/2019/12/03/test/44.png" alt><br></p>
<h3 id="进入Jenkins的主界面点击新建或创建一个新任务"><a href="#进入Jenkins的主界面点击新建或创建一个新任务" class="headerlink" title="进入Jenkins的主界面点击新建或创建一个新任务"></a>进入Jenkins的主界面点击新建或创建一个新任务<br></h3><p><br>输入项目的名字选择自由风格点击OK<br><br><img src="/2019/12/03/test/45.png" alt><br><br><img src="/2019/12/03/test/46.png" alt><br><br>选择源码管理中的Subversion(SVN) 填写第五步搭建SVN的地址(里面需要有代码)<br><br><img src="/2019/12/03/test/47.png" alt><br><br><img src="/2019/12/03/test/48.png" alt><br><br><img src="/2019/12/03/test/49.png" alt><br><br><img src="/2019/12/03/test/50.png" alt><br><br><img src="/2019/12/03/test/51.png" alt><br><br><img src="/2019/12/03/test/52.png" alt><br><br><img src="/2019/12/03/test/53.png" alt><br><br><img src="/2019/12/03/test/54.png" alt></p>
<pre><code>    #!/bin/bash
date=`date +&quot;%H:%M&quot;`
file=`ls -l  /data/program/  |grep db  |awk -F&quot; &quot; &apos;{print $(NF-1)}&apos;`
if [ &quot;$date&quot; == &quot;$file&quot; ];then
echo &quot;no&quot;
else
echo &quot;checkout&quot;
svn  checkout  http://192.168.1.240/program/  /data/install/   --username  xinlong
echo &quot;OK&quot; &gt;/data/ok.txt
echo &quot;OK&quot;
fi</code></pre><p><br><img src="/2019/12/03/test/55.png" alt><br><br><img src="/2019/12/03/test/56.png" alt><br><br><img src="/2019/12/03/test/57.png" alt><br><br><img src="/2019/12/03/test/58.png" alt><br><br><img src="/2019/12/03/test/59.png" alt><br><br><img src="/2019/12/03/test/60.png" alt><br><br><img src="/2019/12/03/test/61.png" alt><br><br><img src="/2019/12/03/test/62.png" alt><br><br><img src="/2019/12/03/test/63.png" alt><br><br><img src="/2019/12/03/test/64.png" alt><br><br><img src="/2019/12/03/test/65.png" alt><br><br><img src="/2019/12/03/test/66.png" alt><br><br><img src="/2019/12/03/test/67.png" alt><br><br><img src="/2019/12/03/test/68.png" alt><br><br><img src="/2019/12/03/test/69.png" alt><br></p>
<h3 id="下面步骤可以更改http-svn-为https"><a href="#下面步骤可以更改http-svn-为https" class="headerlink" title="下面步骤可以更改http svn 为https"></a>下面步骤可以更改http svn 为https</h3><p><br>开通 HTTPS 协议<br></p>
<h3 id="3-1-安装-ssl-模块"><a href="#3-1-安装-ssl-模块" class="headerlink" title="3.1 安装 ssl 模块"></a>3.1 安装 ssl 模块</h3><pre><code>yum -y install mod_ssl openssl</code></pre><h3 id="3-2-生成证书"><a href="#3-2-生成证书" class="headerlink" title="3.2 生成证书"></a>3.2 生成证书</h3><pre><code>mkdir /etc/httpd/ssl
cp nginx.key /etc/httpd/ssl/httpd.key
cp nginx.crt /etc/httpd/ssl/httpd.crt</code></pre><h3 id="3-3-配置证书"><a href="#3-3-配置证书" class="headerlink" title="3.3 配置证书"></a>3.3 配置证书</h3><pre><code>vim /etc/httpd/conf.d/ssl.conf
SSLCertificateFile    /etc/httpd/ssl/httpd.crt
SSLCertificateKeyFile /etc/httpd/ssl/httpd.key</code></pre><p>如果要停用 https 改用 http，只需注释下面的 SSLRequireSSL 一行。</p>
<pre><code>vim /etc/httpd/conf/httpd.conf

&lt;Location /program&gt;
    ## ......

    Require valid-user
    SSLRequireSSL
&lt;/Location&gt;</code></pre><h3 id="3-4-重启服务"><a href="#3-4-重启服务" class="headerlink" title="3.4 重启服务"></a>3.4 重启服务</h3><pre><code>systemctl restart httpd</code></pre><h3 id="3-5-防火墙放行"><a href="#3-5-防火墙放行" class="headerlink" title="3.5 防火墙放行"></a>3.5 防火墙放行</h3><pre><code>vim /etc/sysconfig/iptables
-A INPUT -m state --state NEW -m tcp -p tcp --dport 443 -j ACCEPT</code></pre><p>重启生效</p>
<pre><code>sudo systemctl restart iptables</code></pre><h3 id="3-6-客户端验证-https-xxx"><a href="#3-6-客户端验证-https-xxx" class="headerlink" title="3.6 客户端验证(https://xxx)"></a>3.6 客户端验证(<a href="https://xxx" target="_blank" rel="noopener">https://xxx</a>)</h3><p><br>Windows 下使用 Chrome 浏览器访问: <a href="https://ip/program/，输入用户名" target="_blank" rel="noopener">https://ip/program/，输入用户名</a> charles 及其密码，成功。此时只能使用 https 访问，http 已被禁用。<br><br><br><br><br><br><br></p>
</h4></h4></h4>]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>subversion</tag>
        <tag>jenkins</tag>
      </tags>
  </entry>
</search>
